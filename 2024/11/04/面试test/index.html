<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试test | 零度Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="面试问题1.使用RocketMQ降低数据库瓶颈，平稳数据库流量，防止大量请求瞬时进入数据库，从而导致数据库读写压力过大  异步处理：当应用收到请求需要写入或读取数据库时，首先将请求转化为消息并发送到RocketMQ。应用程序立即返回客户端一个确认信息，而不等待数据库操作完成。后台服务（消费者）订阅这些消息并异步地处理数据库操作。这样，数据库操作与用户请求解耦，请求处理速度加快，数据库压力得以">
<meta property="og:type" content="article">
<meta property="og:title" content="面试test">
<meta property="og:url" content="https://nil0330.github.io/2024/11/04/%E9%9D%A2%E8%AF%95test/index.html">
<meta property="og:site_name" content="零度Blog">
<meta property="og:description" content="面试问题1.使用RocketMQ降低数据库瓶颈，平稳数据库流量，防止大量请求瞬时进入数据库，从而导致数据库读写压力过大  异步处理：当应用收到请求需要写入或读取数据库时，首先将请求转化为消息并发送到RocketMQ。应用程序立即返回客户端一个确认信息，而不等待数据库操作完成。后台服务（消费者）订阅这些消息并异步地处理数据库操作。这样，数据库操作与用户请求解耦，请求处理速度加快，数据库压力得以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/tfy03/AppData/Roaming/Typora/typora-user-images/image-20241104220711910.png">
<meta property="og:image" content="https://raw.githubusercontent.com/nil0330/PicGo1/main/202411042154880.png">
<meta property="og:image" content="https://raw.githubusercontent.com/nil0330/PicGo1/main/202411042154603.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241104204433666.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240625110256050.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240625110303936.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240625110310813.png">
<meta property="og:image" content="file:///C:/Users/tfy03/AppData/Local/Temp/ksohtml10420/wps4.jpg">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240612205217711.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240616105542954.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730213650988.png">
<meta property="og:image" content="https://nil0330.github.io/.io//java-collection-hierarchy.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730215616476.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730215723003.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730215810186.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730215937369.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730220215344.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730220529306.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730220623959.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730220658347.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730220757201.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730220838582.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730221005029.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730221033424.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730221108295.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730221147445.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730221356071.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730221412919.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730221428256.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730221448953.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730222040231.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730222137182.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730222244598.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730222324394.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240730222442746.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731203414040.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731203555379.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731203614951.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731203702489.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731203742166.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731203828116.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731203949828.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731204046769.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731204551300.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731204629611.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731204732587.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731204831335.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731204919266.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731204941869.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205042084.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205058417.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205220193.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205315112.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205425277.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205538835.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205608590.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205640145.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205753607.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205825773.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731205938443.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731210157613.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731210545074.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731212826043.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731212859804.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731213148509.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731213135423.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731213442523.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731213629072.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731213636653.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731213651828.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731213936134.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731214044732.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731214224178.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731214233168.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731214328229.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731214410927.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731214922209.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731220709287.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731220811632.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731220900194.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731220907244.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731222122710-17224356861281.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731222135341.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731222213330.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240731222227565.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1684052228671-580f0c9d-44f7-44c2-b91c-47635a24a753.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1684052732599-1d837b94-0cb8-4e84-a7fc-b2fb2ffe818d.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1684052895297-36ab6420-98d5-4c73-9c6a-20366ef78717.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240621204025996.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240621204037065.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1684054233717-18dae7e9-35f7-48e4-a5d5-f8b361f30b7f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686488146259-ee0c8f14-ddf9-47cc-ae1d-2c2e47ecb8dd.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686488206175-797c5f61-603a-4c80-b4a1-cee34595e178.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1684054861140-1cb0a782-94b8-469f-9b9f-40e5d574d839.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240912172214959.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240622111511210.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240622111615657.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240622111646953.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240622112115764.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240622112603165.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623101905859.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623102046528.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623103127320.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623103718187.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623104012436.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623104151873.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623105230345.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623105244891.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623105303055.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623105836210.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623110018274.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623110031689.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623110224537.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623110231893.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623110240840.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623110301232.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623112420650.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240623105002765.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1684051087918-bc73f44f-94ce-4e9e-942c-c1dfa1b5e746.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1684051162880-bc7c922f-5349-4e77-97cf-5b8f486e50d6.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1684051219821-8497c577-9658-443f-bcf6-0ca30402df33.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1687873585249-2592d6b9-2f1b-47c2-832f-ba443a907dca.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687876206758-9ca4b574-77ff-4e50-8f5e-abc49c3645bc.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687878190994-a6b9faae-1660-4950-9f32-bd924602b90f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1696774042453-b60ad494-54f0-4c53-a7eb-4f960a72ef42.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687879137805-93fb8f3d-b53e-4b6f-bf42-4ff75a43649f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687879415806-d428be89-d6ef-4659-9eb4-0a14befb6445.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687879562495-a65b6474-9375-4f10-b767-2dc5707901b0.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687879657208-227b4da2-b6e6-49e1-b971-d0563683bab3.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687879708500-34e55b5e-9209-4fc1-a535-c0b5081605b5.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687880124935-e430cfcb-7f2a-4ce9-9f8a-989deb69d101.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687880425267-62216f78-d077-47a7-a1e9-48708143c0c5.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687880415037-87a84cf9-ef34-48c9-a586-757b3bff859d.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687880510124-ae75e40e-8280-49b4-bfcc-e9d2604f27d1.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687880912214-0455ecb2-ecab-4944-a613-e14caab9cebd.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687880995814-1c6835f3-896e-4102-b358-f6d43ad77812.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687881298833-7925c881-1ec7-4752-9f0f-a25bf7dd9f93.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687881342402-4d8b92d7-4195-42e3-8081-0010b4359359.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687881367503-6820bd50-6a8b-49be-b691-8740aa400571.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687881736669-b2ce3ac6-c7c7-47f1-bd8a-db27a76a7d49.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687881342402-4d8b92d7-4195-42e3-8081-0010b4359359-171945758396839.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687881848658-7a376f78-cb94-47aa-a030-db044aa1ad18.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687881437596-d0beec76-0a54-44c5-bf59-0c86af4af2bd.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1687882085902-f413b933-ce8b-40d9-88d5-468bf62b3db3.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1696776459691-710e3aca-3b94-4a56-8ebb-dd4744c4da05.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1696776799275-742b29d6-2f90-4ad4-97ed-b8fe632f0a4f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1696776886567-27b1b81e-afb7-480e-8cbf-a689e8469273.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627145215151.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627150326607.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627153254785.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627153345723.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627153536756.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627153631543.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627153644975.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627153708637.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627153753101.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154047390.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154108906.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154144844.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154234090.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154258036.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154341192.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154354659.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154401989.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154420411.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154517755.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154627310.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154638240.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154653713.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154702326.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154713682.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154725219.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154827080.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154839938.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154854703.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154917589.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154935704.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154944538.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627154955735.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155020521.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155101557.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155110718.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155128816.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155141476.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155204975.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155321466.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155341577.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155353650.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155410047.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155437337.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155521354.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155540643.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155556440.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155610597.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155625394.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155640773.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155653929.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155709204.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155742634.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155752541.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155801948.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155840523.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155944052.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627155955695.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160005827.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160316023.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160352688.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160638535.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160702405.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160719698.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160729938.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160750224.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160902023.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160913751.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160924711.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627160953992.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161011354.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161023240.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161032867.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161059368.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161110896.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161123339.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161133756.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161141989.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161156482.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627161223817.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1696329943218-3c381bbc-cd26-4b7d-8fb8-54f6620bd322.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1696330533790-29afbed8-989b-441e-aacf-646671f91794.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686065611648-65b3dfe9-a76c-482c-8369-d6a0c79247df.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1696330601106-20ea9e19-7914-48ad-bf1f-ca53404647d4.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1696330652541-44d5a206-2526-428b-b046-caddc42b79e7.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686066979801-781a8726-299b-4121-ae50-d16c39135ad6.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686152600719-a3bc7900-8b71-437d-bcb2-988d11f5f48f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686152911797-43a16110-bb76-471d-a637-e4652398be76.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686153054364-8008c25f-03da-4005-950c-6c1a54405dff.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686155313919-a1fc8983-d0a4-44b5-89c8-be33a3f8f199.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686156003982-fdbe1543-565b-4d48-bd51-13c8ced3c098.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686155473139-3c9cb804-8181-4387-9225-fe65cc504feb.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686155597468-4fe8d3ca-d06a-43db-94d7-b6ec401cea67.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686155579442-c3d8c9d6-61f2-4f09-aca1-e64d8215612a.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686155675435-040a3f52-7298-4082-a0a5-111a3ec5b970.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686209976321-d21f42a8-c880-4bad-a426-7c70e39d92dd.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686210057214-c83a524e-02e8-4035-a2e1-368bd8bd8dd4.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686210321555-fc48ca3c-13dd-42bd-804e-5353424aedef.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1686210549994-11e82fd4-5163-47fe-8f9e-1390afcb777e.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627210732942.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627211058658.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627211126778.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627211518365.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627211622382.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627211705087.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627211752786.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627212251250.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627212434223.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627212648229.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627212851590.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240627212905610.png">
<meta property="og:image" content="https://nil0330.github.io/.io//shejimoshi-20240309104732.png">
<meta property="og:image" content="https://nil0330.github.io/.io//shejimoshi-20240314083451.png">
<meta property="og:image" content="https://nil0330.github.io/.io//watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q2i5q2l5YmN6KGM,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.png">
<meta property="og:image" content="https://nil0330.github.io/.io//watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q2i5q2l5YmN6KGM,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1692879184758-c8e488ec-80a6-408a-96bf-1dfe1c0f4b5c.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692880369836-f4bc0cfd-2855-4435-b846-be1ec7b115ed.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692880732535-9ae1c5f8-395b-4afc-80c7-bb6036f980f2.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692887667160-3fcbe508-9da1-451e-8f55-476d2e95ee00.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692890899542-df7b7384-41db-4a7b-8a8a-c0730153e632.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692889700004-bff5fd35-06d2-40f3-9251-f54034a261a6.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692890136311-be25b8bb-9951-4524-af6b-485c61c30b8e.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692892642246-a075665f-3fa5-4ca3-8051-be63c751b222.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692893036052-76bbecc3-741f-43ba-a6f1-c0d15c7cebb8.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692893821809-f1f05bb6-a1e7-44e3-b2c8-56e3518f7a67.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692894214945-2b25da5e-e51f-499f-89eb-0f0088efb6e6.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692894313076-bf5de3ae-6a1d-484a-bc23-4f6f86584618.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694838682316-6244f4d6-f8b9-423e-8c3f-e16bf72f4141.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694797825724-8a10c660-6e1f-4cb9-9b35-17e7227b49bb.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694797928410-693cd25d-a7ed-45da-98b0-8a5ea90422fc.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694798178170-73f6143c-a83d-4d39-980f-04e05165bfa0.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694798650596-34e5c323-90b4-4b4c-881a-1ce2b4da2a60.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694798952659-63fd7155-8076-4dd4-bfc4-37164b47a6df.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694799542835-de99d806-780e-4fbd-a832-99998c728dbe.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1685189899438-884c817d-0ee5-4b7d-a540-6be3bb135975.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1691922802574-2086caa2-e1b9-48df-92c2-438451e0ad3e.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1691922818312-48ecbc4e-f52f-4598-92e4-def6f6c0e099.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694805584259-c669c4a3-5828-4ec4-a54a-72ffb66a95d4.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694805861395-ce36e294-2c1d-4508-a798-584fa8f4a9dc.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694841895526-7e9134fc-5820-46f4-9c62-43020b324f1d.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694842964385-ae96b9d4-090f-45e1-a6b5-86aff19eec6f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694845013491-2538e540-76c3-41ed-bcb4-2a4ef044de34.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694845092656-b6391f16-9e45-4946-b9f2-840976e23e81.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694845759730-03316ff3-f98b-41b3-ba50-9bc877ee7f7c.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694846361596-d143d38d-7f00-4a1b-8ef4-5ed783b7e733.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694847104347-948f1f30-fc74-477d-a625-439d3c0e4b9c.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694847189240-0306c1c5-8842-4dd5-b298-60900ffb24ab.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694849424519-aa3d5ee7-41c5-4943-ae19-c3b98f5e0d35.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694851387465-57d7e1f7-a968-4b05-98b1-146e83c68a5f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694856070259-99191750-30be-4698-95d4-39ffe3ee93ac.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694875066927-747fcc4d-4054-41ea-b941-74e9aab836ec.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694876581542-d9e90c2a-e4e7-4224-9a8b-5a6b06f5e2f8.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1695130491354-2805f3d6-1e7d-4dd7-b916-e398448e232e.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694881218413-cad8e188-0c7d-49e9-af92-09e7c3705429.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694881895993-0e8f3911-f315-40a8-856c-5048a037abcd.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694882377438-8c76afd6-ad37-4eab-a9d4-196dd82a3d70.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694880682366-4a1e72a0-cff5-45ca-834f-c405eab3d6b6.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1690708033267-a86c050b-7c97-435f-9d3e-ce03138bb685.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694930308758-683605d3-6cae-47a7-b2d4-7c72e3b73de8.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694932870774-221b3d26-6a96-4bd8-b015-0d9da08552dc.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694936653684-cf437a2a-a5cc-4c82-9339-de9f5d650e5f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694934319042-c125f3be-5ebb-4fed-90ba-5e19a005dc5d.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694934553162-c79fc616-5199-48f2-a766-1585b3adfbb1.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694935196869-922dfa70-cb91-4577-b33b-0eff6e2eede7.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694935301440-09120016-7b3f-4c8c-ad80-2952720816cb.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694936650475-f26874de-9316-4b1e-9660-88e6cf5b25bd.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694936308310-68841798-91c9-4cae-a4fb-722f0d57ae5f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694938909569-0647c645-2367-48fd-ae7a-7f663a35aa73.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694939418984-09f0d450-0f5e-4ae4-98c7-3b23599ffbf3.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694942089281-94e4bb4e-0c03-4f85-b604-faa88aadf6e5.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694942346761-98c8132b-b529-498d-a62a-dda06784d0fe.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694943058398-885e6af8-0946-40c0-ae28-eb1487b34152.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694943718419-8c2e2296-b2b1-4efe-89ba-6e1cd4201772.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694944213805-5d1c5c07-2f45-4a11-a7ad-58248d91508d.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1695138190521-256e0017-5473-4dbb-9127-ec884512eb60.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694946409060-202f0226-5002-40e2-aace-83fe76b57c1a.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694947486805-85c3db30-a485-481a-b892-fd2c78c75f67.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694947519712-d0b9de3a-6c1a-49d6-8ede-e2a4eae4ebf9.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1683730199674-c637177d-5e89-46a2-ae0a-f44872a9e44b.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240715221123379.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240716152725842.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240716152741562.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240716152751761.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240716153832398.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240716153848340.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806203851001.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806204120286.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806204302897.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806204434144.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806204555514.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806204654995.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806204954441.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806205047238.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806205129956.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806205213200.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806205308061.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806205515822.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806205555410.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806205744667.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806205915922.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806205955550.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806210042625.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806210512145.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806210644870.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806210801733.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806210942447.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806211045429.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806211248378.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806211548016.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806211658103.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806211745911.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806211944277.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806211959816.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806212858743.png">
<meta property="og:image" content="https://nil0330.github.io/.io//jmm.png">
<meta property="og:image" content="https://nil0330.github.io/.io//jmm2.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806213136995.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806213319525.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806213436274.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806213531245.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806213612798.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806213756431.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214128670.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214204698.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214315797.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214350681.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214432764.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214535891.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214625864.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214649864.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214741836.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214815645.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806214831024.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806215121986.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806215317518.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806215431769.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806215501665.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806215734191.png">
<meta property="og:image" content="https://nil0330.github.io/.io//synchronized-principle.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806215927498.png">
<meta property="og:image" content="https://nil0330.github.io/.io//synchronized-get-lock-code-block.png">
<meta property="og:image" content="https://nil0330.github.io/.io//synchronized-release-lock-block.png">
<meta property="og:image" content="https://nil0330.github.io/.io//synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806220440891.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806220614528.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806220635584.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806220816992.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806220840400.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806221028266.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806221052027.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806222216266.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806222509430.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240806222554130.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807104704712.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807150919760.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807150954676.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807151706615.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807151738135.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807151820525.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807151942068.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807152127592.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807152202413.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807152327825.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807152545875.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807152931380.png">
<meta property="og:image" content="https://nil0330.github.io/.io//relationship-between-thread-pool-parameters.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807153026353.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807153216032.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807153243032.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807153356441.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807153425419.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807153724024.png">
<meta property="og:image" content="https://nil0330.github.io/.io//threadpool-reject-2-threadpool-reject-01.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807153928206.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807154023052.png">
<meta property="og:image" content="https://nil0330.github.io/.io//threadpool-reject-2-threadpool-reject-02.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807154138797.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807154724914.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807154906742.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807155004085.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807155222181.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807155541527.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807155836708.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807160247918.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807160309445.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807161555643.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807161848763.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807162326121.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807162404164.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807162552793.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807162754733.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807162822073.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807220520603.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807220837054.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807220847409.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807221204693.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807221225144.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807221408318-17230400500777.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807221721323.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807221756634.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807221904724.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807221937926.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807222130794.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807222315219.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807222505929.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807222554927.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807222705800.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807223037090.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807223111846.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240807223220173.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801145041283.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801145504002.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801145809123.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193135085.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193147363.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193215137.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193239847.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193310365.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193432490.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193441648.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193504123.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193631618.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193852495.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801193947954.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801194045314.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801180314164.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801180322963.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801180432423.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801180447203.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801180838154.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801181250699.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801181628971.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801181808804.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801194255237.png">
<meta property="og:image" content="https://nil0330.github.io/.io//frc-365faceb5697f04f31399937c059c162.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801194457670.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801194700626.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801194717305.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801194829110.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801195916501.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801203559020.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801203959068.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801204033974.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801204101401.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801204140187.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801204403955.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801204422888.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801204543807.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801204851930.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801205500987.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801205937535.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801210157156.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801210211874.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801210227076.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801210341521.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801223222651.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801223459938.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801223524845.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801223601639.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801223817818.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801223848151.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801223938543.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224000095.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224032892.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224041585.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224151279.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224204975.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224312967.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224436509.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224542167.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224651990.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224810253.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801224837668.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801225914493.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801225956488.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230009538.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230021141.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230034456.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230121433.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230150766.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230158879.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230221563.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230229943.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230323551.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230359503.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230454533.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230539147.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230649386.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240801230728110.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802101005513.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802101346870.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802101418220.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802103503879.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802103605136.png">
<meta property="og:image" content="https://nil0330.github.io/.io//spring-transactional-rollbackfor.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802103636688.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802103857893.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802103916706.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802103954852.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802104017664.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802104026168.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802104102699.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802104126650.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240802104153457.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20220728183540954.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240808224148883.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240808224605447.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240808225105678.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901145040443.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901145142353.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901145355868.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901145456501.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901145600795.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901145718162.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901150009165.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901150343365.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901150351809.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901150413652.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901150427614.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901150520618.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901150532288.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240904153033974.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240904155636755.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901152810001.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901162828781.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240901220722551.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1692717057362-3de0b048-1963-4a27-9d6e-bf599ea8beff.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692879184758-c8e488ec-80a6-408a-96bf-1dfe1c0f4b5c.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692880369836-f4bc0cfd-2855-4435-b846-be1ec7b115ed.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692880732535-9ae1c5f8-395b-4afc-80c7-bb6036f980f2.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692887667160-3fcbe508-9da1-451e-8f55-476d2e95ee00.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692890899542-df7b7384-41db-4a7b-8a8a-c0730153e632.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692889700004-bff5fd35-06d2-40f3-9251-f54034a261a6.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692890136311-be25b8bb-9951-4524-af6b-485c61c30b8e.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694837770260-94c263b1-4042-48c7-be8f-4baf95cca63e.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692892642246-a075665f-3fa5-4ca3-8051-be63c751b222.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692893036052-76bbecc3-741f-43ba-a6f1-c0d15c7cebb8.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692893821809-f1f05bb6-a1e7-44e3-b2c8-56e3518f7a67.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692894214945-2b25da5e-e51f-499f-89eb-0f0088efb6e6.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1692894313076-bf5de3ae-6a1d-484a-bc23-4f6f86584618.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694838682316-6244f4d6-f8b9-423e-8c3f-e16bf72f4141.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694797825724-8a10c660-6e1f-4cb9-9b35-17e7227b49bb.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694797928410-693cd25d-a7ed-45da-98b0-8a5ea90422fc.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694798178170-73f6143c-a83d-4d39-980f-04e05165bfa0-172559465483410.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694798650596-34e5c323-90b4-4b4c-881a-1ce2b4da2a60.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694798952659-63fd7155-8076-4dd4-bfc4-37164b47a6df.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694799542835-de99d806-780e-4fbd-a832-99998c728dbe.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1685189899438-884c817d-0ee5-4b7d-a540-6be3bb135975.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1691922818312-48ecbc4e-f52f-4598-92e4-def6f6c0e099.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906120907266.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906120933712.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906120749625.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694805584259-c669c4a3-5828-4ec4-a54a-72ffb66a95d4.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694805861395-ce36e294-2c1d-4508-a798-584fa8f4a9dc.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906211031866.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694841895526-7e9134fc-5820-46f4-9c62-43020b324f1d.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906213921820.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694842964385-ae96b9d4-090f-45e1-a6b5-86aff19eec6f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906215217555.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906215316611.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906215418377.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694845013491-2538e540-76c3-41ed-bcb4-2a4ef044de34.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694845092656-b6391f16-9e45-4946-b9f2-840976e23e81.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694845759730-03316ff3-f98b-41b3-ba50-9bc877ee7f7c.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694846361596-d143d38d-7f00-4a1b-8ef4-5ed783b7e733.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694847189240-0306c1c5-8842-4dd5-b298-60900ffb24ab.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694849424519-aa3d5ee7-41c5-4943-ae19-c3b98f5e0d35.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694851387465-57d7e1f7-a968-4b05-98b1-146e83c68a5f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906221847328.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906222105494.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906222541709.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694856070259-99191750-30be-4698-95d4-39ffe3ee93ac.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906222648096.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906222901953.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906222925307.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694875066927-747fcc4d-4054-41ea-b941-74e9aab836ec.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694876581542-d9e90c2a-e4e7-4224-9a8b-5a6b06f5e2f8.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1695130491354-2805f3d6-1e7d-4dd7-b916-e398448e232e.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694881218413-cad8e188-0c7d-49e9-af92-09e7c3705429.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694881895993-0e8f3911-f315-40a8-856c-5048a037abcd.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694882377438-8c76afd6-ad37-4eab-a9d4-196dd82a3d70.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694880682366-4a1e72a0-cff5-45ca-834f-c405eab3d6b6.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1690708033267-a86c050b-7c97-435f-9d3e-ce03138bb685.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694930308758-683605d3-6cae-47a7-b2d4-7c72e3b73de8.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240906235730128.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694932870774-221b3d26-6a96-4bd8-b015-0d9da08552dc.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694936653684-cf437a2a-a5cc-4c82-9339-de9f5d650e5f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694934319042-c125f3be-5ebb-4fed-90ba-5e19a005dc5d.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694934553162-c79fc616-5199-48f2-a766-1585b3adfbb1.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694935196869-922dfa70-cb91-4577-b33b-0eff6e2eede7.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694935301440-09120016-7b3f-4c8c-ad80-2952720816cb.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694936650475-f26874de-9316-4b1e-9660-88e6cf5b25bd.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694936308310-68841798-91c9-4cae-a4fb-722f0d57ae5f.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694938909569-0647c645-2367-48fd-ae7a-7f663a35aa73.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694939418984-09f0d450-0f5e-4ae4-98c7-3b23599ffbf3.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240907162445243.png">
<meta property="og:image" content="https://nil0330.github.io/.io//1694942346761-98c8132b-b529-498d-a62a-dda06784d0fe.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694943058398-885e6af8-0946-40c0-ae28-eb1487b34152-172570005191997.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694943718419-8c2e2296-b2b1-4efe-89ba-6e1cd4201772.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694944213805-5d1c5c07-2f45-4a11-a7ad-58248d91508d.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1695138190521-256e0017-5473-4dbb-9127-ec884512eb60.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//1694946409060-202f0226-5002-40e2-aace-83fe76b57c1a.webp">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20240907220944814.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241011222513493.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014105008442.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014105044132.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014105105737.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014105226176.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014105245412.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014105325811.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014105355125.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014105607526.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014105632841.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014110033328.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014110252229.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014110333385.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014110402811.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014110656381.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014110709728.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014110840002.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014111205656.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014111321387.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014111332391.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014111449789.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014111625999.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014111845939.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014112027842.png">
<meta property="og:image" content="https://nil0330.github.io/.io//image-20241014112226968.png">
<meta property="article:published_time" content="2024-11-04T12:27:20.000Z">
<meta property="article:modified_time" content="2024-11-04T14:07:28.702Z">
<meta property="article:author" content="tfy">
<meta property="article:tag" content="IM">
<meta property="article:tag" content="小抖音">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/tfy03/AppData/Roaming/Typora/typora-user-images/image-20241104220711910.png">
  
    <link rel="alternate" href="/atom.xml" title="零度Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">零度Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://nil0330.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面试test" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/04/%E9%9D%A2%E8%AF%95test/" class="article-date">
  <time class="dt-published" datetime="2024-11-04T12:27:20.000Z" itemprop="datePublished">2024-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试test
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="C:/Users/tfy03/AppData/Roaming/Typora/typora-user-images/image-20241104220711910.png" alt="image-20241104220711910"><br><img src="https://raw.githubusercontent.com/nil0330/PicGo1/main/202411042154880.png" alt="image-20241104215433805"></p>
<p><img src="https://raw.githubusercontent.com/nil0330/PicGo1/main/202411042154603.png" alt="image-20241104215447175"></p>
<p><img src="/.io//image-20241104204433666.png" alt="image-20241104204433666"></p>
<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="1-使用RocketMQ降低数据库瓶颈，平稳数据库流量，防止大量请求瞬时进入数据库，从而导致数据库读写压力过大"><a href="#1-使用RocketMQ降低数据库瓶颈，平稳数据库流量，防止大量请求瞬时进入数据库，从而导致数据库读写压力过大" class="headerlink" title="1.使用RocketMQ降低数据库瓶颈，平稳数据库流量，防止大量请求瞬时进入数据库，从而导致数据库读写压力过大"></a>1.使用<strong>RocketMQ</strong>降低数据库瓶颈，平稳数据库流量，防止大量请求瞬时进入数据库，从而导致数据库读写压力过大</h2><blockquote>
<ol>
<li><strong>异步处理</strong>：当应用收到请求需要写入或读取数据库时，首先将请求转化为消息并发送到RocketMQ。应用程序立即返回客户端一个确认信息，而不等待数据库操作完成。后台服务（消费者）订阅这些消息并异步地处理数据库操作。这样，数据库操作与用户请求解耦，请求处理速度加快，数据库压力得以分散。</li>
<li><strong>流量削峰填谷</strong>：在高峰期，大量请求可以通过RocketMQ缓存起来，而不是直接冲击数据库。RocketMQ可以按照预设的速度（如通过消息消费速率限制）均匀地将消息分发给消费者，即使在请求量激增时也能保持数据库负载稳定，实现流量的平滑处理。</li>
<li><strong>批量处理</strong>：消费者可以从RocketMQ批量拉取消息，然后对这批消息执行数据库操作。相比于单条消息的处理，批量处理可以显著减少数据库的I&#x2F;O操作次数，提高处理效率。</li>
<li><strong>消息队列优先级与延迟消息</strong>：RocketMQ支持消息优先级设定和延迟消息功能。你可以根据业务需求设置不同优先级的消息，优先处理更重要的数据操作，或者设定消息在未来某个时间点才被消费，以更好地控制数据库负载。</li>
<li><strong>事务消息</strong>：RocketMQ支持事务消息功能，可以在确保数据库操作和消息发送之间保持事务一致性的同时，通过两阶段提交模式来优化处理流程，避免因消息处理失败而导致的数据不一致问题。</li>
<li><strong>数据库分片与读写分离</strong>：虽然这不是RocketMQ直接提供的功能，但在使用RocketMQ设计系统时，可以结合数据库分片和读写分离策略，进一步提升数据库处理能力。RocketMQ可以作为桥梁，智能地将写操作导向主库，读操作导向从库，减轻单一数据库的压力。</li>
</ol>
</blockquote>
<h2 id="2-针对用户评论，用户点赞和用户关注这三个数据库表，添加了-MySQL-分表功能，降低单表的存储压力"><a href="#2-针对用户评论，用户点赞和用户关注这三个数据库表，添加了-MySQL-分表功能，降低单表的存储压力" class="headerlink" title="2.针对用户评论，用户点赞和用户关注这三个数据库表，添加了 MySQL 分表功能，降低单表的存储压力"></a>2.针对用户评论，用户点赞和用户关注这三个数据库表，<strong>添加了 MySQL 分表功能</strong>，降低单表的存储压力</h2><p>分库分表主要针对的是评论表、点赞表和关注表。因为在短视频App中，用户评论、用户点赞和用户关注这种操作是比较多的，相应的就会产生很多数据存入到对应的表中，如果只设计一张表，那么就会导致表中数据很多，查询时会比较慢，所以需要分库分表。</p>
<p>（2）评论表：3张；点赞表：3张；关注表：16张。</p>
<p>（3）·评论表结构：	</p>
<p><img src="/.io//image-20240625110256050.png" alt="image-20240625110256050"></p>
<p>·点赞表结构：	</p>
<p><img src="/.io//image-20240625110303936.png" alt="image-20240625110303936"></p>
<p>·关注表结构：</p>
<p><img src="/.io//image-20240625110310813.png" alt="image-20240625110310813"></p>
<p>（4）·评论表根据评论视频id进行分表操作：因为业务中有根据视频id获取视频全部评论的需求（视频播放页面），如果根据视频id进行分表操作的话，可以确保同一视频的所有评论都在一个表中。</p>
<p>·点赞表根据点赞用户id进行分表操作：因为业务中有根据用户id获取用户点赞视频列表的需求（用户详情页中的），如果根据用户id进行分表操作的话，可以确保同一用户的所有点赞视频数据都在一个表中。</p>
<p>·关注表根据关注者用户id进行分表操作（根据被关注者用户id进行分表操作）：因为业务中有根据用户id获取当前用户关注列表的需求（还有根据用户id获取谁关注了当前用户），此时就可以确保我们要查的数据在同一个表中。</p>
<p>（1）这四种表的主键都不是用的数据库自增主键，而是用雪花算法来生成的。</p>
<p>（5）使用这个组件进行实现：</p>
<p><img src="file:///C:\Users\tfy03\AppData\Local\Temp\ksohtml10420\wps4.jpg" alt="img"> </p>
<p> <strong>1.分库分表依据？</strong></p>
<p> <strong>1.MySQL分库分表有几种方式？</strong></p>
<p>（1）垂直切分：垂直切分是根据业务来拆分数据库，同一类业务的数据表拆分到一个独立的数据库，另一类的数据表拆分到其他数据库。垂直切分可以降低单节点数据库的负载。原来所有数据表都放在一个数据库节点上，因此所有的读写请求也都发到这个MySQL上面，所以数据库的负载太高。如果把一个节点的数据库拆分成多个MySQL数据库，这样就可以有效的降低每个MySQL数据库的负载。但是垂直切分无法解决表记录太多的情况，因此使用水平切分进行“缩表”。</p>
<p>（2）水平切分：水平切分是按照某个字段的某种规则，进行一个数据分片，把一张大的数据表拆分成多张小的数据表，这样就可以起到缩表的效果了。（注意：其实MySQL水平拆分出来的数据表也可以放在同一个MySQL结点上，因为MySQL自带一种数据分区的技术，可以把一张表按照特殊的规则切分存储在不同的目录下，因此我们可以利用MySQL分区技术将一张表的数据切分存储在不同的磁盘上，这样就能有效提高数据库的效率）。</p>
<p><img src="/.io//image-20240612205217711.png" alt="image-20240612205217711"></p>
<p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。</p>
<p>（1）哈希分片：求指定key（比如id）的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。</p>
<p>（2）范围分片：按照特定的范围区间（比如时间区间、ID区间）来分配数据，比如将id为1<del>299999的记录分到第一个表，300000</del>599999的分到第二个表。范围分片适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。</p>
<p>（3）地理位置分片：很多NewSQL数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。</p>
<p> <strong>1.分库分表会带来什么问题呢？</strong></p>
<p>（1）join操作：同一个数据库中的表分布在了不同的数据库中，导致无法使用join操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</p>
<p>（2）事务问题：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。需要使用分布式事务。</p>
<p>（3）分布式id：分库之后，数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。这个时候，我们就需要为我们的系统引入分布式id了。</p>
<h2 id="3-使用Redis对用户已发布视频进行缓存，同时针对缓存更新、缓存穿透、缓存雪崩、缓存击穿等问题做了处理"><a href="#3-使用Redis对用户已发布视频进行缓存，同时针对缓存更新、缓存穿透、缓存雪崩、缓存击穿等问题做了处理" class="headerlink" title="3.使用Redis对用户已发布视频进行缓存，同时针对缓存更新、缓存穿透、缓存雪崩、缓存击穿等问题做了处理"></a>3.使用<strong>Redis</strong>对用户已发布视频进行缓存，同时针对<strong>缓存更新、缓存穿透、缓存雪崩、缓存击穿</strong>等问题做了处理</h2><blockquote>
<p>缓存更新：</p>
<p>首先如果缓存中的事务过期了，那么首先按照约定好的键获取互斥锁，如果没有获得互斥锁，睡眠50ms再次执行，然后通过springAOP调用代理对象从新执行。这个是因为代理对象内部调用原始对象的方法时，应该确保环绕的切面逻辑包括@transcational的切面逻辑执行。</p>
<p>加上互斥锁之后。需要二次判断缓存中的内容，以防等待的过程中上一个线程已经执行完了，然后才是执行真正的缓存重建逻辑</p>
<p>从数据库加载进缓存中</p>
</blockquote>
<blockquote>
<p>缓存穿透</p>
<p>项目里存在缓存重建的操作，一些如果在数据库没有搜索到的场景，就要在缓存中的键中放入默认值，防止每次的访问都直接打进数据库中</p>
<p>具体什么时候保存这个默认值，通常遵循以下几个原则：</p>
<ol>
<li><strong>首次查询数据库后</strong>：当应用第一次查询数据库，发现某条数据不存在时，就应该将这个“默认值”（如null、空对象或者特定错误码）存入缓存，并设置一个合理的过期时间。这个时间不宜过长，以免数据更新后，缓存中的无效信息持续影响业务。</li>
<li><strong>在数据不存在的逻辑处理中</strong>：在服务端的逻辑处理中，明确判断出数据库中没有对应数据后，紧跟着就应该执行缓存“默认值”的保存操作。这通常是在数据访问层或服务层实现。’</li>
<li><strong>利用缓存失效策略</strong>：如果之前已经将“默认值”存入缓存，当这个缓存项接近过期时，下一次请求如果再次查找不到数据，应该重新触发保存“默认值”的逻辑，以延续防止缓存穿透的保护效果。</li>
<li><strong>批量处理或定时任务</strong>：对于一些可能频繁发生缓存穿透的热点数据，可以考虑使用批量处理或定时任务的方式，定期检查和刷新这类数据的缓存状态，确保即使数据不存在，也有一个有效的“默认值”在缓存中。</li>
</ol>
</blockquote>
<p>核心思想就是在确定数据库中没有所需数据的时候，主动在缓存中存放一个表示：”无数据”的占位符，并合理控制其声明周期，以此减少不必要的数据库访问</p>
<blockquote>
<p>缓存雪崩：指的是当大量缓存的过期时间同一时间失效或者Redis宕机，这时大量的用户请求就会直接打到数据库中</p>
<p>发生缓存雪崩有两个原因：</p>
<p>·大量数据同时过期；</p>
<p>·Redis故障宕机；</p>
<p>（1）解决方案：</p>
<p><strong>①：针对大量数据同时过期：</strong></p>
<p>·<strong>均匀设置过期时间</strong>：可以在对缓存数据设置过期时间时，给这些数据的过期时间<strong>加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p>
<p>·<strong>互斥锁</strong>：当业务线程在处理用户请求时，如果发现访问的数据不在Redis里，就加个互斥锁，保证同一时间内只有一个请求来访问数据库、构建缓存（从数据库读取数据，再将数据更新到Redis里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>
<p>&#x3D;&#x3D;这样就能保证当缓存过期的时候，只有一个线程去执行服务，然后重建缓存&#x3D;&#x3D;</p>
<p>·双key策略：对缓存数据可以使用两个key，一个是主key，会设置过期时间，一个是备key，不会设置过期，它们只是key不一样，但是value值是一样的，相当于给缓存数据做了个副本。当业务线程访问不到主key的缓存数据时，就直接返回备key的缓存数据，然后在更新缓存的时候，同时更新主key和备key的数据。</p>
<p>&#x3D;&#x3D;设置备用key里面为相同数据&#x3D;&#x3D;</p>
<p><strong>②：针对Redis故障宕机：</strong></p>
<p>·服务熔断：因为Redis故障宕机而导致缓存雪崩问题时，我们可以启动服务熔断机制，暂停业务应用对缓存服务的访问，直接返回错误，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到Redis恢复正常后，再允许业务应用访问缓存服务。</p>
<p>·构建Redis缓存高可靠集群：通过主从节点的方式构建Redis缓存高可靠集群。如果Redis缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于Redis故障宕机而导致的缓存雪崩问题。</p>
</blockquote>
<blockquote>
<p>缓存击穿：</p>
<p>（1）概念：如果缓存中的<strong>某个热点数据过期了</strong>，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。</p>
<p>（2）解决方案：</p>
<p>·互斥锁方案，（Redis中使用SetNX方法设置一个状态位，表示这是一种锁定状态）<strong>，保证同一时间只有一个业务线程请求数据库，更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</strong></p>
<p>·<strong>不给热点数据设置过期时间，由后台异步更新缓存</strong>，或者在热点数据准备<strong>要过期前</strong>，提前通知<strong>后台线程更新缓存</strong>以及<strong>重新设置过期时间</strong>；</p>
</blockquote>
<h2 id="4-项目前台系统用户登录模块设计，采用-Redis＋Token-实现项目的单点登录和自动续期功能。基于过滤器实现用户登录校验和状态更新功能"><a href="#4-项目前台系统用户登录模块设计，采用-Redis＋Token-实现项目的单点登录和自动续期功能。基于过滤器实现用户登录校验和状态更新功能" class="headerlink" title="4.项目前台系统用户登录模块设计，采用 Redis＋Token 实现项目的单点登录和自动续期功能。基于过滤器实现用户登录校验和状态更新功能"></a>4.项目前台系统用户登录模块设计，采用 <strong>Redis＋Token</strong> 实现项目的单点登录和自动续期功能。基于过滤器实现用户登录校验和状态更新功能</h2><blockquote>
<p>单点登录：指的是只需登录一次就能够访问所有信任的系统</p>
<p>用户首先是拿着用户名和密码进行访问，首先去数据库查询是否有这个用户，如果用户存在拿取用户id然后从redis中获取token如果能获取到说明在登录状态中，爆出不需要重复登录的异常，如果token为空则利用JwtUtils来生成token，然后设置进redis中</p>
<p>之后的所有操作是通过拦截器拦截所有对于登录后业务层访问的请求，然后直接更新redis中的过期时间实现续期的效果</p>
</blockquote>
<h2 id="5-使用-CompletableFuture进行异步任务编排，提升接口响应时间"><a href="#5-使用-CompletableFuture进行异步任务编排，提升接口响应时间" class="headerlink" title="5.使用 CompletableFuture进行异步任务编排，提升接口响应时间"></a>5.使用 <strong>CompletableFuture进行异步任务</strong>编排，提升接口响应时间</h2><blockquote>
<p>在Java中，<code>CompletableFuture</code> 是Java 8引入的一个强大工具，用于实现非阻塞的异步编程和任务的编排。它可以帮助我们更高效地利用系统资源，特别是在需要处理IO密集型操作（如从数据库中并行获取视频素材）时，能显著提升接口响应时间。下面是如何使用<code>CompletableFuture</code>来并行查询数据库以获取视频素材的示例步骤：</p>
<h3 id="1-创建异步任务"><a href="#1-创建异步任务" class="headerlink" title="1. 创建异步任务"></a>1. 创建异步任务</h3><p>首先，我们需要定义一个方法来从数据库中获取视频素材，然后使用<code>CompletableFuture.supplyAsync()</code>将其转换为异步任务。这里假设有一个<code>VideoService</code>类提供了这样的查询方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoService</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> List&lt;VideoMaterial&gt; <span class="title function_">getVideoMaterialsFromDatabase</span><span class="params">(String query)</span> &#123;</span><br><span class="line">     <span class="comment">// 假设这是从数据库查询的方法</span></span><br><span class="line">     <span class="keyword">return</span> database.query(query);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-异步执行查询"><a href="#2-异步执行查询" class="headerlink" title="2. 异步执行查询"></a>2. 异步执行查询</h3><p>接下来，我们将使用<code>CompletableFuture</code>来异步执行查询操作。如果需要并行获取多组不同的视频素材，可以为每组查询创建一个独立的<code>CompletableFuture</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoController</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> VideoService videoService;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">VideoController</span><span class="params">(VideoService videoService)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.videoService = videoService;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> CompletableFuture&lt;List&lt;VideoMaterial&gt;&gt; <span class="title function_">fetchVideosAsync</span><span class="params">(String query1, String query2)</span> &#123;</span><br><span class="line">     CompletableFuture&lt;List&lt;VideoMaterial&gt;&gt; videosFuture1 = CompletableFuture.supplyAsync(() -&gt; videoService.getVideoMaterialsFromDatabase(query1));</span><br><span class="line">     CompletableFuture&lt;List&lt;VideoMaterial&gt;&gt; videosFuture2 = CompletableFuture.supplyAsync(() -&gt; videoService.getVideoMaterialsFromDatabase(query2));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 可以继续添加更多的查询任务</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果需要合并结果，可以使用thenCombine或者其他组合方法</span></span><br><span class="line">     <span class="keyword">return</span> videosFuture1.thenCombine(videosFuture2, (list1, list2) -&gt; &#123;</span><br><span class="line">         List&lt;VideoMaterial&gt; combinedList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list1);</span><br><span class="line">         combinedList.addAll(list2);</span><br><span class="line">         <span class="keyword">return</span> combinedList; <span class="comment">// 返回合并后的视频素材列表</span></span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-结果编排与处理"><a href="#3-结果编排与处理" class="headerlink" title="3. 结果编排与处理"></a>3. 结果编排与处理</h3><p>上面的代码展示了如何启动两个异步查询，并使用<code>thenCombine</code>方法来合并这两个查询的结果。这样做的好处是，这两个查询任务是并行执行的，可以充分利用系统资源，从而减少总的等待时间。一旦两个任务都完成，<code>thenCombine</code>提供的函数会被调用来合并结果。</p>
<h3 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h3><p>在实际应用中，还需要考虑异常处理。可以通过<code>exceptionally</code>或<code>handle</code>方法来捕获并处理可能出现的异常情况。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过使用<code>CompletableFuture</code>，我们可以很容易地对数据库查询这类耗时操作进行异步处理，从而提高接口的响应速度。它支持灵活的任务编排机制，使得我们可以并行执行多个查询任务，并在所有任务完成后合并结果，非常适合于提升涉及大量数据库交互的服务性能。</p>
</blockquote>
<h2 id="6-使用RocketMQ降低数据库瓶颈，平稳数据库流量，并配合Sentinel进行限流和熔断降级"><a href="#6-使用RocketMQ降低数据库瓶颈，平稳数据库流量，并配合Sentinel进行限流和熔断降级" class="headerlink" title="6.使用RocketMQ降低数据库瓶颈，平稳数据库流量，并配合Sentinel进行限流和熔断降级"></a>6.使用<strong>RocketMQ</strong>降低数据库瓶颈，平稳数据库流量，并配合<strong>Sentinel</strong>进行限流和熔断降级</h2><h2 id="7-采用推拉结合的模式实现视频Feed流，分摊服务端压力，提高响应能力"><a href="#7-采用推拉结合的模式实现视频Feed流，分摊服务端压力，提高响应能力" class="headerlink" title="7.采用推拉结合的模式实现视频Feed流，分摊服务端压力，提高响应能力"></a>7.采用<strong>推拉结合</strong>的模式实现视频Feed流，分摊服务端压力，提高响应能力</h2><h2 id="8-运用Seata框架来达成分布式事务管理的目标，通过采用其AT模式来确保不同模块间操作的最终一致性"><a href="#8-运用Seata框架来达成分布式事务管理的目标，通过采用其AT模式来确保不同模块间操作的最终一致性" class="headerlink" title="8.运用Seata框架来达成分布式事务管理的目标，通过采用其AT模式来确保不同模块间操作的最终一致性"></a>8.运用<strong>Seata框架</strong>来达成分布式事务管理的目标，通过采用其<strong>AT模式</strong>来确保不同模块间操作的最终一致性</h2><h1 id="IM问题"><a href="#IM问题" class="headerlink" title="IM问题"></a>IM问题</h1><h2 id="1-借助微信开发平台API，通过微信扫码登录，实现Channel与OpenId的关联，并以带参二维码方式进行呈现"><a href="#1-借助微信开发平台API，通过微信扫码登录，实现Channel与OpenId的关联，并以带参二维码方式进行呈现" class="headerlink" title="1.借助微信开发平台API，通过微信扫码登录，实现Channel与OpenId的关联，并以带参二维码方式进行呈现"></a>1.借助微信开发平台API，通过<strong>微信扫码登录，</strong>实现Channel与OpenId的关联，并以带参二维码方式进行呈现</h2><p><img src="/.io//image-20240616105542954.png" alt="image-20240616105542954"></p>
<p>首先用户会发送登录请求，然后前端会根据channel生成login_map&lt;channel，null&gt;后端会随机生成事件码，然后将事件码和channel保存起来WAIT_LOGIN_MAP&lt;Code,Channel&gt;,并返回二维码</p>
<p>然后用户扫码登录，触发微信sdk中的scanHandler，拿到其中的openid和code，如果用户已经存在那么直接登录，如果没有那么首先在redis中保存openid和code之间的关系，发送授权链接，授权过后，通过openid找到user，把头像信息等传入数据库，然后触发登录逻辑，登录逻辑就是如果找到数据库中有这个用户，那么删掉WAIT_LOGIN_MAP&lt;Code,Channel&gt;（&#x3D;&#x3D;这里的map一定得是线程安全的，如果用普通的hashmap来put的时候容易造成，ConcurrentModifiedException&#x3D;&#x3D;），补齐LOGIN_MAP中的&lt;channel,uid&gt;，登录成功设置token的消息</p>
<p>然后用户扫码关注后，后端会在redis中更新上线列表，也会在本地列表中存储一份uid-&gt;channel的map映射，以便后续推送消息，然后生成token，前端就会token，之后就可以通过这个token来进行请求，这大概就是登录流程</p>
<p>以上为登录流程 </p>
<h3 id="1-对应的集合问题"><a href="#1-对应的集合问题" class="headerlink" title="1.对应的集合问题"></a>1.对应的集合问题</h3><p><img src="/.io//image-20240730213650988.png" alt="image-20240730213650988"></p>
<p><img src="/.io//java-collection-hierarchy.png" alt="Java 集合框架概览"></p>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>
<p><img src="/.io//image-20240730215616476.png" alt="image-20240730215616476"></p>
<p><img src="/.io//image-20240730215723003.png" alt="image-20240730215723003"></p>
<p><img src="/.io//image-20240730215810186.png" alt="image-20240730215810186"></p>
<p><img src="/.io//image-20240730215937369.png" alt="image-20240730215937369"></p>
<p><img src="/.io//image-20240730220215344.png" alt="image-20240730220215344"></p>
<p><img src="/.io//image-20240730220529306.png" alt="image-20240730220529306"></p>
<p><img src="/.io//image-20240730220623959.png" alt="image-20240730220623959"></p>
<p><img src="/.io//image-20240730220658347.png" alt="image-20240730220658347"></p>
<p><img src="/.io//image-20240730220757201.png" alt="image-20240730220757201"></p>
<p>内部使用了synchronized</p>
<p><img src="/.io//image-20240730220838582.png" alt="image-20240730220838582"></p>
<p><img src="/.io//image-20240730221005029.png" alt="image-20240730221005029"></p>
<p><img src="/.io//image-20240730221033424.png" alt="image-20240730221033424"></p>
<p><img src="/.io//image-20240730221108295.png" alt="image-20240730221108295"></p>
<p><img src="/.io//image-20240730221147445.png" alt="image-20240730221147445"></p>
<p><img src="/.io//image-20240730221356071.png" alt="image-20240730221356071"></p>
<p><img src="/.io//image-20240730221412919.png" alt="image-20240730221412919"></p>
<p><img src="/.io//image-20240730221428256.png" alt="image-20240730221428256"></p>
<p><img src="/.io//image-20240730221448953.png" alt="image-20240730221448953"></p>
<p><img src="/.io//image-20240730222040231.png" alt="image-20240730222040231"></p>
<p><img src="/.io//image-20240730222137182.png" alt="image-20240730222137182"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原始数组:&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.reverse(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.sort(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;定制排序后：&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240730222244598.png" alt="image-20240730222244598"></p>
<p><img src="/.io//image-20240730222324394.png" alt="image-20240730222324394"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//依旧是当小于传入的数据时返回-1，所以顺序保持不变所以是</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240730222442746.png" alt="image-20240730222442746"></p>
<p><img src="/.io//image-20240731203414040.png" alt="image-20240731203414040"></p>
<p><img src="/.io//image-20240731203555379.png" alt="image-20240731203555379"></p>
<p><img src="/.io//image-20240731203614951.png" alt="image-20240731203614951"></p>
<p><img src="/.io//image-20240731203702489.png" alt="image-20240731203702489"></p>
<p><img src="/.io//image-20240731203742166.png" alt="image-20240731203742166"></p>
<p><img src="/.io//image-20240731203828116.png" alt="image-20240731203828116"></p>
<p><img src="/.io//image-20240731203949828.png" alt="image-20240731203949828"></p>
<p><img src="/.io//image-20240731204046769.png" alt="image-20240731204046769"></p>
<h4 id="map重点"><a href="#map重点" class="headerlink" title="!map重点"></a>!map重点</h4><p><img src="/.io//image-20240731204551300.png" alt="image-20240731204551300"></p>
<p><img src="/.io//image-20240731204629611.png" alt="image-20240731204629611"></p>
<p><img src="/.io//image-20240731204732587.png" alt="image-20240731204732587"></p>
<p><img src="/.io//image-20240731204831335.png" alt="image-20240731204831335"></p>
<p><img src="/.io//image-20240731204919266.png" alt="image-20240731204919266"></p>
<p><img src="/.io//image-20240731204941869.png" alt="image-20240731204941869"></p>
<p><img src="/.io//image-20240731205042084.png" alt="image-20240731205042084"></p>
<p><img src="/.io//image-20240731205058417.png" alt="image-20240731205058417"></p>
<p><img src="/.io//image-20240731205220193.png" alt="image-20240731205220193"></p>
<p><img src="/.io//image-20240731205315112.png" alt="image-20240731205315112"></p>
<p><img src="/.io//image-20240731205425277.png" alt="image-20240731205425277"></p>
<p><img src="/.io//image-20240731205538835.png" alt="image-20240731205538835"></p>
<p><img src="/.io//image-20240731205608590.png" alt="image-20240731205608590"></p>
<p><img src="/.io//image-20240731205640145.png" alt="image-20240731205640145"></p>
<p><img src="/.io//image-20240731205753607.png" alt="image-20240731205753607"></p>
<p><img src="/.io//image-20240731205825773.png" alt="image-20240731205825773"></p>
<p><img src="/.io//image-20240731205938443.png" alt="image-20240731205938443"></p>
<p><img src="/.io//image-20240731210157613.png" alt="image-20240731210157613"></p>
<p><img src="/.io//image-20240731210545074.png" alt="image-20240731210545074"></p>
<p><img src="/.io//image-20240731212826043.png" alt="image-20240731212826043"></p>
<p><img src="/.io//image-20240731212859804.png" alt="image-20240731212859804"></p>
<p><img src="/.io//image-20240731213148509.png" alt="image-20240731213148509"></p>
<p><img src="/.io//image-20240731213135423.png" alt="image-20240731213135423"></p>
<p><img src="/.io//image-20240731213442523.png" alt="image-20240731213442523"></p>
<p><img src="/.io//image-20240731213629072.png" alt="image-20240731213629072"></p>
<p><img src="/.io//image-20240731213636653.png" alt="image-20240731213636653"></p>
<p><img src="/.io//image-20240731213651828.png" alt="image-20240731213651828"></p>
<p><img src="/.io//image-20240731213936134.png" alt="image-20240731213936134"></p>
<p><img src="/.io//image-20240731214044732.png" alt="image-20240731214044732"></p>
<p><img src="/.io//image-20240731214224178.png" alt="image-20240731214224178"></p>
<p><img src="/.io//image-20240731214233168.png" alt="image-20240731214233168"></p>
<p><img src="/.io//image-20240731214328229.png" alt="image-20240731214328229"></p>
<p><img src="/.io//image-20240731214410927.png" alt="image-20240731214410927"></p>
<p><img src="/.io//image-20240731214922209.png" alt="image-20240731214922209"></p>
<p><img src="/.io//image-20240731220709287.png" alt="image-20240731220709287"></p>
<p><img src="/.io//image-20240731220811632.png" alt="image-20240731220811632"></p>
<p><img src="/.io//image-20240731220900194.png" alt="image-20240731220900194"></p>
<p><img src="/.io//image-20240731220907244.png" alt="image-20240731220907244"></p>
<h4 id="集合中哪些是线程安全的哪些不是"><a href="#集合中哪些是线程安全的哪些不是" class="headerlink" title="集合中哪些是线程安全的哪些不是"></a>集合中哪些是线程安全的哪些不是</h4><p><img src="/.io//image-20240731222122710-17224356861281.png" alt="image-20240731222122710"></p>
<p><img src="/.io//image-20240731222135341.png" alt="image-20240731222135341"></p>
<p><img src="/.io//image-20240731222213330.png" alt="image-20240731222213330"></p>
<p><img src="/.io//image-20240731222227565.png" alt="image-20240731222227565"></p>
<h2 id="2-基于interceptor拦截器，判断是否拥有有效token、黑名单拦截以及用户登陆时IP属地收集"><a href="#2-基于interceptor拦截器，判断是否拥有有效token、黑名单拦截以及用户登陆时IP属地收集" class="headerlink" title="2.基于interceptor拦截器，判断是否拥有有效token、黑名单拦截以及用户登陆时IP属地收集"></a>2.基于interceptor拦截器，判断是否拥有有效token、黑名单拦截以及用户登陆时IP属地收集</h2><blockquote>
<p>1.事先导入黑名单表<br>&#x3D;&#x3D;包括拉黑目标是ip还是uid&#x3D;&#x3D;</p>
<p>2.通过拦截器对每一个接口都进行黑名单的校验</p>
</blockquote>
<p><strong>判断权限功能</strong></p>
<blockquote>
<p>首先每一个用户登录的时候我们都会通过ONLINE_WS_MAP中获取uid，然后将uid、token、以及是否拥有管理员权限类型、然后向用户推送他的个人信息（头像，ip归属地，权限等等）</p>
</blockquote>
<p><strong>拉黑功能</strong></p>
<blockquote>
<p>拉黑传进来的&#x3D;&#x3D;参数直接是一个uid&#x3D;&#x3D;，首先判断&#x3D;&#x3D;当前用户是不是一个管理员&#x3D;&#x3D;，判断成功之后执行拉黑逻辑</p>
<p>设置&#x3D;&#x3D;拉黑目标的类型（uid&#x2F;ip），和具体的对象&#x3D;&#x3D;，然后先保存进数据库中，然后从用户表中拉取他的IP信息，&#x3D;&#x3D;再在黑名单中插入他的IP信息，然后发送拉黑事件&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;第一个监听&#x3D;&#x3D;的是发送消息的方法回&#x3D;&#x3D;把拉黑的用户发送给每一个websocket链接上的用户&#x3D;&#x3D;（这里调用了连接池 @Qualifier(ThreadPoolConfig.WS_EXECUTOR)并行的发送消息）</p>
<p>&#x3D;&#x3D;另一个监听的是设置用户状态方法，监听到在user表中把状态设置为1&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;还有一个事件是将BlackMap取消掉&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(WS_EXECUTOR)</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">websocketExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);<span class="comment">//线程池优雅停机</span></span><br><span class="line">    executor.setCorePoolSize(<span class="number">16</span>);</span><br><span class="line">    executor.setMaxPoolSize(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//因为主要是io操作所以线程池多一点</span></span><br><span class="line">    executor.setQueueCapacity(<span class="number">1000</span>);</span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">&quot;websocket-executor-&quot;</span>);</span><br><span class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());<span class="comment">//满了直接丢弃</span></span><br><span class="line">    executor.setThreadFactory(<span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>((executor)));</span><br><span class="line">    executor.initialize();</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>黑名单拦截器操作</p>
<p>preHandle中&#x3D;&#x3D;首先从数据库中取到不同类型的黑名单map&#x3D;&#x3D;，用于用的&#x3D;&#x3D;@Cacheable所以可以使用内在的缓存&#x3D;&#x3D;</p>
<p>他会首先从RequestHolder（存在刚登陆的uid和ip）中取得现在登录的uid，如果BlackMap中存在的话直接拒绝访问</p>
<p>然后在WebMvcConfigurer中进行配置</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;Inteceptor每次都是从数据中查询到然后在服务器中存储一下（这样做的目的是保证时效性，防止黑名单里面的是旧数据）&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;每次拉黑的时候，都会声明一个事务，然后对应的事件监听，比如说清楚服务器里存储的黑名单，准备从interceptor中重新拉取，移除在线用户，并在数据表中标注是黑名单&#x3D;&#x3D;</p>
</blockquote>
<p><strong>是否拥有有效token</strong></p>
<blockquote>
<p>&#x3D;&#x3D;prehandle中从request中的请求头中获取token，如果token是个有效的token就提取出有效的uid&#x3D;&#x3D;</p>
<p>然后就在request中设置uid设置登录态</p>
<p>如果&#x3D;&#x3D;不是一个有效的uid，那么就看他访问的是不是一个公共路径，如果是的话也放行，如果不是拒绝访问然后返回401&#x3D;&#x3D;</p>
</blockquote>
<p><strong>几个拦截器的配置顺序</strong></p>
<blockquote>
<p>&#x3D;&#x3D;先是tokenInterceptor获得用户登录token，拿到有效的uid&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;然后是collectorInterceptor将uid和ip设置进RequestHolder&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;最后是黑名单的interceptor进行一个拦截&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>项目的认证有两个渠道</p>
<p><strong>http请求携带token</strong>：&#x3D;&#x3D;每次请求都需要用户携带token，在拦截器中进行校验&#x3D;&#x3D;</p>
<p><strong>对channel链接进行认证</strong>：用户在首次扫码登录的时候，后端会将channel链接关联上uid，但是channel并不稳定，前端只要刷新页面，channel就断开了，然后就需要进行重连了，&#x3D;&#x3D;重连的channel怎么知道他是谁，但是前端登录后就保存了token，他拿着token从channel发送过来认证一下，就又能重新建立起channel和uid之间的映射关系了，以下是他具体的实现逻辑&#x3D;&#x3D;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 心跳检查</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">idleStateEvent</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 读空闲</span></span><br><span class="line">        <span class="keyword">if</span> (idleStateEvent.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            <span class="comment">// 关闭用户的连接</span></span><br><span class="line">            userOffLine(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> WebSocketServerProtocolHandler.HandshakeComplete) &#123;</span><br><span class="line">        <span class="comment">//如果事件是握手完成之后</span></span><br><span class="line">        <span class="built_in">this</span>.webSocketService.connect(ctx.channel());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">	@Override</span></span><br><span class="line"><span class="comment">		public void connect(Channel channel) &#123;</span></span><br><span class="line"><span class="comment">    		ONLINE_WS_MAP.put(channel, new WSChannelExtraDTO());</span></span><br><span class="line"><span class="comment">    		这里放入的是一个channel和null</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> NettyUtil.getAttr(ctx.channel(), NettyUtil.TOKEN);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(token)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.webSocketService.authorize(ctx.channel(), <span class="keyword">new</span> <span class="title class_">WSAuthorize</span>(token));</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">@Override</span></span><br><span class="line"><span class="comment">public void authorize(Channel channel, WSAuthorize wsAuthorize) &#123;</span></span><br><span class="line"><span class="comment">    //校验token</span></span><br><span class="line"><span class="comment">    boolean verifySuccess = loginService.verify(wsAuthorize.getToken());</span></span><br><span class="line"><span class="comment">    if (verifySuccess) &#123;//用户校验成功给用户登录</span></span><br><span class="line"><span class="comment">        User user = userDao.getById(loginService.getValidUid(wsAuthorize.getToken()));</span></span><br><span class="line"><span class="comment">        loginSuccess(channel, user, wsAuthorize.getToken());</span></span><br><span class="line"><span class="comment">    &#125; else &#123; //让前端的token失效</span></span><br><span class="line"><span class="comment">        sendMsg(channel, WSAdapter.buildInvalidateTokenResp());</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>额外补充，&#x3D;&#x3D;ip地址获取是如何做到的&#x3D;&#x3D;	</p>
<p>首先是两种方式：1.http请求 2.websocket请求</p>
<p><strong>第一种对于controller</strong>的请求是可以通过拦截器的方式直接将IP设置设置进上下文的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">RequestInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>();</span><br><span class="line"> info.setUid(Optional.ofNullable(request.getAttribute(TokenInterceptor.ATTRIBUTE_UID)).map(Object::toString).map(Long::parseLong).orElse(<span class="literal">null</span>));</span><br><span class="line"> info.setIp(ServletUtil.getClientIP(request));</span><br><span class="line"> RequestHolder.set(info);</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;ip在请求头中都会携带。直接用hutool的工具类获取ip&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getClientIP</span><span class="params">(HttpServletRequest request, String... otherHeaderNames)</span> &#123;</span><br><span class="line"> String[] headers = &#123;<span class="string">&quot;X-Forwarded-For&quot;</span>, <span class="string">&quot;X-Real-IP&quot;</span>, <span class="string">&quot;Proxy-Client-IP&quot;</span>, <span class="string">&quot;WL-Proxy-Client-IP&quot;</span>, <span class="string">&quot;HTTP_CLIENT_IP&quot;</span>, <span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>&#125;;</span><br><span class="line"> <span class="keyword">if</span> (ArrayUtil.isNotEmpty(otherHeaderNames)) &#123;</span><br><span class="line">     headers = ArrayUtil.addAll(headers, otherHeaderNames);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> getClientIPByHeader(request, headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有点要注意，如果我们开启了nginx来带来请求，&#x3D;&#x3D;需要在nginx里面保存用户真实ip到<code>X-Real-IP</code>，否则你拿到的就是nginx的ip地址了&#x3D;&#x3D;。</p>
<p><img src="/.io//1684052228671-580f0c9d-44f7-44c2-b91c-47635a24a753.webp" alt="image.png"></p>
<p><strong>websocket请求</strong></p>
<p>对于websocket请求获取ip就会麻烦一些。</p>
<p>首先我们要有个概念，&#x3D;&#x3D;websocket初期会借助http来升级协议&#x3D;&#x3D;。&#x3D;&#x3D;所以我们需要在http升级之前就要获取ip，并且将用户ip保存起来&#x3D;&#x3D;</p>
<p><img src="/.io//1684052732599-1d837b94-0cb8-4e84-a7fc-b2fb2ffe818d.png" alt="img"></p>
<p>在协议升级前，我们加入了<code>HttpHeadersHandler</code>处理器，这时候还是能拿到http的request的，想获取header很容易。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpHeadersHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> AttributeKey&lt;String&gt; key = AttributeKey.valueOf(<span class="string">&quot;Id&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FullHttpRequest) &#123;</span><br><span class="line">         <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> ((FullHttpRequest) msg).headers();</span><br><span class="line">         <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> headers.get(<span class="string">&quot;X-Real-IP&quot;</span>);</span><br><span class="line">         <span class="keyword">if</span> (Objects.isNull(ip)) &#123;<span class="comment">//如果没经过nginx，就直接获取远端地址</span></span><br><span class="line">             <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> (InetSocketAddress) ctx.channel().remoteAddress();</span><br><span class="line">             ip = address.getAddress().getHostAddress();</span><br><span class="line">         &#125;</span><br><span class="line">         NettyUtil.setAttr(ctx.channel(), NettyUtil.IP, ip);</span><br><span class="line">     &#125;</span><br><span class="line">     ctx.fireChannelRead(msg);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后协议升级后，请求就不会再走这个处理器了，所以我们的ip需要保存起来。&#x3D;&#x3D;正好<code>channel</code>其实有个附件功能，我们可以直接把ip作为附件保存进channel。之后每次的websocket请求，都用的是同一个<code>channel</code>，从里面取ip就好了&#x3D;&#x3D;。</p>
<p>正好所有连接的用户，我们也会去保存uid和channel的映射关系，保存这个channel。</p>
<p><img src="/.io//1684052895297-36ab6420-98d5-4c73-9c6a-20366ef78717.webp" alt="image.png"></p>
</blockquote>
<p><strong>ip的更新</strong></p>
<p>ip的更新时机其实也是一个话题。总不可能用户每次请求，我们都要去做一次ip更新吧，那也太麻烦了。我们可以在用户首次认证去更新ip即可。</p>
<p>用户首次认证有两个场景：</p>
<p>1.&#x3D;&#x3D;用户浏览器里有token。前端拿它来后端认证下即可&#x3D;&#x3D;。</p>
<p>2.&#x3D;&#x3D;用户token失效重新扫码登录&#x3D;&#x3D;。</p>
<p>针对于第二种登录，扫码的时候是wx给我们的回调。&#x3D;&#x3D;我们通过回调的code，去找出code对应的连接<code>channel</code>。再从<code>channel</code>里找到用户信息以及ip&#x3D;&#x3D;</p>
<p>我们可以选用用户认证的时间点来触发ip的刷新。</p>
<p><strong>ip的保存</strong></p>
<p>ip的信息其实是个比较复杂的数据类型，我们可以直接通过json格式存成user的扩展信息。</p>
<p><img src="/.io//image-20240621204025996.png" alt="image-20240621204025996"></p>
<p><img src="/.io//image-20240621204037065.png" alt="image-20240621204037065"></p>
<p><strong>ip归属地进行解析</strong></p>
<p><strong>基于淘宝开放接口</strong></p>
<p>淘宝有提供了ip地址库的查询接口，大家可以自己postman测试下。</p>
<p>淘宝的IP地址库API可以提供IP地址的详细信息，包括国家、省份、城市、经纬度等。使用淘宝的IP地址库API，可以轻松获取IP地址的详细信息，从而获取IP地址的地理位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --request GET \</span><br><span class="line">  --url <span class="string">&#x27;https://ip.taobao.com/outGetIpInfo?ip=112.96.166.230&amp;accessKey=alibaba-inc&#x27;</span> \</span><br><span class="line">  --header <span class="string">&#x27;content-type: application/json&#x27;</span> </span><br></pre></td></tr></table></figure>

<p><img src="/.io//1684054233717-18dae7e9-35f7-48e4-a5d5-f8b361f30b7f.webp" alt="image.png"></p>
<p>淘宝自己的地址库会一直更新，比较全。而且没有任何依赖，直接接口解析。它只有一个缺点，就是有频控o(╥﹏╥)o。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;the request over max qps for user ,the accessKey=alibaba-inc&quot;</span>,</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步解析淘宝ip接口框架实现</strong></p>
<p>用户的登录请求，对于后台来说都是并发的。</p>
<img src="/.io//1686488146259-ee0c8f14-ddf9-47cc-ae1d-2c2e47ecb8dd.webp" alt="image.png" style="zoom: 67%;">

<p>&#x3D;&#x3D;每个用户的请求线程都会阻塞等待ip解析完，才响应结果&#x3D;&#x3D;。&#x3D;&#x3D;并且并发的情况下解析ip容易出现淘宝ip的限流。&#x3D;&#x3D;</p>
<p>根据淘宝ip的限流，我们会想到框架需要的几个重点</p>
<p>1.<code>排队</code>，&#x3D;&#x3D;把ip解析当成一个任务，存进队列，一个个排队解析，不要太快。&#x3D;&#x3D;</p>
<p>2.<code>重试</code>，&#x3D;&#x3D;针对某个任务解析失败，需要能重试，但是重试也要有最大次数&#x3D;&#x3D;。</p>
<p>3.<code>异步</code>，&#x3D;&#x3D;淘宝解析接口很慢，异步解析，不要影响主任务。&#x3D;&#x3D;</p>
<p>综上，&#x3D;&#x3D;用<code>coreSize</code>为1的线程池，就可以比较方便的实现这一点。线程池的队列用来排队。&#x3D;&#x3D;</p>
<p>同时还能异步执行。</p>
<img src="/.io//1686488206175-797c5f61-603a-4c80-b4a1-cee34595e178.webp" alt="image.png" style="zoom:67%;">

<p>我们创建了一个这样的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">500</span>), <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;refresh-ipDetail&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>：核心线程数（corePoolSize）设置为<span class="number">1</span>，这意味着线程池至少会保持<span class="number">1</span>个线程活跃，即使它们处于空闲状态。</span><br><span class="line"><span class="number">1</span>：最大线程数（maximumPoolSize）也设置为<span class="number">1</span>，表明线程池最多只能拥有<span class="number">1</span>个线程。这实际上限制了所有任务都将排队等待，因为线程池大小不会根据负载动态扩展。</span><br><span class="line"><span class="number">0L</span>, TimeUnit.MILLISECONDS：空闲线程存活时间设置为<span class="number">0</span>，单位是毫秒。这意味着多余的线程（如果有，但根据上面的设置其实没有多余线程）将会立即终止，不过由于最大和最小线程数相同，这个设置实际上不起作用。</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">500</span>)：工作队列（BlockingQueue）使用的是LinkedBlockingQueue，其容量设置为<span class="number">500</span>。这意味着如果线程池中的线程正在忙，新的任务会被放到这个队列中等待，直到线程变为可用。队列满时，根据线程池的饱和策略，新来的任务可能会被拒绝。</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;refresh-ipDetail&quot;</span>, <span class="literal">false</span>)：自定义线程工厂，用于创建线程并给线程命名。这里的线程命名前缀为<span class="string">&quot;refresh-ipDetail&quot;</span>，并且第二个参数<span class="literal">false</span>表示不使线程成为守护线程（即当程序退出时，这些线程不会自动结束）。</span><br></pre></td></tr></table></figure>

<p>同时写了个ip解析的接口</p>
<p><img src="/.io//1684054861140-1cb0a782-94b8-469f-9b9f-40e5d574d839.webp" alt="image.png"></p>
<p>需要刷新ip详情的用户，把uid扔进来就好了，最小的耦合业务。</p>
<p>里面具体的实现逻辑</p>
<p>com.abin.mallchat.common.user.service.impl.IpServiceImpl#refreshIpDetailAsync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> IpDetail <span class="title function_">TryGetIpDetailOrNullTreeTimes</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">IpDetail</span> <span class="variable">ipDetail</span> <span class="operator">=</span> getIpDetailOrNull(ip);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(ipDetail)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ipDetail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个任务最多重试三次，被频控后，就休眠一会儿再重试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IpDetail <span class="title function_">getIpDetailOrNull</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> HttpUtil.get(<span class="string">&quot;https://ip.taobao.com/outGetIpInfo?ip=&quot;</span> + ip + <span class="string">&quot;&amp;accessKey=alibaba-inc&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IpResult&lt;IpDetail&gt; result = JSONUtil.toBean(body, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;IpResult&lt;IpDetail&gt;&gt;() &#123;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result.getData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个线程是并不是spring管理的线程池，所以需要我们自己来实现优雅停机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS)) &#123;<span class="comment">//最多等30秒，处理不完就拉倒</span></span><br><span class="line">        <span class="keyword">if</span> (log.isErrorEnabled()) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Timed out while waiting for executor [&#123;&#125;] to terminate&quot;</span>, executor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池的任务总是不安全的，会有解析失败的小概率事件，但是失败又如何，下一次登录重新解析就好了嘛</p>
<p>实际上的实现是当用户准备上线进行更新时，发送事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOnlineListener</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpService ipService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存用户的上线信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@TransactionalEventListener(classes = UserOnlineEvent.class,phase = TransactionPhase.AFTER_COMMIT,fallbackExecution = true)</span></span><br><span class="line">    <span class="comment">//fallbackExecution = true注解的意思是，当没有事务在运行时，这个事件应该被处理 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveDB</span><span class="params">(UserOnlineEvent event)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> event.getUser();</span><br><span class="line">        <span class="type">User</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        update.setId(user.getId());</span><br><span class="line">        update.setLastOptTime(user.getLastOptTime());</span><br><span class="line">        update.setIpInfo(user.getIpInfo());</span><br><span class="line">        update.setActiveStatus(UserActiveStatusEnum.ONLINE.getStatus());</span><br><span class="line">        userDao.updateById(update);</span><br><span class="line">        <span class="comment">//到这之前都是在更新用户的信息</span></span><br><span class="line">        <span class="comment">//更新完之后才进行用户ip详情的更新，一定要先入库再去解析</span></span><br><span class="line">        ipService.refreshIpDetailAsync(user.getId());</span><br><span class="line">        <span class="comment">//只传uid进去，保证每个方法之间是最小依赖</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是ip解析的框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IpService</span>, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">500</span>), <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;refresh-ipDetail&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">//创建了一个线程池，池内核心线程数（即便他们是空闲的，也是存在的，除非线程池显式关闭）为1，最大线程数为1，空闲线程存活时间是0，因为核心线程数和最大线程数都是1，这个值设置没有意义，LinkedBlockingQueue任务队列，虽然初始容量指定了大小，但是依然是无界队列，</span></span><br><span class="line">    <span class="comment">//new NamedThreadFactory(&quot;refresh-ipDetail&quot;, false)，工厂用来创建线程，命名为refresh-ipDetail，方便寻找，false指定的是不设置守护线程，守护线程为了服务用户而存在，不执行主要任务，用户线程结束后，守护线程会立即退出</span></span><br><span class="line">    <span class="comment">//用户线程是执行应用程序的主要任务，jvm会等待用户线程执行完毕了才会结束</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshIpDetailAsync</span><span class="params">(Long uid)</span> &#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//异步执行任务</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.getById(uid);</span><br><span class="line">            <span class="type">IPInfo</span> <span class="variable">ipInfo</span> <span class="operator">=</span> user.getIpInfo();</span><br><span class="line">            <span class="comment">//首先去拿取用户的IP信息</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(ipInfo)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//是空的话直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> ipInfo.needRefreshIp();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(ip)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是空的证明不用刷新</span></span><br><span class="line">            <span class="type">IPDetail</span> <span class="variable">ipDetail</span> <span class="operator">=</span> tryGetIpDetailOrNullTreeTimes(ip);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(ipDetail)) &#123;</span><br><span class="line">                <span class="comment">//如果ipdetail已经获得了</span></span><br><span class="line">                ipInfo.refreshIpDeTail(ipDetail);</span><br><span class="line">                <span class="type">User</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                update.setId(uid);</span><br><span class="line">                update.setIpInfo(ipInfo);</span><br><span class="line">                userDao.updateById(update);</span><br><span class="line">                <span class="comment">//更新数据库</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IPDetail <span class="title function_">tryGetIpDetailOrNullTreeTimes</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">IPDetail</span> <span class="variable">ipDetail</span> <span class="operator">=</span> getIpDetailOrNull(ip);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(ipDetail)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ipDetail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;tryGetIpDetailOrNullTreeTimes InterruptedException&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IPDetail <span class="title function_">getIpDetailOrNull</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://ip.taobao.com/outGetIpInfo?ip=&quot;</span> + ip + <span class="string">&quot;&amp;accessKey=alibaba-inc&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> HttpUtil.get(url);</span><br><span class="line">            ApiResult&lt;IPDetail&gt; result = JsonUtils.toObj(data, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;ApiResult&lt;IPDetail&gt;&gt;() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> result.getData();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="type">IPDetail</span> <span class="variable">ipDetail</span> <span class="operator">=</span> tryGetIpDetailOrNullTreeTimes(<span class="string">&quot;222.27.255.211&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (Objects.nonNull(ipDetail)) &#123;</span><br><span class="line">                    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;第%d次成功，目前耗时%dms&quot;</span>, finalI, (date.getTime() - begin.getTime())));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//优雅停机implements DisposableBean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="comment">//这个方法平和地关闭ExecutorService，不再接受新的任务提交，但它会等待已提交的任务执行完毕。</span></span><br><span class="line">        <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS)) &#123;<span class="comment">//最多等30秒，处理不完就拉倒</span></span><br><span class="line">            <span class="keyword">if</span> (log.isErrorEnabled()) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Timed out while waiting for executor [&#123;&#125;] to terminate&quot;</span>, executor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-集中项目管理线程池，采用异步执行优化接口响应速度。确保线程池的异常捕获与优雅停机，提升系统稳定性"><a href="#3-集中项目管理线程池，采用异步执行优化接口响应速度。确保线程池的异常捕获与优雅停机，提升系统稳定性" class="headerlink" title="3.集中项目管理线程池，采用异步执行优化接口响应速度。确保线程池的异常捕获与优雅停机，提升系统稳定性"></a>3.集中项目管理线程池，采用<strong>异步执行</strong>优化接口响应速度。确保线程池的<strong>异常捕获</strong>与<strong>优雅停机</strong>，提升系统稳定性</h2><p><strong>面临问题描述：</strong>频繁的创建、销毁线程和线程池，会给系统带来额外的开销，未经池化及统一管理的线程，则会导致<strong>系统内线程数上限不可控。</strong></p>
<p>这样随着访问数增加，系统内线程数持续增长，cpu负载逐步提高，极端的情况下会吃满cpu资源，最后导致整个服务不可用。</p>
<p><img src="/.io//image-20240912172214959.png" alt="image-20240912172214959"></p>
<blockquote>
<p><strong>自建线程池</strong></p>
<p>在<code>ThreadPoolConfig</code>中，创建我们项目统一的线程池，并交给spring管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 线程池配置</span></span><br><span class="line"><span class="comment"> * Author: &lt;a href=&quot;https://github.com/zongzibinbin&quot;&gt;abin&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Date: 2023-04-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="comment">//能够将特定的方法委派给一个独立的线程或线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span>, </span><br><span class="line">SecureInvokeConfigurer &#123;</span><br><span class="line"><span class="comment">//AsyncConfigurer 接口很可能来源于Spring框架，特别是与异步方法执行相关的部分。当一个类实现这个接口时，它需要提供配置来定制Spring的异步任务执行器（TaskExecutor，也就是线程池）。这包括定义线程池的大小、队列策略等，以便于Spring在处理@Async注解的方法时，能够根据这些配置来调度任务。实现此接口通常需要覆盖如下方法：    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现了AsyncConfigurer接口要求实现getAsyncExecutor方法来提供运行实例，Spring利用这个执行器来运行所有标记了@Async的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SecureInvokeConfigurer 是自定义的一个接口</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目共用线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MALLCHAT_EXECUTOR</span> <span class="operator">=</span> <span class="string">&quot;mallchatExecutor&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * websocket通信线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WS_EXECUTOR</span> <span class="operator">=</span> <span class="string">&quot;websocketExecutor&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AICHAT_EXECUTOR</span> <span class="operator">=</span> <span class="string">&quot;aichatExecutor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mallchatExecutor();</span><br><span class="line">        <span class="comment">//返回这个方法创建的线程池实例，这个线程池将成为应用默认的异步执行器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getSecureInvokeExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mallchatExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(MALLCHAT_EXECUTOR)</span></span><br><span class="line">    <span class="comment">//告诉Spring此方法将定义一个名为mallchatExecutor的bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="comment">//表示当一个类下面有多个bean的时候，通过标注@Primary，可以告诉Spring这个是首选的</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">mallchatExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">//创建并配置了一个`ThreadPoolTaskExecutor`实例，这是一个Spring提供的一个灵活线程池实现</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//设置核心线程池数10，这些线程会一直存活</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//设置最大线程数也是10</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//设置任务队列的容量是200</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;mallchat-executor-&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<span class="comment">//满了调用线程执行，认为重要任务</span></span><br><span class="line">        <span class="comment">//配置了拒绝策略，当线程池达到最大线程数且队列也满的同时，该策略会让调用者所在的线程直接执行任务，“逻辑”是如果任务提交者本身有能力执行任务，那么就由它自己来执行，而不是放弃或抛出异常</span></span><br><span class="line">        executor.setThreadFactory(<span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(executor));</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(WS_EXECUTOR)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">websocketExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">16</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">16</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">1000</span>);<span class="comment">//支持同时推送1000人</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;websocket-executor-&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());<span class="comment">//满了直接丢弃，默认为不重要消息推送</span></span><br><span class="line">        executor.setThreadFactory(<span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(executor));</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(AICHAT_EXECUTOR)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">chatAiExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">15</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;aichat-executor-&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());<span class="comment">//满了直接丢弃，默认为不重要消息推送</span></span><br><span class="line">        executor.setThreadFactory(<span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>(executor));</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们的线程池没有用**<code>Excutors</code>快速创建。是因为<code>Excutors</code>创建的线程池用的无界队列，有oom（内存耗尽）的风险（小考点）**。</p>
</blockquote>
<p><strong>优雅停机</strong></p>
<p>首先怎么感知到项目快结束了，spring有生命周期，比如说destroy，我们这里用的是spring的线程池，ThreadPoolExecutor是juc的线程池</p>
<img src="/.io//image-20240622111511210.png" alt="image-20240622111511210" style="zoom:150%;">

<p>继承了这个类</p>
<p><img src="/.io//image-20240622111615657.png" alt="image-20240622111615657"></p>
<p>这个类又实现了这个方法的接口，这个是在Spring框架的应用上下文中，<strong>当一个Bean不再需要时</strong>（比如应用关闭时或Bean定义从容器中移除时），<strong>Spring会自动调用实现了<code>DisposableBean</code>接口的Bean的<code>destroy</code>方法</strong>。这是一种让Bean能够自我清理资源的机制，增强了应用程序的健壮性和资源管理能力。</p>
<p><img src="/.io//image-20240622111646953.png" alt="image-20240622111646953"></p>
<p>在这里去进行一个优雅关闭</p>
<p><img src="/.io//image-20240622112115764.png" alt="image-20240622112115764"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Shutting down ExecutorService&quot;</span> + (<span class="built_in">this</span>.beanName != <span class="literal">null</span> ? <span class="string">&quot; &#x27;&quot;</span> + <span class="built_in">this</span>.beanName + <span class="string">&quot;&#x27;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.executor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//先判断现在的线程池不是空的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.waitForTasksToCompleteOnShutdown) &#123;</span><br><span class="line">            <span class="comment">//如果这个标记位是true的话就优雅停机，不再接收新任务，等待所有提交了的任务执行完成之后再关闭线程池</span></span><br><span class="line">            <span class="built_in">this</span>.executor.shutdown();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//负责把所有的运行的线程依次停止</span></span><br><span class="line">            <span class="comment">//这不仅停止接收新任务，还会尝试中断正在执行的任务，并返回一个包含尚未开始执行的任务的列表。随后，对于列表中的每一个任务，调用 cancelRemainingTask(remainingTask) 方法进行额外的处理（可能是记录、清理工作等）。</span></span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="built_in">this</span>.executor.shutdownNow().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">remainingTask</span> <span class="operator">=</span> (Runnable)var1.next();</span><br><span class="line">                <span class="built_in">this</span>.cancelRemainingTask(remainingTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.awaitTerminationIfNecessary(<span class="built_in">this</span>.executor);</span><br><span class="line">        <span class="comment">//这个方法通常会根据配置等待一段时间，以确保线程池中的任务确实已经完成执行或超时。这是一种确保资源被正确释放的机制。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240622112603165.png" alt="image-20240622112603165"></p>
<p>先判断是不是Future类型，是的话尝试中断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.awaitTerminationIfNecessary(<span class="built_in">this</span>.executor);</span><br></pre></td></tr></table></figure>

<p>他会是等待时间走完结束进程	</p>
<p><strong>异常捕获</strong></p>
<p><img src="/.io//image-20240623101905859.png" alt="image-20240623101905859"></p>
<blockquote>
<p>子进程的报错不打印报错日志，只在控制台输出，部署在服务器上时，问题就会被隐藏</p>
</blockquote>
<blockquote>
<p><strong>首先子线程的异常会抛到哪里去？</strong></p>
<p>如果一个异常未被捕获，从线程中抛了出来。JVM会回调一个方法<code>dispatchUncaughtException</code></p>
</blockquote>
<p><img src="/.io//image-20240623102046528.png" alt="image-20240623102046528"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch an uncaught exception to the handler. This method is</span></span><br><span class="line"><span class="comment"> * intended to be called only by the JVM.	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchUncaughtException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="built_in">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向处理器分发一个未捕获的异常。此方法预期仅由JVM调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchUncaughtException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的未捕获异常处理器并调用其uncaughtException方法，</span></span><br><span class="line">    <span class="comment">// 传入当前线程自身（this）和发生的异常（e），以此来处理未捕获的异常情况。</span></span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="built_in">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the handler invoked when this thread abruptly terminates</span></span><br><span class="line"><span class="comment"> * due to an uncaught exception. If this thread has not had an</span></span><br><span class="line"><span class="comment"> * uncaught exception handler explicitly set then this thread&#x27;s</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;ThreadGroup&lt;/tt&gt; object is returned, unless this thread</span></span><br><span class="line"><span class="comment"> * has terminated, in which case &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the uncaught exception handler for this thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title function_">getUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uncaughtExceptionHandler != <span class="literal">null</span> ?</span><br><span class="line">        uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当此线程因未捕获的异常而突然终止时调用的处理器。</span></span><br><span class="line"><span class="comment"> * 如果没有为此线程明确设置未捕获异常处理器，则返回此线程的</span></span><br><span class="line"><span class="comment"> * `&lt;tt&gt;ThreadGroup&lt;/tt&gt;`对象，除非此线程已经终止，在这种情况下返回&lt;tt&gt;null&lt;/tt&gt;。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此线程的未捕获异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title function_">getUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果uncaughtExceptionHandler不为空，则返回它；</span></span><br><span class="line">    <span class="comment">// 否则，返回此线程所属的线程组对象（除非线程已终止，此时返回null）。</span></span><br><span class="line">    <span class="keyword">return</span> uncaughtExceptionHandler != <span class="literal">null</span> ?</span><br><span class="line">        uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null unless explicitly set</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"><span class="comment">//这个默认是没有设置的</span></span><br></pre></td></tr></table></figure>
<p>所以处理的一般是group</p>
<p><img src="/.io//image-20240623103127320.png" alt="image-20240623103127320"></p>
<p>alt+F7可以查看在哪里被读取了或更改了</p>
<p><img src="/.io//image-20240623103718187.png" alt="image-20240623103718187"></p>
<p><img src="/.io//image-20240623104012436.png" alt="image-20240623104012436"></p>
<p>它被他实现了</p>
<p><img src="/.io//image-20240623104151873.png" alt="image-20240623104151873"></p>
<p>进入到threadgroup里，发现这个报错和我们的终端显示的是一致的，所以如果我们不去进行设置，就会最终打印到这里来</p>
<p>所以如何捕获异常我们要给线程添加一个异常捕获处理类，让其做到以后遇到异常转成error日志</p>
<p>Thread有两个属性，一个类静态变量，一个实例对象。都可以设置异常捕获。区别在于一个生效的范围是单个thread对象，一个生效的范围是全局的thread。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null unless explicitly set</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// null unless explicitly set</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br></pre></td></tr></table></figure>

<p>我们一般选择给每个thread实例都加一个异常捕获。毕竟别人的thread咱们别管，只管自己创建的thread。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运行时异常了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">uncaughtExceptionHandler</span> <span class="operator">=</span>(t,e)-&gt;&#123;</span><br><span class="line">    log.error(<span class="string">&quot;Exception in thread &quot;</span>,e);</span><br><span class="line">&#125;;</span><br><span class="line">thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240623105230345.png" alt="image-20240623105230345"></p>
<p><img src="/.io//image-20240623105244891.png" alt="image-20240623105244891"><img src="/.io//image-20240623105303055.png" alt="image-20240623105303055"></p>
<p>要实现这个接口</p>
<p><img src="/.io//image-20240623105836210.png" alt="image-20240623105836210"></p>
<blockquote>
<p>这里主线程要等待200ms</p>
<p>当Java程序执行到<code>thread.start();</code>时，它只是启动了新线程，并不意味着新线程立刻就能执行或者其执行结果（包括异常）能立即被感知。主线程和新线程是并发执行的，如果没有适当的同步或等待机制，主线程可能很快就执行完了<code>Thread.sleep(200);</code>之前的代码并结束，导致程序终止，此时新线程可能还没来得及执行到抛出异常的部分。（主线程是程序入口点）</p>
<p>下面看线程池如何配置</p>
<p><img src="/.io//image-20240623110018274.png" alt="image-20240623110018274"></p>
<p>我们要把spring创建线程的过程交给我们来管理</p>
<p><img src="/.io//image-20240623110031689.png" alt="image-20240623110031689"></p>
<p><img src="/.io//image-20240623110224537.png" alt="image-20240623110224537"></p>
<p>&#x3D;&#x3D;alt+7可以打开idea的structrue&#x3D;&#x3D;</p>
<p><img src="/.io//image-20240623110231893.png" alt="image-20240623110231893"></p>
<p><img src="/.io//image-20240623110240840.png" alt="image-20240623110240840"></p>
<p><img src="/.io//image-20240623110301232.png" alt="image-20240623110301232"></p>
<p>所以我们不推荐自己写一个线程工厂来满足自己的需求，所以采用<strong>装饰器模式</strong>，首先我们要替换他的线程工厂</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.tfy.mallchat.common.common.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:tfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>:2024/05/12/20:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="comment">//由于这里设置了一个全参构造函数所以这里必定会传入一个original线程工厂的实例，用于保存原始的线程工厂实例</span></span><br><span class="line"><span class="comment">//比如调用之前传进来的是ThreaPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MyUncaughtExceptionHandler</span> <span class="variable">MY_UNCAUGHT_EXCEPTION_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>();</span><br><span class="line">    <span class="keyword">private</span> ThreadFactory original;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> original.newThread(r);<span class="comment">//执行spring自己的创建逻辑</span></span><br><span class="line">        <span class="comment">//额外装饰我们需要的创建逻辑</span></span><br><span class="line">        thread.setUncaughtExceptionHandler(MY_UNCAUGHT_EXCEPTION_HANDLER); </span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240623112420650.png" alt="image-20240623112420650"></p>
<p><img src="/.io//image-20240623105002765.png" alt="image-20240623105002765"></p>
<p>这样老板再也不怕我的线程执行异常啦</p>
<p><strong>线程池的使用</strong></p>
<p>我们放进容器的线程池设置了beanName。</p>
<p><img src="/.io//1684051087918-bc73f44f-94ce-4e9e-942c-c1dfa1b5e746.png" alt="img"></p>
<p>业务需要用，也可以根据beanName取出想用的线程池。</p>
<p><img src="/.io//1684051162880-bc7c922f-5349-4e77-97cf-5b8f486e50d6.png" alt="img"></p>
<p>或者是直接在方法上加上异步注解<code>@async</code></p>
<p><img src="/.io//1684051219821-8497c577-9658-443f-bcf6-0ca30402df33.png" alt="img"></p>
<h3 id="异步方法调用的线程池"><a href="#异步方法调用的线程池" class="headerlink" title="异步方法调用的线程池"></a>异步方法调用的线程池</h3><ul>
<li><p><strong>默认情况</strong>：当你在某个方法上标注 <code>@Async</code>，且没有指定线程池名称时，Spring 会使用 <code>ThreadPoolConfig</code> 中的 <code>getAsyncExecutor()</code> 方法提供的 <code>mallchatExecutor</code> 线程池。</p>
</li>
<li><p><strong>指定线程池</strong>：如果你希望某个异步方法使用特定的线程池执行，比如 WebSocket 通信相关任务，可以在 <code>@Async</code> 注解中指定线程池的名称，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java复制代码@Async(ThreadPoolConfig.WS_EXECUTOR)</span><br><span class="line">public void someAsyncWebSocketMethod() &#123;</span><br><span class="line">    // WebSocket 通信任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，异步方法将使用 <code>websocketExecutor</code> 来执行，而不是默认的 <code>mallchatExecutor</code>。</p>
</li>
</ul>
<h2 id="4-针对实践业务中敏感词场景，优化前缀树算法，利用AC自动机和kmp思想实现检索速度优化"><a href="#4-针对实践业务中敏感词场景，优化前缀树算法，利用AC自动机和kmp思想实现检索速度优化" class="headerlink" title="4.针对实践业务中敏感词场景，优化前缀树算法，利用AC自动机和kmp思想实现检索速度优化"></a>4.针对实践业务中敏感词场景，优化<strong>前缀树算法</strong>，利用<strong>AC自动机和kmp思想</strong>实现检索速度优化</h2><p><img src="/.io//1687873585249-2592d6b9-2f1b-47c2-832f-ba443a907dca.webp" alt="image.png"></p>
<p>这样一个敏感词替换的功能是怎么实现的呢？</p>
<p>我们的抹茶项目是个千人群聊，里面是不是也会出现一些脏话。对于这些不健康的言论，或者是不健康的网名，都需要在发送消息，以及修改网名的时候，都对文本做一个<strong>敏感词的过滤</strong>，那么怎么去做呢？</p>
<p><strong>传统实现方案</strong></p>
<p><img src="/.io//1687876206758-9ca4b574-77ff-4e50-8f5e-abc49c3645bc.webp" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sensitiveList = Arrays.asList(<span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;abcbba&quot;</span>, <span class="string">&quot;adabca&quot;</span>);</span><br><span class="line">String text=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (String s : sensitiveList) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hit</span> <span class="operator">=</span> text.contains(s);</span><br><span class="line">    System.out.println(hit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>最简单也是最暴力的方法，就是循环遍历所有的敏感词，判断是不是匹配。

这样下来，敏感词数量一大,比如到了几万，那每一次敏感词的判断都要去循环几万次。而且contains的方法是暴力破解法匹配，效率非常的低。具体为啥用暴力破解，[可查看](https://blog.csdn.net/demon7766/article/details/109998089)（==查询有可能是因为如果字符串长度很短并且字符串很随机不重复就有可能出现暴力的效果更好的情况==）String的contains的方法就是略带优化的暴力，时间复杂度O(n2)，空间复杂度O(1)
</code></pre>
<p>那有没有效率更高的优化方法呢？</p>
<p><strong>DFA有穷自动机</strong></p>
<p>找到所有的敏感词，把前缀复用起来，构成Trie树</p>
<blockquote>
<p>Trie树，即<strong>字典树</strong>或<strong>前缀树</strong>，是一种树形结构。广泛应用于<strong>统计和排序大量的字符串</strong>（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。</p>
</blockquote>
<p>&#x3D;&#x3D;Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。但是相比起原有的敏感词列表，复用前缀也省下了不少的内存。&#x3D;&#x3D;</p>
<p><img src="/.io//1687878190994-a6b9faae-1660-4950-9f32-bd924602b90f.webp" alt="image.png"></p>
<pre><code>就像这样，把一个个敏感词扔进去构造前缀树。红色是根节点。相同的前缀就复用，不同的前缀就分支。最后敏感词结束的节点，就是绿色的节点。而我们能够匹配到绿色节点，就代表命中了一个敏感词。

可以试着再把我们的敏感词“abcdefg”扔进去匹配，看看最终会匹配到哪个绿色节点。没错，就是d节点。
</code></pre>
<p><strong>前缀树节点结构</strong></p>
<p>构造前缀树节点数据结构，其中有一个存字符的节点<code>c</code>，以及判断当前是否是结束节点的<code>end</code>，同时还有指向下一级节点的分叉树枝，也就是map结构的<code>next</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Word</span> &#123;</span><br><span class="line">    <span class="comment">// 当前字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一层级的敏感词字典</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Word&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Word</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.end = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造前缀树</strong></p>
<p>构造前缀树，需要获取到敏感词列表的数据源。有两种方案</p>
<p>1.从本地文件用流读取</p>
<p>2.从远端数据库获取敏感词列表</p>
<p>我们采用的是数据库来存储，比较方便改动</p>
<p>加载数据源，在com.abin.mallchat.common.sensitive.MyWordFactory</p>
<p><img src="/.io//1696774042453-b60ad494-54f0-4c53-a7eb-4f960a72ef42.webp" alt="image.png"></p>
<p>具体构造前缀树的方法</p>
<p>com.abin.mallchat.common.common.utils.sensitiveWord.DFAFilter#loadWord(java.lang.String, com.abin.mallchat.common.common.utils.sensitiveWord.DFAFilter.Word)</p>
<p><img src="/.io//1687879137805-93fb8f3d-b53e-4b6f-bf42-4ff75a43649f.webp" alt="image.png"></p>
<p>这样前缀树就构造好啦。</p>
<p><strong>敏感词判断</strong></p>
<p>具体的可以去看判断的逻辑，不断的debug看看具体流程。</p>
<p>com.abin.mallchat.common.common.utils.SensitiveWordUtils#filter</p>
<p><img src="/.io//1687879415806-d428be89-d6ef-4659-9eb4-0a14befb6445.webp" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 敏感词替换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text 待替换文本	WTMDL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 替换后的文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(text);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; result.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> result.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (skip(c)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Word</span> <span class="variable">word</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; result.length(); i++) &#123;</span><br><span class="line">            c = result.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (skip(c)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                c += <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            word = word.next.get(c);</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (word.end) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= i; j++) &#123;</span><br><span class="line">                    result.setCharAt(j, replace);</span><br><span class="line">                &#125;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经典的双指针匹配，匹配失败就开始指针右移，这个其实效率是不高的。</p>
<p>比如我们来假设一个匹配，发现尾部指针e和d匹配不上，这时候开始指针右移一位，尾部指针从开始指针重新开始</p>
<p><img src="/.io//1687879562495-a65b6474-9375-4f10-b767-2dc5707901b0.webp" alt="image.png"></p>
<p>发现匹配不上，继续右移开始指针</p>
<p><img src="/.io//1687879657208-227b4da2-b6e6-49e1-b971-d0563683bab3.webp" alt="image.png"></p>
<p><img src="/.io//1687879708500-34e55b5e-9209-4fc1-a535-c0b5081605b5.webp" alt="image.png"></p>
<p>有没有办法提高匹配的效率呢？<strong>参考kmp算法</strong>，能够减少不必要的判断，比如我们提前就能把a移动到下一个能匹配上的位置</p>
<p><strong>判断优化KMP</strong></p>
<p>找规律，子串的ab有相同的前缀，当你匹配到d的位置，发现匹配不上的时候，你可以快速的重新匹配，把子串移动到前面，从c开始匹配，因为我们在构造的时候，就发现子串的重复前缀，可以减少判断的时间。</p>
<p><img src="/.io//1687880124935-e430cfcb-7f2a-4ce9-9f8a-989deb69d101.webp" alt="image.png"></p>
<p>给子串构造跳转节点</p>
<p><img src="/.io//1687880425267-62216f78-d077-47a7-a1e9-48708143c0c5.webp" alt="image.png"></p>
<p>再重新模拟一次匹配会是什么样</p>
<p><img src="/.io//1687880415037-87a84cf9-ef34-48c9-a586-757b3bff859d.webp" alt="image.png"></p>
<p>发现子串匹配失败，回退到b发现子串可以快速回退到2的位置重新匹配</p>
<p><img src="/.io//1687880510124-ae75e40e-8280-49b4-bfcc-e9d2604f27d1.webp" alt="image.png"></p>
<p>就是这种感觉。这样，我们就稍微摸到了ac自动机的领域了</p>
<p><strong>AC自动机</strong></p>
<p>trie树做匹配的时候，需要从根节点向下搜索，一直往下匹配，当匹配不下去的时候，继续从根节点进行再一次匹配。</p>
<p>&#x3D;&#x3D;很明显可以看出trie树匹配的缺点是匹配的时候每次都从根节点开始，这个时间复杂度高了，需要优化。&#x3D;&#x3D;</p>
<p>优化的方法很容易想出来，就是优化每次从根节点进行匹配，当匹配不下去的时候，返回上一节点，继续尝试其他路径</p>
<blockquote>
<p>AC自动机其实就是trie+kmp算法。</p>
</blockquote>
<p>&#x3D;&#x3D;上面我们也介绍的比较清楚了，把跳转节点，当作失败跳转指针。类似于在trie树上加fail表。&#x3D;&#x3D;</p>
<p>现在我们对之前的trie树做一个改造</p>
<p><img src="/.io//1687880912214-0455ecb2-ecab-4944-a613-e14caab9cebd.webp" alt="image.png"></p>
<p>加上fail指针</p>
<p><img src="/.io//1687880995814-1c6835f3-896e-4102-b358-f6d43ad77812.webp" alt="image.png"></p>
<p>现在我们再来判断一段文本<code>“adabcd”</code></p>
<p>首先会一往无前的向右匹配，直到匹配到c</p>
<p><img src="/.io//1687881298833-7925c881-1ec7-4752-9f0f-a25bf7dd9f93.webp" alt="image.png"></p>
<p>发现匹配失败，跳转到下一个快速匹配的节点</p>
<p><img src="/.io//1687881342402-4d8b92d7-4195-42e3-8081-0010b4359359.webp" alt="image.png"></p>
<p>继续向前匹配，匹配到d</p>
<p><img src="/.io//1687881367503-6820bd50-6a8b-49be-b691-8740aa400571.webp" alt="image.png"></p>
<p><strong>节点结构</strong></p>
<p><img src="/.io//1687881736669-b2ce3ac6-c7c7-47f1-bd8a-db27a76a7d49.webp" alt="image.png"></p>
<p>和dfa的差别，就是多了个<code>depth</code>。这个和上面的例子不同，上面的例子在跳转到失败指针的时候，<code>前指针</code>会前进。实际上不会的。</p>
<p><img src="/.io//1687881342402-4d8b92d7-4195-42e3-8081-0010b4359359-171945758396839.webp" alt="img"></p>
<p>也就是这样</p>
<p><img src="/.io//1687881848658-7a376f78-cb94-47aa-a030-db044aa1ad18.webp" alt="image.png"></p>
<pre><code>那最后匹配到了d，结果不是以为原串的adabcd全命中了嘛。所以他加了个`depth`的字段记录节点的深度。

我们只需要知道`后指针`的值，减去`depth`就能推算出前指针，因此我们维护一个指针就好了。
</code></pre>
<p><strong>构建前缀数</strong></p>
<p>构建<code>Trie树</code>的差别在于构建完还会加一个失败指针。</p>
<p>com.abin.mallchat.common.common.algorithm.ac.ACTrie#ACTrie</p>
<p><img src="/.io//1687881437596-d0beec76-0a54-44c5-bf59-0c86af4af2bd.webp" alt="image.png"></p>
<p><strong>敏感词判断</strong></p>
<p>com.abin.mallchat.common.common.algorithm.ac.ACTrie#matches</p>
<p><img src="/.io//1687882085902-f413b933-ce8b-40d9-88d5-468bf62b3db3.webp" alt="image.png"></p>
<p><strong>整体实现方案</strong></p>
<p>针对不同的敏感词实现策略，我们抽象了固定的接口。</p>
<p><img src="/.io//1696776459691-710e3aca-3b94-4a56-8ebb-dd4744c4da05.webp" alt="image.png"></p>
<p>三个核心功能，分别是<strong>过滤敏感词</strong>，判断<strong>是否命中敏感词</strong>，以及<strong>构建敏感词树</strong>。</p>
<p>创建一个引导类SensitiveWordBs，装载敏感词<strong>数据源</strong>，和设置敏感词具体<strong>过滤策略</strong>。交由spring管理</p>
<p><img src="/.io//1696776799275-742b29d6-2f90-4ad4-97ed-b8fe632f0a4f.webp" alt="image.png"></p>
<p>在需要使用的地方，直接调用过滤方法。</p>
<p><img src="/.io//1696776886567-27b1b81e-afb7-480e-8cbf-a689e8469273.webp" alt="image.png"></p>
<p><strong>总结</strong></p>
<p>相比起来，ac自动机由于要构建失败节点，所以初始化速度会更慢，以及内存占用会更大</p>
<p>但是ac自动机的匹配速度会更快很多。特别是在多模匹配的情况下，效果更佳明显。</p>
<p>什么是<strong>多模匹配</strong>？</p>
<blockquote>
<p>比如敏感词abc和bcd。</p>
<p>匹配字符串abcde。</p>
<p>单模匹配后：***de</p>
<p>多模匹配后：****e</p>
</blockquote>
<p>学完后，你也可以做一个敏感词的工具包。甚至可以做的有扩展性，融合两种实现方案。进行一个效率匹配。可以当做的你项目亮点，但是你必须</p>
<ol>
<li>会一定的算法，能手写kmp，dfa，ac自动机，这样面试游刃有余</li>
<li>了解相关算法的时间和空间复杂度，能够解释</li>
</ol>
<p><strong>代码实现</strong></p>
<p><img src="/.io//image-20240627145215151.png" alt="image-20240627145215151"></p>
<blockquote>
<p>以下是SensitiveWordFilter接口的具体实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 敏感词过滤</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyuhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/07/08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有敏感词</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSensitiveWord</span><span class="params">(String text)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">filter</span><span class="params">(String text)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载敏感词列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> words 敏感词数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadWord</span><span class="params">(List&lt;String&gt; words)</span>;</span><br><span class="line">	<span class="comment">//最重要的是加载敏感词的列表，无论是AC还是DFA都需要我们去实现一个树那样的数据结构，所以要把一个词的列表集合加载进去</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以下是AC_Tree的加载方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于ac自动机实现的敏感词过滤工具类</span></span><br><span class="line"><span class="comment"> * 可以用来替代&#123;<span class="doctag">@link</span> ConcurrentHistogram&#125;</span></span><br><span class="line"><span class="comment"> * 为了兼容提供了相同的api接口 &#123;<span class="doctag">@code</span> hasSensitiveWord&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Created by berg on 2023/6/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ACFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">char</span> <span class="variable">mask_char</span> <span class="operator">=</span> <span class="string">&#x27;*&#x27;</span>; <span class="comment">// 替代字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ACTrie</span> <span class="variable">ac_trie</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有敏感词</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasSensitiveWord</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(text)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> !Objects.equals(filter(text), text);</span><br><span class="line">        <span class="comment">//经过过滤的敏感词和原始文本不一样就是true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 敏感词替换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 待替换文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 替换后的文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(text)) <span class="keyword">return</span> text;</span><br><span class="line">        List&lt;MatchResult&gt; matchResults = ac_trie.matches(text);</span><br><span class="line">        <span class="comment">//这里得到的是一组起始和结束位置</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(text);</span><br><span class="line">        <span class="comment">// matchResults是按照startIndex排序的，因此可以通过不断更新endIndex最大值的方式算出尚未被替代部分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (MatchResult matchResult : matchResults) &#123;</span><br><span class="line">            endIndex = Math.max(endIndex, matchResult.getEndIndex());</span><br><span class="line">            replaceBetween(result, matchResult.getStartIndex(), endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">replaceBetween</span><span class="params">(StringBuffer buffer, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line">            buffer.setCharAt(i, mask_char);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载敏感词列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> words 敏感词数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadWord</span><span class="params">(List&lt;String&gt; words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        ac_trie = <span class="keyword">new</span> <span class="title class_">ACTrie</span>(words);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ACTrie</span> <span class="variable">ac_trie</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载敏感词列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> words 敏感词数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadWord</span><span class="params">(List&lt;String&gt; words)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (words == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    ac_trie = <span class="keyword">new</span> <span class="title class_">ACTrie</span>(words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240627150326607.png" alt="image-20240627150326607"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * aho-corasick算法（又称AC自动机算法）</span></span><br><span class="line"><span class="comment"> * Created by berg on 2023/6/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ACTrie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> ACTrieNode root;</span><br><span class="line"><span class="comment">//---------------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ACTrie</span><span class="params">(List&lt;String&gt; words)</span> &#123;</span><br><span class="line">        words = words.stream().distinct().collect(Collectors.toList()); <span class="comment">// 去重</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">ACTrieNode</span>();</span><br><span class="line">        <span class="comment">//声明ACTreeNode节点，属性包括字节点map包括字符和ACTrieNode之间的映射关系，失败节点、深度、是否是叶子节点</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            addWord(word);</span><br><span class="line">        &#125;</span><br><span class="line">        initFailover();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">ACTrieNode</span> <span class="variable">walkNode</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="comment">//把每一个单词转换成为字符数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            walkNode.addChildrenIfAbsent(chars[i]);</span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    private Map&lt;Character, ACTrieNode&gt; children = Maps.newHashMap();</span></span><br><span class="line"><span class="comment">	public void addChildrenIfAbsent(char c) &#123;</span></span><br><span class="line"><span class="comment">        children.computeIfAbsent(c, (key) -&gt; new ACTrieNode());</span></span><br><span class="line"><span class="comment">        代表的是当c不在map中的映射关系时就把他作为键插入进去，然后声明一个新的ACTrieNode作为值</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------*/</span></span><br><span class="line">            walkNode = walkNode.childOf(chars[i]);</span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    public ACTrieNode childOf(char c) &#123;</span></span><br><span class="line"><span class="comment">        return children.get(c);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    从map中拿去对应的ACTrieNode</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------*/</span></span><br><span class="line">            walkNode.setDepth(i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//设定节点的深度</span></span><br><span class="line">        &#125;</span><br><span class="line">        walkNode.setLeaf(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化节点中的回退指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFailover</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//!!!!!第一层的fail指针指向root</span></span><br><span class="line">        Queue&lt;ACTrieNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, ACTrieNode&gt; children = root.getChildren();</span><br><span class="line">        <span class="comment">//获得root所有孩子的信息，这是第一层节点的信息</span></span><br><span class="line">        <span class="keyword">for</span> (ACTrieNode node : children.values()) &#123;</span><br><span class="line">            node.setFailover(root);</span><br><span class="line">            <span class="comment">//所有孩子的返回节点都设置为root</span></span><br><span class="line">            queue.offer(node);</span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获得root所有的子节点，然后将所有节点的失败节点都设置为root，然后进行入队</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//构建剩余层数节点的fail指针,利用层次遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">ACTrieNode</span> <span class="variable">parentNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">//从队列中弹出一个节点</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, ACTrieNode&gt; entry : parentNode.getChildren().entrySet()) &#123;</span><br><span class="line">                <span class="comment">//获得这个节点的所有的子节点</span></span><br><span class="line">                <span class="type">ACTrieNode</span> <span class="variable">childNode</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                <span class="comment">//拿取所有孩子节点的节点值</span></span><br><span class="line">                <span class="type">ACTrieNode</span> <span class="variable">failover</span> <span class="operator">=</span> parentNode.getFailover();</span><br><span class="line">                <span class="comment">//拿到父节点的回溯点</span></span><br><span class="line">                <span class="comment">// 在树中找到以childNode为结尾的字符串的最长前缀匹配，failover指向了这个最长前缀匹配的父节点</span></span><br><span class="line">                <span class="keyword">while</span> (failover != <span class="literal">null</span> &amp;&amp; (!failover.hasChild(entry.getKey()))) &#123;</span><br><span class="line">                    failover = failover.getFailover();</span><br><span class="line">                   <span class="comment">//当回溯节点不为空时且父节点没有和他相同的子节点就继续往回找了</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//回溯到了root节点</span></span><br><span class="line">                <span class="keyword">if</span> (failover == <span class="literal">null</span>) &#123;</span><br><span class="line">                    childNode.setFailover(root);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 更新当前节点的回退指针</span></span><br><span class="line">                    childNode.setFailover(failover.childOf(entry.getKey()));</span><br><span class="line">                                    <span class="comment">// 在树中找到以childNode为结尾的字符串的最长前缀匹配，failover指向了这个最长前缀匹配的父节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(childNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询句子中包含的敏感词的起始位置和结束位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MatchResult&gt; <span class="title function_">matches</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        List&lt;MatchResult&gt; result = Lists.newArrayList();</span><br><span class="line">        <span class="type">ACTrieNode</span> <span class="variable">walkNode</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> text.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!walkNode.hasChild(c) &amp;&amp; walkNode.getFailover() != <span class="literal">null</span>) &#123;</span><br><span class="line">                walkNode = walkNode.getFailover();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果因为当前节点的孩子节点有这个字符，则将walkNode替换为下面的孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (walkNode.hasChild(c)) &#123;</span><br><span class="line">                walkNode = walkNode.childOf(c);</span><br><span class="line">                <span class="comment">// 检索到了敏感词</span></span><br><span class="line">                <span class="keyword">if</span> (walkNode.isLeaf()) &#123;</span><br><span class="line">                    result.add(<span class="keyword">new</span> <span class="title class_">MatchResult</span>(i - walkNode.getDepth() + <span class="number">1</span>, i + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 模式串回退到最长可匹配前缀位置并开启新一轮的匹配</span></span><br><span class="line">                    <span class="comment">// 这种回退方式将一个不漏的匹配到所有的敏感词，匹配结果的区间可能会有重叠的部分</span></span><br><span class="line">                    walkNode = walkNode.getFailover();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>添加词的形式如下：</strong></p>
<p><img src="/.io//image-20240627153254785.png" alt="image-20240627153254785"></p>
</blockquote>
<p><strong>重新整理—DFA算法原理实现</strong></p>
<p>针对不同的敏感词实现策略，我们抽象了固定的接口。</p>
<p><img src="/.io//image-20240627153345723.png" alt="image-20240627153345723"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 敏感词过滤</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyuhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/07/08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有敏感词</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSensitiveWord</span><span class="params">(String text)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">filter</span><span class="params">(String text)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载敏感词列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> words 敏感词数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadWord</span><span class="params">(List&lt;String&gt; words)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接口定义 了加载敏感词的列表、以及最最重要的过滤方法，以及一个判断是不是有这个敏感词</p>
<p>其中具体是怎么加载的，有选择了什么样的策略呢实现了一个SensitiveWordBs（SensitiveWordBootstrap）的引导类，引导类来帮我们进行对应的配置，引导类需要去装载一些东西比如：需要用什么策略</p>
<p><img src="/.io//image-20240627153536756.png" alt="image-20240627153536756"></p>
<p>默认是DFA的</p>
<p>还有敏感词的列表</p>
<p><img src="/.io//image-20240627153631543.png" alt="image-20240627153631543"></p>
<p><img src="/.io//image-20240627153644975.png" alt="image-20240627153644975"></p>
<p>这个是一个工厂，让调用方自己来实现这个工厂，去写一个数据源加载的方法</p>
<p><img src="/.io//image-20240627153708637.png" alt="image-20240627153708637"></p>
<p>从mysql中进行的加载</p>
<p>这个引导类需要客户自己去装载</p>
<p><img src="/.io//image-20240627153753101.png" alt="image-20240627153753101"></p>
<p>我们实现了一个敏感词的自动装配类，在这里将Bean创建出来交给spring管理</p>
<p><img src="/.io//image-20240627154047390.png" alt="image-20240627154047390"></p>
<p>在这里指定了数据源的工厂和策略类，业务中我们要使用SensitiveWordBs直接使用他就好了</p>
<p><img src="/.io//image-20240627154108906.png" alt="image-20240627154108906"></p>
<p>我们直接把他进行一个注入</p>
<p><img src="/.io//image-20240627154144844.png" alt="image-20240627154144844"></p>
<p>直接调用他filter</p>
<p><img src="/.io//image-20240627154234090.png" alt="image-20240627154234090"></p>
<p>以上是他的效果</p>
<p>还有一个方法hasSensitiveWord（是否有敏感词）</p>
<p><img src="/.io//image-20240627154258036.png" alt="image-20240627154258036"></p>
<p>修改名字时就会进行判断让他重新进行输入</p>
<p>总结这里就是：想用这个敏感词就要使用这个引导类进行一个Bean的一个创建，把他交给spring的管理，指定他的策略和数据源 ，最后注入一下就可以使用了</p>
</blockquote>
<p><strong>接下来进行一个test来了解他的过程：</strong></p>
<p><img src="/.io//image-20240627154341192.png" alt="image-20240627154341192"></p>
<p><img src="/.io//image-20240627154354659.png" alt="image-20240627154354659"></p>
<p><img src="/.io//image-20240627154401989.png" alt="image-20240627154401989"></p>
<p><img src="/.io//image-20240627154420411.png" alt="image-20240627154420411"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载敏感词列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> words 敏感词数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadWord</span><span class="params">(List&lt;String&gt; words)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(words)) &#123;</span><br><span class="line">        <span class="type">Word</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Word</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="comment">//首先构造一个空节点</span></span><br><span class="line">        words.forEach(word -&gt; loadWord(word, newRoot));</span><br><span class="line">        <span class="comment">//将这些进行一个遍历，把这些加载到树上，这里面都放入一个根节点</span></span><br><span class="line">        root = newRoot;</span><br><span class="line">        <span class="comment">//最终再赋予到空节点上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240627154517755.png" alt="image-20240627154517755"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载敏感词</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> word 词</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadWord</span><span class="params">(String word, Word root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(word)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Word</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">        <span class="comment">// 如果是大写字母, 转换为小写</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            c += <span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (skip(c)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Word</span> <span class="variable">next</span> <span class="operator">=</span> current.next.get(c);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">Word</span>(c);</span><br><span class="line">            current.next.put(c, next);</span><br><span class="line">        &#125;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    current.end = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240627154627310.png" alt="image-20240627154627310"></p>
<p><img src="/.io//image-20240627154638240.png" alt="image-20240627154638240"></p>
<p><img src="/.io//image-20240627154653713.png" alt="image-20240627154653713"></p>
<p><img src="/.io//image-20240627154702326.png" alt="image-20240627154702326"></p>
<p><img src="/.io//image-20240627154713682.png" alt="image-20240627154713682"></p>
<blockquote>
<p>看他需不需要进行跳过</p>
</blockquote>
<p><img src="/.io//image-20240627154725219.png" alt="image-20240627154725219"></p>
<blockquote>
<p>对于这些字符串都会进行一个跳过</p>
</blockquote>
<p><img src="/.io//image-20240627154827080.png" alt="image-20240627154827080"></p>
<p><img src="/.io//image-20240627154839938.png" alt="image-20240627154839938"></p>
<p><img src="/.io//image-20240627154854703.png" alt="image-20240627154854703"></p>
<p>再往下我们的current就是a了</p>
<p><img src="/.io//image-20240627154917589.png" alt="image-20240627154917589"></p>
<p>执行完成后我们就会发现已经组装成功了</p>
<p><img src="/.io//image-20240627154935704.png" alt="image-20240627154935704"></p>
<p><img src="/.io//image-20240627154944538.png" alt="image-20240627154944538"></p>
<p>之后的关键词再存入就会产生分支</p>
<p><img src="/.io//image-20240627154955735.png" alt="image-20240627154955735"></p>
<p>接下来我们去看他是否有敏感词</p>
<p><img src="/.io//image-20240627155020521.png" alt="image-20240627155020521"></p>
<p>判断有没有敏感词直接复用了这个方法，最后判断过略之后的敏感词和原来的词有没有不同做判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 敏感词替换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text 待替换文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 替换后的文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(text);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; result.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> result.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (skip(c)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Word</span> <span class="variable">word</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; result.length(); i++) &#123;</span><br><span class="line">            c = result.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (skip(c)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                c += <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            word = word.next.get(c);</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (word.end) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= i; j++) &#123;</span><br><span class="line">                    result.setCharAt(j, replace);</span><br><span class="line">                &#125;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240627155101557.png" alt="image-20240627155101557"></p>
<p>这个result就是我们最后能够替换上的一个结果</p>
<p><img src="/.io//image-20240627155110718.png" alt="image-20240627155110718"></p>
<blockquote>
<p>先去检查是不是一个特殊字符，是的话进行一个跳过</p>
</blockquote>
<p>首先拿到root，然后开始遍历</p>
<p><img src="/.io//image-20240627155128816.png" alt="image-20240627155128816"></p>
<p><strong><img src="/.io//image-20240627155141476.png" alt="image-20240627155141476"></strong></p>
<p>有没有找到一个标识</p>
<p><img src="/.io//image-20240627155204975.png" alt="image-20240627155204975"></p>
<p><img src="/.io//image-20240627155321466.png" alt="image-20240627155321466"></p>
<p><img src="/.io//image-20240627155341577.png" alt="image-20240627155341577"></p>
<p><img src="/.io//image-20240627155353650.png" alt="image-20240627155353650">	<img src="/.io//image-20240627155410047.png" alt="image-20240627155410047"></p>
<p>然后进行一个*替换</p>
<p><img src="/.io//image-20240627155437337.png" alt="image-20240627155437337"></p>
<p><strong>AC自动机算法原理实现</strong></p>
<p><img src="/.io//image-20240627155521354.png" alt="image-20240627155521354"></p>
<blockquote>
<p>把这个words全部扔进去，扔到构建函数里面去就构建好了这样一棵树</p>
</blockquote>
<p><img src="/.io//image-20240627155540643.png" alt="image-20240627155540643"></p>
<blockquote>
<p>AC节点包括子节点的map，回退节点、深度、是否是叶子节点</p>
</blockquote>
<p><img src="/.io//image-20240627155556440.png" alt="image-20240627155556440"></p>
<blockquote>
<p>这里面进行了一个树的初始化</p>
</blockquote>
<p><img src="/.io//image-20240627155610597.png" alt="image-20240627155610597"></p>
<p>首先对单词进行一个去重，然后创建一个空的根节点，然后赋予给我们的根节点，然后去添加我们每一个单词</p>
<p><img src="/.io//image-20240627155625394.png" alt="image-20240627155625394"></p>
<blockquote>
<p>如果不存在这个子节点就添加</p>
<p>childOf这时子节点一定加入进去了</p>
<p><img src="/.io//image-20240627155640773.png" alt="image-20240627155640773"></p>
<p>所以取得他的孩子然后走到下一个，然后设置深度</p>
<p><img src="/.io//image-20240627155653929.png" alt="image-20240627155653929"></p>
<p>这时我们的根节点就有一个子节点了</p>
<p><img src="/.io//image-20240627155709204.png" alt="image-20240627155709204"></p>
<p>d构建循环结束之后就设置叶子的标志</p>
</blockquote>
<p><img src="/.io//image-20240627155742634.png" alt="image-20240627155742634"></p>
<p><img src="/.io//image-20240627155752541.png" alt="image-20240627155752541"></p>
<p><img src="/.io//image-20240627155801948.png" alt="image-20240627155801948"></p>
<p>现在查看失败节点是如何构建的</p>
<p><img src="/.io//image-20240627155840523.png" alt="image-20240627155840523"></p>
<blockquote>
<p>首先去获取子节点、然后对子节点进行一个遍历</p>
<p>对于第一层来说，失败的话都是回到原点</p>
<p>然后把第一层的节点都放入到queue里面、</p>
<p>进行一个层序遍历，之所以使用层序遍历我觉得是因为对于同一个父节点的子节点来说他们的回退节点其实是一样的</p>
</blockquote>
<p><img src="/.io//image-20240627155944052.png" alt="image-20240627155944052"></p>
<p><img src="/.io//image-20240627155955695.png" alt="image-20240627155955695"></p>
<p><img src="/.io//image-20240627160005827.png" alt="image-20240627160005827"></p>
<blockquote>
<p>那这个逻辑是在做什么，就是在开始指他的失败指针了</p>
<ul>
<li><p>对于<code>parentNode</code>的所有子节点，遍历它们，并试图为每个子节点<code>childNode</code>找到合适的失败指针。这里的合适意味着如果从<code>childNode</code>开始的字符串不能直接匹配，那么失败指针应当指向能够匹配该字符串最长前缀的节点的下一个节点。</p>
</li>
<li><p>初始化逻辑中，首先将<code>parentNode</code>的失败指针暂存为<code>failover</code>，然后检查<code>failover</code>节点是否有<code>ParentNode</code>代表的字符作为子节点。如果没有，就沿着<code>failover</code>的失败指针继续向上回溯，直到找到一个节点具有该字符作为子节点或者回溯到根节点为止。</p>
</li>
</ul>
</blockquote>
<p><img src="/.io//image-20240627160316023.png" alt="image-20240627160316023"></p>
<p>这里其实每一个节点都有失败指针，但是没有画的就是根节点</p>
<p><img src="/.io//image-20240627160352688.png" alt="image-20240627160352688"></p>
<blockquote>
<p>而以b为例就是首先它会遵循父节点的失败指针，所以a是根节点、他最开始也是根节点</p>
</blockquote>
<p><img src="/.io//image-20240627160638535.png" alt="image-20240627160638535"></p>
<p>这段是在判断根节点有没有一个子节点也是b的，如果根节点有一个子节点也是b的，就不用推到根节点了，如果没有继续往上推</p>
<p><img src="/.io//image-20240627160702405.png" alt="image-20240627160702405"></p>
<p>如果推到了根节点那么就是设置回退点为root即可</p>
<p><img src="/.io//image-20240627160719698.png" alt="image-20240627160719698"></p>
<p><img src="/.io//image-20240627160729938.png" alt="image-20240627160729938"></p>
<blockquote>
<p>到这个a了观察他的失败指针是如何构建的</p>
</blockquote>
<p><img src="/.io//image-20240627160750224.png" alt="image-20240627160750224"></p>
<p>首先遵从父类的失败指针是root</p>
<p><img src="/.io//image-20240627160902023.png" alt="image-20240627160902023"></p>
<blockquote>
<p>走到这个分支证明可以往前走</p>
</blockquote>
<p><img src="/.io//image-20240627160913751.png" alt="image-20240627160913751"></p>
<p>找到了这个a作为我们的回退指针</p>
<p><img src="/.io//image-20240627160924711.png" alt="image-20240627160924711"></p>
<p><img src="/.io//image-20240627160953992.png" alt="image-20240627160953992"></p>
<p>接下来查看是否含有</p>
<p><img src="/.io//image-20240627161011354.png" alt="image-20240627161011354"></p>
<p><img src="/.io//image-20240627161023240.png" alt="image-20240627161023240"></p>
<p><img src="/.io//image-20240627161032867.png" alt="image-20240627161032867"></p>
<p><img src="/.io//image-20240627161059368.png" alt="image-20240627161059368"></p>
<p><img src="/.io//image-20240627161110896.png" alt="image-20240627161110896"></p>
<p><img src="/.io//image-20240627161123339.png" alt="image-20240627161123339"></p>
<p><img src="/.io//image-20240627161133756.png" alt="image-20240627161133756"></p>
<p><img src="/.io//image-20240627161141989.png" alt="image-20240627161141989"></p>
<p>然后再继续回退，因为可能会出现abcd是敏感词，bcd也是敏感词</p>
<p><img src="/.io//image-20240627161156482.png" alt="image-20240627161156482"></p>
<p><img src="/.io//image-20240627161223817.png" alt="image-20240627161223817"></p>
<h2 id="5-消息中的url解析小卡片，不同的类型链接有不同解析方式，采用策略模式，封装多种解析方法。采用责任链模式，串联解析流程。采用模板方法模式，搭建解析基础骨架。采用CompletableFuture并行解析多个url。并借助Jsoup的请求超时，进行熔断"><a href="#5-消息中的url解析小卡片，不同的类型链接有不同解析方式，采用策略模式，封装多种解析方法。采用责任链模式，串联解析流程。采用模板方法模式，搭建解析基础骨架。采用CompletableFuture并行解析多个url。并借助Jsoup的请求超时，进行熔断" class="headerlink" title="5.消息中的url解析小卡片，不同的类型链接有不同解析方式，采用策略模式，封装多种解析方法。采用责任链模式，串联解析流程。采用模板方法模式，搭建解析基础骨架。采用CompletableFuture并行解析多个url。并借助Jsoup的请求超时，进行熔断"></a>5.消息中的url解析小卡片，不同的类型链接有不同解析方式，采用<strong>策略模式，</strong>封装多种解析方法。采用责任链模式，<strong>串联解析流程。采用</strong>模板方法模式<strong>，搭建解析基础骨架。采用CompletableFuture</strong>并行解析多个url。并借助Jsoup的请求超时，进行<strong>熔断</strong></h2><p><img src="/.io//1696329943218-3c381bbc-cd26-4b7d-8fb8-54f6620bd322.webp" alt="image.png"></p>
<p>url能够识别高亮，并且还解析出对应网页的标题。这样点击就能跳转，不点击也能知道这个网站是干嘛用的，是不是方便很多。这样一个功能是怎么做出来的，又有哪些细节呢？本文会详细的从调研到方案选型，再到技术实现，一一道来。</p>
<p><strong>背景</strong></p>
<p>为啥要做这个url跳转的功能呢？首先是因为我们的项目有点赞的功能。大家为了能够获赞，就会发一些很好的博客链接。</p>
<p>如果这个链接能够被识别出来，点击就能跳转，是不是对大家都会很方便？甚至做的再好些，直接把url对应的标题解析出来，不用点击就知道这个链接是啥内容，我感不感兴趣。（&#x3D;&#x3D;模仿微信分享的功能&#x3D;&#x3D;）</p>
<p><strong>调研</strong></p>
<p>url的识别其实很简单，一般就是正则匹配。url的标题解析也很简单，就是提前访问一下，然后获取对应网站的title标签内容。</p>
<p>&#x3D;&#x3D;那难点在哪里呢？&#x3D;&#x3D;</p>
<blockquote>
<p>难点在于，你什么时候去解析或者匹配url。是后端做还是前端做，是入库时做，还是列表查询做？</p>
<p>和前端的消息体是怎么样的？</p>
</blockquote>
<p>于是我们先调研了一下市面上已经成熟的产品，相信大家并不陌生，就是我们的知识星球。</p>
<p><img src="/.io//1696330533790-29afbed8-989b-441e-aacf-646671f91794.webp" alt="image.png"></p>
<p>熟悉星球的小伙伴应该都知道，星球会解析url的标题。我们通过抓包就可以了解他们实现的思路。</p>
<p>打开F12，抓到了这么多包，不知道哪个是我们想要的内容。</p>
<p><img src="/.io//1686065611648-65b3dfe9-a76c-482c-8369-d6a0c79247df.webp" alt="image.png"></p>
<p>这时候交大家一个小技巧，通过内容搜索请求，ctrl+f出现搜索框搜索jianshu</p>
<p><img src="/.io//1696330601106-20ea9e19-7914-48ad-bf1f-ca53404647d4.webp" alt="image.png"></p>
<p>点击info下的消息体，复制出来发现被unicode编码了，进行解码一下。</p>
<p><img src="/.io//1696330652541-44d5a206-2526-428b-b046-caddc42b79e7.webp" alt="image.png"></p>
<p>后端是直接在原文用一种特殊格式传给前端，里面指定了title文本内容和跳转链接。</p>
<p>我们要不要学它这么去做呢？</p>
<p>至少确定了，这件事是后端来做。</p>
<p><strong>方案选型</strong></p>
<p>首先我们思考下url什么时候去解析。url的正则匹配不怎么耗时，主要是请求外部网站解析标题的时候比较耗时。</p>
<p><img src="/.io//1686066979801-781a8726-299b-4121-ae50-d16c39135ad6.webp" alt="image.png"></p>
<p>你可以选择：</p>
<ol>
<li>发送消息，入库前去解析</li>
<li>用户访问消息列表的时候，查出来在后端解析</li>
<li>直接原文扔给用户，前端自己去解析。</li>
</ol>
<p>首先排除2，总共才一份消息。不同的人请求，都要去重复解析，拉高的整体的接口响应，占用了后端的资源。</p>
<p>3和2的区别在于，3是用户端自己解析，不会占用服务的资源。这样消息阅读者的加载会慢一些。但是它有个致命的缺点，如果你在千人在线的群发一条链接。这一千个前端都会去请求那个网站，解析url，对别人的网站负担比较大。我们还是不要给别人的网站造成这样的困扰比较好。（&#x3D;&#x3D;千人用户去请求网站，负担会比较大，尽量不要给其他网站造成这样的困扰&#x3D;&#x3D;）</p>
<p>思来想去，就剩最后一个选择了。那就是让消息的发送者稍微委屈下（谁让你要发链接呢！）。</p>
<p>那有没有可能异步呢？也不要去阻塞发送者。先入库，再异步解析，再推送给其他用户。</p>
<p>答案是否定的，消息发送者其实也需要实时看见自己的链接被解析了。这个时间与其都要等，不如就直接等着吧。</p>
<p>于是最终我们决定让消息发送者承担下所有，但是别太悲观，该有的优化，我们也会尽力去优化的。</p>
<p><strong>技术实现</strong></p>
<p>在技术实现之前，我们需要先进行一个最小粒度的验证。就是先验证我们能够识别url和标题解析，再去进行代码更优雅的编写。</p>
<p><strong>尝试识别url</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;这是一个很长的字符串再来 www.github.com，其中包含一个URL www.baidu.com,, 一个带有端口号的URL http://www.jd.com:80, 一个带有路径的URL http://mallchat.cn, 还有美团技术文章https://mp.weixin.qq.com/s/hwTf4bDck9_tlFpgVDeIKg&quot;</span>;</span><br><span class="line">    <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;((http|https)://)?(www.)?([\\w_-]+(?:(?:\\.[\\w_-]+)+))([\\w.,@?^=%&amp;:/~+#-]*[\\w@?^=%&amp;/~+#-])?&quot;</span>);</span><br><span class="line">    List&lt;String&gt; matchList = ReUtil.findAll(pattern, content, <span class="number">0</span>);<span class="comment">//hutool工具类</span></span><br><span class="line">    System.out.println(matchList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[www.github.com, www.baidu.com, http:<span class="comment">//www.jd.com:80, http://mallchat.cn, https://mp.weixin.qq.com/s/hwTf4bDck9_tlFpgVDeIKg]</span></span><br></pre></td></tr></table></figure>

<p>大部分的case都匹配上了，没有问题。其实想要找一个完美的链接匹配正则是有难度的。这个正则还是一个粉丝用gpt4生成的。</p>
<p><strong>尝试获取标题</strong></p>
<p>引入jsoup依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.15</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>获取标题，我们可用java常用的爬虫工具Jsoup来进行内容的解析。一般浏览器展示的标签页的文本，就是html里面的<code>&lt;title&gt;&lt;/title&gt;</code>标签</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> connect.get();</span><br><span class="line">    <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> document.title();</span><br><span class="line">    System.out.println(title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">百度一下，你就知道</span><br></pre></td></tr></table></figure>

<p>为了让你能更加清楚的了解<code>jsoup</code>爬取到的<code>document</code>是啥样，我们debug看看</p>
<p><img src="/.io//1686152600719-a3bc7900-8b71-437d-bcb2-988d11f5f48f.webp" alt="image.png"></p>
<p>其实就是一个html页面。我们通过<code>document.title()</code>去匹配标题的标签内容。</p>
<p>所有网页的标题都是这个title标签吗？也不全是。比如微信文章的网页。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O4Ts0UnnDlYB5OQyCxO0Og%EF%BC%8C%E4%BD%A0%E5%8E%BB%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AAtitle%E6%98%AF%E6%8B%BF%E4%B8%8D%E5%88%B0%E4%BB%BB%E4%BD%95%E4%B8%9C%E8%A5%BF%E7%9A%84">https://mp.weixin.qq.com/s/O4Ts0UnnDlYB5OQyCxO0Og，你去访问这个title是拿不到任何东西的</a></p>
<p><img src="/.io//1686152911797-43a16110-bb76-471d-a637-e4652398be76.webp" alt="image.png"></p>
<p>因为它压根就没有title标签。通过深入分析它的html文档，你会发现，它的标题是在<meta>标签里，也有一定的规律。</p>
<p><img src="/.io//1686153054364-8008c25f-03da-4005-950c-6c1a54405dff.webp" alt="image.png"></p>
<p>找到了规律，就能匹配出我们的标题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;https://mp.weixin.qq.com/s/O4Ts0UnnDlYB5OQyCxO0Og&quot;</span>);</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> connect.get();</span><br><span class="line">    <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> document.getElementsByAttributeValue(<span class="string">&quot;property&quot;</span>, <span class="string">&quot;og:title&quot;</span>).attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">    System.out.println(title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能解析出我们的标题了。</p>
<p>你发现没，不同的页面，标题在不同的标签内，需要不同的解析方式。我们也不知道哪些标题需要用到什么解析方式，只能把解析不出来的标题打个日志，然后再去慢慢的添加更多的解析方式，那未来肯定会扩展很多的解析方式。</p>
<p>把标题的解析方式做成解析器。每个解析器串成一个链条。通用的解析器优先级更高。链条中直到其中某个解析器解析出标题，就返回。</p>
<p>解析器串起的链条就是&#x3D;&#x3D;责任链模式&#x3D;&#x3D;，创建责任链的地方就是&#x3D;&#x3D;工厂模式&#x3D;&#x3D;。而不同的类实现不同的url解析方法，这就是&#x3D;&#x3D;策略模式&#x3D;&#x3D;，而抽象类里面的逻辑，又像是&#x3D;&#x3D;模板方法模式&#x3D;&#x3D;，一口气就能实现四种模式。</p>
<p><strong>搭建url解析框架</strong></p>
<p>正好想到之前学spring源码的时候，看见spring的参数解析器（就是识别方法的参数名）和我们的这个需求类似，我们可以参考spring去进行框架的搭建。</p>
<p><img src="/.io//1686155313919-a1fc8983-d0a4-44b5-89c8-be33a3f8f199.webp" alt="image.png"></p>
<p>定义接口，&#x3D;&#x3D;核心的接口是<code>getContentTitleMap</code>&#x3D;&#x3D;，其他的方法只是细分的获取步骤。<img src="/.io//1686156003982-fdbe1543-565b-4d48-bd51-13c8ced3c098.webp" alt="image.png"></p>
<p>公共的逻辑放在抽象类。子类<code>commonUrl</code>和<code>WxUrl</code>就是不同的标题解析策略。</p>
<p><img src="/.io//1686155473139-3c9cb804-8181-4387-9225-fe65cc504feb.webp" alt="image.png"></p>
<p><img src="/.io//1686155597468-4fe8d3ca-d06a-43db-94d7-b6ec401cea67.webp" alt="image.png"></p>
<p><img src="/.io//1686155579442-c3d8c9d6-61f2-4f09-aca1-e64d8215612a.webp" alt="image.png"></p>
<p><code>prioritizedUrl</code>是我们的策略类，同时也是组装责任链的工厂。如果你调用它，它会按顺序执行责任链，直到解析出url标题。</p>
<p><img src="/.io//1686155675435-040a3f52-7298-4082-a0a5-111a3ec5b970.webp" alt="image.png"></p>
<blockquote>
<p>看源码能让我们更加深入的理解设计模式的运用，更能为我们平时的开发提供思路灵感</p>
</blockquote>
<p>这样一个url解析框架基本完成，发送消息的时候只需要匹配出所有url，然后通过责任链去解析标题就ok了。</p>
<p>真的ok了吗？</p>
<p>**并行解析  **</p>
<p>如果一个用户发了一段话，里面有非常多的url，我们要串行的一步步解析嘛</p>
<p><img src="/.io//1686209976321-d21f42a8-c880-4bad-a426-7c70e39d92dd.webp" alt="image.png"></p>
<p>耗费的时间是每一个网址解析时间的总和。每&#x3D;&#x3D;个网址的解析其实互不相关&#x3D;&#x3D;，完全可以独立进行。</p>
<p><img src="/.io//1686210057214-c83a524e-02e8-4035-a2e1-368bd8bd8dd4.webp" alt="image.png"></p>
<p>这样立马就省下了大多数的时间，好歹消息的发送者是要阻塞在这里的，也要考虑下它的体验吧。</p>
<p>这样还不够，针对github这种网站，请求时间可能会很长，它决定了用户的等待上限。我们要对它们做一个熔断，也就是超过1s，没拿到网站，就算了。对于代码就是这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> Jsoup.connect(matchUrl);</span><br><span class="line">connect.timeout(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> connect.get();</span><br></pre></td></tr></table></figure>

<p><img src="/.io//1686210321555-fc48ca3c-13dd-42bd-804e-5353424aedef.webp" alt="image.png"></p>
<p>github解析超时直接丢弃。这样的一个并行框架要怎么去写呢？可以用<code>CompletableFuture</code>，不了解的要去先学学<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/java/tbma9x40r1nv40to#iyJF9">JUC</a>，然后再看看美团的一篇技术文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GQGidprakfticYnbVYVYGQ">外卖商家端API的异步化</a>。</p>
<p>美团提供了一个异步的工具类，对<code>CompletableFuture</code>进行了一层封装，用起来更加简洁优雅。</p>
<p>com.abin.mallchat.common.common.utils.discover.AbstractUrlTitleDiscover#getContentTitleMap</p>
<p><img src="/.io//1686210549994-11e82fd4-5163-47fe-8f9e-1390afcb777e.webp" alt="image.png"></p>
<p><strong>总结</strong></p>
<p>看完本篇文章，你能了解到一个简单的url解析框架的从0到1，为什么要做这个功能？调研了哪些方案？方案选型的思考？最小粒度的技术尝试？以及为了支持灵活的扩展与性能做出的框架的搭建过程。</p>
<p>当你明白这些之后，就像是自己从0到1的搭建了这个框架，还有谁会质疑？</p>
<blockquote>
<ol>
<li>爬虫框架jsoup的灵活运用，与chatGPT生成正则对工作的加成（解决问题的能力）</li>
<li>参考Spring框架，写出一套适合自己场景的URL解析框架。体现你对源码的熟悉程度。与对大量设计模式的熟练度。</li>
<li>对并发框架的熟悉程度，以及平常阅读技术博客的习惯，并能灵活运用。</li>
</ol>
</blockquote>
<p><strong>参考源码</strong></p>
<p>正好想到之前学spring源码的时候，看见spring的参数解析器（就是识别方法的参数名）和我们的这个需求类似，我们可以参考spring去进行框架的搭建。</p>
<p><img src="/.io//image-20240627210732942.png" alt="image-20240627210732942"></p>
<p><img src="/.io//image-20240627211058658.png" alt="image-20240627211058658"></p>
<blockquote>
<p>可以看见ParameterNameDiscover有很多的实现</p>
</blockquote>
<p><img src="/.io//image-20240627211126778.png" alt="image-20240627211126778"></p>
<p>我们一般使用的是带有优先级的这个</p>
<p><img src="/.io//image-20240627211518365.png" alt="image-20240627211518365"></p>
<p>这个discover组装了其他的discover</p>
<blockquote>
<p>这个相当于一个工厂实现了Prioritized这个，组装了所有的策略类，串联成一个责任链</p>
</blockquote>
<img src="/.io//image-20240627211622382.png" alt="image-20240627211622382" style="zoom:150%;">

<p>而责任链又用这个来保存</p>
<p><img src="/.io//image-20240627211705087.png" alt="image-20240627211705087"></p>
<p>在最后的解析的时候呢，就会去遍历这个链表谁能够解析成功就直接返回这个结果了，所以直接仿用这个架构</p>
<p><img src="/.io//image-20240627211752786.png" alt="image-20240627211752786"></p>
<p>优先用普通的，然后再用微信的，后续有新的解析器再加上新的解析器	</p>
<p><strong>url解析框架——责任链模式</strong></p>
<p>首先定义一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UrlDiscover</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个是最通用的方法</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Map&lt;String, UrlInfo&gt; <span class="title function_">getUrlContentMap</span><span class="params">(String content)</span>;</span><br><span class="line">	<span class="comment">//给一个非常长的文本内容，返回一个map&lt;匹配到的链接、值是网址内容（标题、描述、logo）&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下都是细化的能力</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    UrlInfo <span class="title function_">getContent</span><span class="params">(String url)</span>;</span><br><span class="line">    <span class="comment">//我们给一串网址就可以解析出网址的标题、logo、描述</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String <span class="title function_">getTitle</span><span class="params">(Document document)</span>;</span><br><span class="line">    <span class="comment">//给一个document解析出一个title</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">(Document document)</span>;</span><br><span class="line">	<span class="comment">//给一个document就能够解析出一个描述</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String <span class="title function_">getImage</span><span class="params">(String url, Document document)</span>;</span><br><span class="line">	<span class="comment">//给一个网址能够解析出具体的logo</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看通用方法的具体实现</p>
<p><img src="/.io//image-20240627212251250.png" alt="image-20240627212251250"></p>
<p>利用抽象类实现骨架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, UrlInfo&gt; <span class="title function_">getUrlContentMap</span><span class="params">(String content)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(content)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; matchList = ReUtil.findAll(PATTERN, content, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//正则匹配、匹配出所有的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//并行请求:CompletableFuture&lt;Pair&lt;String, UrlInfo&gt;&gt; 表示的是一个未来会完成的计算任务，其结果是一个 Pair 对象，该对象包含一个字符串和一个 UrlInfo 实例</span></span><br><span class="line">    List&lt;CompletableFuture&lt;Pair&lt;String, UrlInfo&gt;&gt;&gt; futures = matchList.stream().map(match -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">UrlInfo</span> <span class="variable">urlInfo</span> <span class="operator">=</span> getContent(match);</span><br><span class="line">        <span class="keyword">return</span> Objects.isNull(urlInfo) ? <span class="literal">null</span> : Pair.of(match, urlInfo);</span><br><span class="line">    &#125;)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//CompletableFuture是Java中用于异步编程的工具，允许你以非阻塞的方式执行任务，supplyAsync方法接受一个 Supplier 函数（无参数，返回结果），并异步执行这个函数。所以针对匹配到的地址每一个都进行异步的执行获得urlInfo，如果非空则转换成map进行存储</span></span><br><span class="line">    CompletableFuture&lt;List&lt;Pair&lt;String, UrlInfo&gt;&gt;&gt; future = FutureUtils.sequenceNonNull(futures);</span><br><span class="line">    <span class="comment">/* List&lt;CompletableFuture&lt;Pair&lt;String, UrlInfo&gt;&gt;&gt;每一个都是CompletableFuture对象</span></span><br><span class="line"><span class="comment">    	CompletableFuture&lt;List&lt;Pair&lt;String, UrlInfo&gt;&gt;&gt;是一个单一的CompletableFuture，这样当所有异步操作完成时，可以直接一次性处理所有结果，不需要逐一检查每个CompletableFuture的状态</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//转换对象</span></span><br><span class="line">    <span class="comment">//结果组装</span></span><br><span class="line">    <span class="keyword">return</span> future.join().stream().collect(Collectors.toMap(Pair::getFirst, Pair::getSecond, (a, b) -&gt; a));、</span><br><span class="line">        <span class="comment">//join方法会阻塞当前线程，直到异步计算完成，然后返回计算结果，将里面的值第一作为键，当键冲突时将第一个作为键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看子类都实现了什么</p>
<p><img src="/.io//image-20240627212434223.png" alt="image-20240627212434223"></p>
<p>他有三个子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrioritizedUrlDiscover</span> <span class="keyword">extends</span> <span class="title class_">AbstractUrlDiscover</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> List&lt;UrlDiscover&gt; urlDiscovers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">PrioritizedUrlDiscover</span><span class="params">()</span> &#123;</span><br><span class="line">     urlDiscovers.add(<span class="keyword">new</span> <span class="title class_">WxUrlDiscover</span>());</span><br><span class="line">     urlDiscovers.add(<span class="keyword">new</span> <span class="title class_">CommonUrlDiscover</span>());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">(Document document)</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (UrlDiscover urlDiscover : urlDiscovers) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">urlTitle</span> <span class="operator">=</span> urlDiscover.getTitle(document);</span><br><span class="line">         <span class="keyword">if</span> (StrUtil.isNotBlank(urlTitle)) &#123;</span><br><span class="line">             <span class="keyword">return</span> urlTitle;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">(Document document)</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (UrlDiscover urlDiscover : urlDiscovers) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">urlDescription</span> <span class="operator">=</span> urlDiscover.getDescription(document);</span><br><span class="line">         <span class="keyword">if</span> (StrUtil.isNotBlank(urlDescription)) &#123;</span><br><span class="line">             <span class="keyword">return</span> urlDescription;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getImage</span><span class="params">(String url, Document document)</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (UrlDiscover urlDiscover : urlDiscovers) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">urlImage</span> <span class="operator">=</span> urlDiscover.getImage(url, document);</span><br><span class="line">         <span class="keyword">if</span> (StrUtil.isNotBlank(urlImage)) &#123;</span><br><span class="line">             <span class="keyword">return</span> urlImage;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个子类其实什么都没有做，只是在调用其他人的</p>
<p>真正有自己的方法的是这两个</p>
<p><img src="/.io//image-20240627212648229.png" alt="image-20240627212648229"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonUrlDiscover</span> <span class="keyword">extends</span> <span class="title class_">AbstractUrlDiscover</span> &#123;</span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">(Document document)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> document.title();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">(Document document)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> document.head().select(<span class="string">&quot;meta[name=description]&quot;</span>).attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">     <span class="type">String</span> <span class="variable">keywords</span> <span class="operator">=</span> document.head().select(<span class="string">&quot;meta[name=keywords]&quot;</span>).attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">     <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> StrUtil.isNotBlank(description) ? description : keywords;</span><br><span class="line">     <span class="comment">//只保留一句话的描述</span></span><br><span class="line">     <span class="keyword">return</span> StrUtil.isNotBlank(content) ? content.substring(<span class="number">0</span>, content.indexOf(<span class="string">&quot;。&quot;</span>)) : content;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getImage</span><span class="params">(String url, Document document)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> document.select(<span class="string">&quot;link[type=image/x-icon]&quot;</span>).attr(<span class="string">&quot;href&quot;</span>);</span><br><span class="line">     <span class="comment">//如果没有去匹配含有icon属性的logo</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">href</span> <span class="operator">=</span> StrUtil.isEmpty(image) ? document.select(<span class="string">&quot;link[rel$=icon]&quot;</span>).attr(<span class="string">&quot;href&quot;</span>) : image;</span><br><span class="line">     <span class="comment">//如果url已经包含了logo</span></span><br><span class="line">     <span class="keyword">if</span> (StrUtil.containsAny(url, <span class="string">&quot;favicon&quot;</span>)) &#123;</span><br><span class="line">         <span class="keyword">return</span> url;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果icon可以直接访问或者包含了http</span></span><br><span class="line">     <span class="keyword">if</span> (isConnect(!StrUtil.startWith(href, <span class="string">&quot;http&quot;</span>) ? <span class="string">&quot;http:&quot;</span> + href : href)) &#123;</span><br><span class="line">         <span class="keyword">return</span> href;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> StrUtil.format(<span class="string">&quot;&#123;&#125;/&#123;&#125;&quot;</span>, url, StrUtil.removePrefix(href, <span class="string">&quot;/&quot;</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 针对微信公众号文章的标题获取类</span></span><br><span class="line"><span class="comment"> * Author: &lt;a href=&quot;https://github.com/zongzibinbin&quot;&gt;abin&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Date: 2023-05-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxUrlDiscover</span> <span class="keyword">extends</span> <span class="title class_">AbstractUrlDiscover</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">(Document document)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> document.getElementsByAttributeValue(<span class="string">&quot;property&quot;</span>, <span class="string">&quot;og:title&quot;</span>).attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">(Document document)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> document.getElementsByAttributeValue(<span class="string">&quot;property&quot;</span>, <span class="string">&quot;og:description&quot;</span>).attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getImage</span><span class="params">(String url, Document document)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">href</span> <span class="operator">=</span> document.getElementsByAttributeValue(<span class="string">&quot;property&quot;</span>, <span class="string">&quot;og:image&quot;</span>).attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> isConnect(href) ? href : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个子类最后会被PrioritizedUrlDiscover聚合起来，相当于工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 具有优先级的title查询器</span></span><br><span class="line"><span class="comment"> * Author: &lt;a href=&quot;https://github.com/zongzibinbin&quot;&gt;abin&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Date: 2023-05-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrioritizedUrlDiscover</span> <span class="keyword">extends</span> <span class="title class_">AbstractUrlDiscover</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;UrlDiscover&gt; urlDiscovers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrioritizedUrlDiscover</span><span class="params">()</span> &#123;</span><br><span class="line">        urlDiscovers.add(<span class="keyword">new</span> <span class="title class_">WxUrlDiscover</span>());</span><br><span class="line">        urlDiscovers.add(<span class="keyword">new</span> <span class="title class_">CommonUrlDiscover</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化的时候进行聚合，组成一个责任链，然后每次去获取title、logo、description就去遍历这个子类，遍历这个责任链，获取到了就返回，没获取到就继续遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">(Document document)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (UrlDiscover urlDiscover : urlDiscovers) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">urlTitle</span> <span class="operator">=</span> urlDiscover.getTitle(document);</span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isNotBlank(urlTitle)) &#123;</span><br><span class="line">                <span class="keyword">return</span> urlTitle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">(Document document)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (UrlDiscover urlDiscover : urlDiscovers) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">urlDescription</span> <span class="operator">=</span> urlDiscover.getDescription(document);</span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isNotBlank(urlDescription)) &#123;</span><br><span class="line">                <span class="keyword">return</span> urlDescription;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getImage</span><span class="params">(String url, Document document)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (UrlDiscover urlDiscover : urlDiscovers) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">urlImage</span> <span class="operator">=</span> urlDiscover.getImage(url, document);</span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isNotBlank(urlImage)) &#123;</span><br><span class="line">                <span class="keyword">return</span> urlImage;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来是我们自己做的优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, UrlInfo&gt; <span class="title function_">getUrlContentMap</span><span class="params">(String content)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(content)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; matchList = ReUtil.findAll(PATTERN, content, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并行请求</span></span><br><span class="line">    List&lt;CompletableFuture&lt;Pair&lt;String, UrlInfo&gt;&gt;&gt; futures = matchList.stream().map(match -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//Supplier&lt;U&gt; supplier: 这是一个函数接口，它不接受任何参数并返回一个结果（类型为U）</span></span><br><span class="line">        <span class="type">UrlInfo</span> <span class="variable">urlInfo</span> <span class="operator">=</span> getContent(match);</span><br><span class="line">        <span class="keyword">return</span> Objects.isNull(urlInfo) ? <span class="literal">null</span> : Pair.of(match, urlInfo);</span><br><span class="line">    &#125;)).collect(Collectors.toList());</span><br><span class="line">    CompletableFuture&lt;List&lt;Pair&lt;String, UrlInfo&gt;&gt;&gt; future = FutureUtils.sequenceNonNull(futures);</span><br><span class="line">    <span class="comment">//结果组装</span></span><br><span class="line">    <span class="keyword">return</span> future.join().stream().collect(Collectors.toMap(Pair::getFirst, Pair::getSecond, (a, b) -&gt; a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> Jsoup.connect(matchUrl);</span><br><span class="line">connect.timeout(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> connect.get();</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240627212851590.png" alt="image-20240627212851590"></p>
<p>github解析超时直接丢弃。这样的一个并行框架要怎么去写呢？可以用<code>CompletableFuture</code>，不了解的要去先学学<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/java/tbma9x40r1nv40to#iyJF9">JUC</a>，然后再看看美团的一篇技术文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GQGidprakfticYnbVYVYGQ">外卖商家端API的异步化</a>。</p>
<p>美团提供了一个异步的工具类，对<code>CompletableFuture</code>进行了一层封装，用起来更加简洁优雅。</p>
<p>com.abin.mallchat.common.common.utils.discover.AbstractUrlTitleDiscover#getContentTitleMap</p>
<p><img src="/.io//image-20240627212905610.png" alt="image-20240627212905610"></p>
<p>这里看一下getContent的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UrlInfo <span class="title function_">getContent</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> getUrlDocument(assemble(url));</span><br><span class="line">    <span class="comment">//assemble检查url是不是以http开头的如果不是手动加上</span></span><br><span class="line">    <span class="comment">//getUrlDocument就是下载指定的url</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(document)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UrlInfo.builder()</span><br><span class="line">            .title(getTitle(document))</span><br><span class="line">            .description(getDescription(document))</span><br><span class="line">            .image(getImage(assemble(url), document)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">assemble</span><span class="params">(String url)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StrUtil.startWith(url, <span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://&quot;</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Document <span class="title function_">getUrlDocument</span><span class="params">(String matchUrl)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> Jsoup.connect(matchUrl);</span><br><span class="line">        connect.timeout(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//超时熔断</span></span><br><span class="line">        <span class="keyword">return</span> connect.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;find error:url:&#123;&#125;&quot;</span>, matchUrl, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里做熔断的原因是github的解析是更慢的，并行的解析可能会因为他而拖后腿</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ol>
<li><strong>创建型模式</strong>：涉及对象实例化，&#x3D;&#x3D;用于创建对象的模式&#x3D;&#x3D;，&#x3D;&#x3D;可以增加程序的灵活性和可重用性&#x3D;&#x3D;。常见的创建型模式有&#x3D;&#x3D;工厂方法、抽象工厂、单例&#x3D;&#x3D;、建造者、原型等。</li>
<li><strong>结构型模式</strong>：&#x3D;&#x3D;涉及类和对象的组合，用于设计类和对象的结构&#x3D;&#x3D;，以便更好地实现程序的功能。常见的&#x3D;&#x3D;结构型模式有适配器&#x3D;&#x3D;、桥接、组合、装饰、外观、享元、代理等。</li>
<li><strong>行为型模式</strong>：&#x3D;&#x3D;关注对象之间的通信&#x3D;&#x3D;，&#x3D;&#x3D;包括责任链&#x3D;&#x3D;、命令、解释器、迭代器、中介者、备忘录、&#x3D;&#x3D;观察者&#x3D;&#x3D;、状态、&#x3D;&#x3D;策略&#x3D;&#x3D;、&#x3D;&#x3D;模板方法&#x3D;&#x3D;、访问者等。</li>
</ol>
<h2 id="01、什么是责任链模式？"><a href="#01、什么是责任链模式？" class="headerlink" title="01、什么是责任链模式？"></a>01、什么是责任链模式？</h2><pre><code>责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，==它使多个对象都有机会处理请求==，从而避免了请求的发送者和接收者之间的耦合关系。
==请求会沿着一条链传递，直到有一个对象处理它为止==。这种模式==常用于处理不同类型的请求以及在不确定具体接收者的情况下==将请求传递给多个对象中的一个。
</code></pre>
<p><img src="/.io//shejimoshi-20240309104732.png" alt="天未：图解 23 种设计模式"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>责任链模式主要包括以下几个角色：</p>
<ul>
<li>**&#x3D;&#x3D;Handler（抽象处理者）&#x3D;&#x3D;**：&#x3D;&#x3D;定义了一个处理请求的接口或抽象类&#x3D;&#x3D;，其中&#x3D;&#x3D;通常会包含一个指向链中&#x3D;&#x3D;下一个处理者的引用。</li>
<li><strong>ConcreteHandler（具体处理者）</strong>：&#x3D;&#x3D;实现抽象处理者的处理方法&#x3D;&#x3D;，如果它能处理请求，则处理；否则将请求转发给链中的下一个处理者。</li>
<li><strong>Client（客户端）</strong>：&#x3D;&#x3D;创建处理链，并向链的第一个处理者对象提交请求&#x3D;&#x3D;。</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>客户端将&#x3D;&#x3D;请求发送给链上的第一个处理者对象&#x3D;&#x3D;。</li>
<li>处理者接&#x3D;&#x3D;收到请求后&#x3D;&#x3D;，&#x3D;&#x3D;决定自己是否有能力&#x3D;&#x3D;进行处理。<ul>
<li>&#x3D;&#x3D;如果可以处理&#x3D;&#x3D;，&#x3D;&#x3D;就处理&#x3D;&#x3D;请求。</li>
<li>&#x3D;&#x3D;如果不能&#x3D;&#x3D;处理，就将请求&#x3D;&#x3D;转发给链上的下一个处理者&#x3D;&#x3D;。</li>
</ul>
</li>
<li>&#x3D;&#x3D;过程重复&#x3D;&#x3D;，直到链上的某个处理者能处理该请求或者链上没有更多的处理者。</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>责任链模式适用于以下场景：</p>
<ul>
<li>有&#x3D;&#x3D;多个对象可以处理同一请求&#x3D;&#x3D;，但具体由&#x3D;&#x3D;哪个对象处理则在运行时动态决定&#x3D;&#x3D;。</li>
<li>在&#x3D;&#x3D;不明确指定接收者&#x3D;&#x3D;的情况下，向&#x3D;&#x3D;多个对象中的一个提交请求&#x3D;&#x3D;。</li>
<li>需要&#x3D;&#x3D;动态组织和管理处理者&#x3D;&#x3D;时。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>降低耦合度：&#x3D;&#x3D;它将请求的发送者和接收者解耦&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;增加了给对象指派职责&#x3D;&#x3D;的灵活性：可以在&#x3D;&#x3D;运行时动态改变链中的成员或调整它们的次序&#x3D;&#x3D;。</li>
<li>可以&#x3D;&#x3D;方便地增加新的处理类&#x3D;&#x3D;，在&#x3D;&#x3D;不影响现有代码的情况下&#x3D;&#x3D;扩展功能。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>&#x3D;&#x3D;请求可能不会被处理&#x3D;&#x3D;：如果没有任何处理者处理请求，&#x3D;&#x3D;它可能会达到链的末端并被丢弃&#x3D;&#x3D;。</li>
<li>性能问题：&#x3D;&#x3D;一个请求可能会在链上进行较长的遍历&#x3D;&#x3D;，影响性能。</li>
<li>&#x3D;&#x3D;调试困难&#x3D;&#x3D;：特别是&#x3D;&#x3D;在链较长时&#x3D;&#x3D;，调试可能会比较麻烦。</li>
</ul>
<h2 id="02、什么是工厂模式？"><a href="#02、什么是工厂模式？" class="headerlink" title="02、什么是工厂模式？"></a>02、什么是工厂模式？</h2><p>工厂模式（Factory Pattern）属于&#x3D;&#x3D;创建型设计模式&#x3D;&#x3D;，主要用于&#x3D;&#x3D;创建对象&#x3D;&#x3D;，而&#x3D;&#x3D;不暴露创建对象的逻辑&#x3D;&#x3D;给客户端。</p>
<p>其在&#x3D;&#x3D;父类&#x3D;&#x3D;中提供一个&#x3D;&#x3D;创建对象&#x3D;&#x3D;的方法， 允许&#x3D;&#x3D;子类&#x3D;&#x3D;&#x3D;&#x3D;决定实例化对象的类型&#x3D;&#x3D;。</p>
<p>举例来说，&#x3D;&#x3D;卡车 Truck 和轮船 Ship 都必须实现&#x3D;&#x3D;运输工具 &#x3D;&#x3D;Transport 接口&#x3D;&#x3D;，该接口&#x3D;&#x3D;声明了一个名为 deliver&#x3D;&#x3D; 的方法。</p>
<p>&#x3D;&#x3D;卡车都实现了 deliver 方法&#x3D;&#x3D;，但是&#x3D;&#x3D;卡车的 deliver&#x3D;&#x3D; 是在&#x3D;&#x3D;陆地上运输&#x3D;&#x3D;，而&#x3D;&#x3D;轮船的 deliver&#x3D;&#x3D; 是在&#x3D;&#x3D;海上运输&#x3D;&#x3D;。</p>
<p><img src="/.io//shejimoshi-20240314083451.png" alt="refactoringguru.cn：工厂模式"></p>
<p>调用工厂方法的代码（客户端代码）&#x3D;&#x3D;无需了解不同子类之间的差别&#x3D;&#x3D;，只管&#x3D;&#x3D;调用接口的 deliver 方法&#x3D;&#x3D;即可。</p>
<h3 id="工厂模式的主要类型"><a href="#工厂模式的主要类型" class="headerlink" title="工厂模式的主要类型"></a>工厂模式的主要类型</h3><p>①、&#x3D;&#x3D;<strong>简单工厂模式</strong>（Simple Factory）&#x3D;&#x3D;：它&#x3D;&#x3D;引入了创建者的概念&#x3D;&#x3D;，将&#x3D;&#x3D;实例化的代码从应用程序的业务逻辑中分离出来&#x3D;&#x3D;。&#x3D;&#x3D;简单工厂模式&#x3D;&#x3D;包括&#x3D;&#x3D;一个工厂类&#x3D;&#x3D;，它&#x3D;&#x3D;提供一个方法用于创建对象&#x3D;&#x3D;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Transport <span class="title function_">createTransport</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;truck&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Truck</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ship&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ship</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Transport</span> <span class="variable">truck</span> <span class="operator">=</span> SimpleFactory.createTransport(<span class="string">&quot;truck&quot;</span>);</span><br><span class="line">        truck.deliver();</span><br><span class="line"></span><br><span class="line">        <span class="type">Transport</span> <span class="variable">ship</span> <span class="operator">=</span> SimpleFactory.createTransport(<span class="string">&quot;ship&quot;</span>);</span><br><span class="line">        ship.deliver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂负责创建对象，外部直接调用创建方法之后直接引用就好</span></span><br></pre></td></tr></table></figure>

<p>②、&#x3D;&#x3D;<strong>工厂方法模式</strong>（Factory Method）：定义一个创建对象的接口&#x3D;&#x3D;，但&#x3D;&#x3D;由子类决定&#x3D;&#x3D;要&#x3D;&#x3D;实例化的类是哪一个&#x3D;&#x3D;。&#x3D;&#x3D;工厂方法&#x3D;&#x3D;让&#x3D;&#x3D;类的实例化推迟到子类进行&#x3D;&#x3D;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Transport</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deliver</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义具体的行为逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">implements</span> <span class="title class_">Transport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deliver</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在陆地上运输&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ship</span> <span class="keyword">implements</span> <span class="title class_">Transport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deliver</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在海上运输&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类具体决定怎么实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TransportFactory</span> &#123;</span><br><span class="line">    Transport <span class="title function_">createTransport</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义创建的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TruckFactory</span> <span class="keyword">implements</span> <span class="title class_">TransportFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Transport <span class="title function_">createTransport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Truck</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShipFactory</span> <span class="keyword">implements</span> <span class="title class_">TransportFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Transport <span class="title function_">createTransport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ship</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类自己决定创建的具体实体类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TransportFactory</span> <span class="variable">truckFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TruckFactory</span>();</span><br><span class="line">        <span class="type">Transport</span> <span class="variable">truck</span> <span class="operator">=</span> truckFactory.createTransport();</span><br><span class="line">        truck.deliver();</span><br><span class="line"></span><br><span class="line">        <span class="type">TransportFactory</span> <span class="variable">shipFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShipFactory</span>();</span><br><span class="line">        <span class="type">Transport</span> <span class="variable">ship</span> <span class="operator">=</span> shipFactory.createTransport();</span><br><span class="line">        ship.deliver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<p>工厂模式是创建行模式的一种，核心是为创建对象提供一个统一的接口，隐藏具体的创建逻辑</p>
<p>主要有以下几种实现方式：</p>
<p>1.简单工厂模式：</p>
<p>提供一个工厂类，可以根据具体传入的参数来决定创建那种实例，但是&#x3D;&#x3D;违反了开闭原则，即对外开放，对修改关闭。增加新产品时需要修改工厂类的代码&#x3D;&#x3D;。</p>
<p>2.工厂方法模式：</p>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。&#x3D;&#x3D;工厂方法使一个类的实例化延迟到其子类&#x3D;&#x3D;，这样的好处使&#x3D;&#x3D;可以让系统在不修改原有代码类的情况引进新的实现类，符合开闭原则&#x3D;&#x3D;。</p>
<p>3.抽象工厂模式</p>
<p>&#x3D;&#x3D;提供一个创建一系列相关或相互依赖对象的接口&#x3D;&#x3D;，&#x3D;&#x3D;而无需指定他们具体的类&#x3D;&#x3D;。是一种更加高级的工厂模式，可以创建一组相关的产品，而不是单一的产品。适用于系统需要多个产品系列，且这些产品系列之间有依赖关系的情况。</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>封装性</strong>: 工厂模式通过&#x3D;&#x3D;将对象的创建封装在工厂类&#x3D;&#x3D;中，&#x3D;&#x3D;隐藏了对象创建的细节&#x3D;&#x3D;，使得代码更加清晰和易于维护。</li>
<li><strong>扩展性</strong>: 当&#x3D;&#x3D;需要添加新的产品&#x3D;&#x3D;时，只需要&#x3D;&#x3D;增加新的产品类和对应的工厂类&#x3D;&#x3D;（或修改工厂方法），原有代码无须改动，符合开闭原则。</li>
<li><strong>解耦</strong>: &#x3D;&#x3D;使用者与具体产品的创建过程解耦&#x3D;&#x3D;，&#x3D;&#x3D;用户只需要知道所需产品的抽象接口&#x3D;&#x3D;，而不需要知道具体产品的创建细节。</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>当&#x3D;&#x3D;一个类无法预料要创建哪种类的对象&#x3D;&#x3D;，或者&#x3D;&#x3D;不想硬编码具体类&#x3D;&#x3D;的创建时。</li>
<li>当&#x3D;&#x3D;一个系统要独立于它所创建的产品对象&#x3D;&#x3D;，并且&#x3D;&#x3D;希望由具体工厂来决定创建什么产品&#x3D;&#x3D;时。</li>
<li>当一&#x3D;&#x3D;个系统需要提供多种产品&#x3D;&#x3D;，并且&#x3D;&#x3D;每次创建产品时都需要做出选择&#x3D;&#x3D;时。</li>
</ul>
<h2 id="03、什么是单例模式？"><a href="#03、什么是单例模式？" class="headerlink" title="03、什么是单例模式？"></a>03、什么是单例模式？</h2><pre><code>单例模式（Singleton Pattern）是一种==创建型设计模式==，它确保==一个类只有一个实例==，并==提供一个全局访问点来获取该实例==。单例模式主要用于==控制对某些共享资源的访问==，例如==配置管理器、连接池、线程池、日志对象==等。
</code></pre>
<h3 id="实现单例模式的关键点？"><a href="#实现单例模式的关键点？" class="headerlink" title="实现单例模式的关键点？"></a>实现单例模式的关键点？</h3><ol>
<li><blockquote>
<p>&#x3D;&#x3D;<strong>私有构造方法</strong>&#x3D;&#x3D;：确保&#x3D;&#x3D;外部代码不能通过构造器创建类&#x3D;&#x3D;的实例。</p>
<ol>
<li><strong>控制实例化</strong>: 通过&#x3D;&#x3D;私有化构造函数&#x3D;&#x3D;，类能够&#x3D;&#x3D;完全控制自身的实例化过程&#x3D;&#x3D;。这意味着&#x3D;&#x3D;只有类内部的代码才能创建类的实例&#x3D;&#x3D;，从而确保了&#x3D;&#x3D;外部代码不能随意生成多个实例&#x3D;&#x3D;，违背单例模式的初衷。</li>
<li><strong>确保唯一性</strong>: 单例模式要求在任何情况下，针对特定的单例类，&#x3D;&#x3D;在整个应用程序中只能存在一个实例&#x3D;&#x3D;。私&#x3D;&#x3D;有构造函数阻止了外部的“new”操作&#x3D;&#x3D;，这是实现这一要求的基础。</li>
</ol>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>私有静态实例变量</strong>&#x3D;&#x3D;：&#x3D;&#x3D;持有类的唯一实例&#x3D;&#x3D;。</p>
</li>
<li><p>**&#x3D;&#x3D;公有静态方法&#x3D;&#x3D;**：提供全局访问点以获取实例，如果实例不存在，则在内部创建。</p>
</li>
</ol>
<h3 id="常见的单例模式实现"><a href="#常见的单例模式实现" class="headerlink" title="常见的单例模式实现"></a>常见的单例模式实现</h3><h4 id="01、饿汉式如何实现单例？"><a href="#01、饿汉式如何实现单例？" class="headerlink" title="01、饿汉式如何实现单例？"></a>01、饿汉式如何实现单例？</h4><pre><code>饿汉式单例（Eager Initialization）在==类加载时就急切地创建实例==，==不管你后续用不用得到==，这也是饿汉式的来源，简单但不支持延迟加载实例。
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="02、懒汉式如何实现单例？"><a href="#02、懒汉式如何实现单例？" class="headerlink" title="02、懒汉式如何实现单例？"></a>02、懒汉式如何实现单例？</h4><pre><code>==懒汉式单例==（Lazy Initialization）==在实际使用时才创建实例==，“确实懒”（😂）。这种实现方式==需要考虑线程安全问题==，因此一般会带上 [==synchronized 关键字==open in new window](https://javabetter.cn/thread/synchronized-1.html)。
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要的时候再new出来</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="03、双重检查锁定如何实现单例？"><a href="#03、双重检查锁定如何实现单例？" class="headerlink" title="03、双重检查锁定如何实现单例？"></a>03、双重检查锁定如何实现单例？</h4><pre><code>双重检查锁定（Double-Checked Locking）==结合了懒汉式的延迟加载和线程安全==，同时==又减少了同步的开销==，主要是用 ==synchronized 同步代码块来替代同步方法==。
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//synchronized (Singleton.class) 是Java中用于同步代码块的关键字用法，它确保了在同一时刻，只有一个线程能够执行该代码块内的内容。这里的同步是基于给定的锁对象进行的，而在本例中，锁对象是 Singleton.class，即Singleton类的类对象（也称为类的Class对象）。</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;当 instance 创建后，再次调用 getInstance 方法时，不会进入同步代码块&#x3D;&#x3D;，从而提高了性能。</p>
<p>&#x3D;&#x3D;在 instance 前加上 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/volatile.html">volatile 关键字&#x3D;&#x3D;open in new window</a>，可以&#x3D;&#x3D;防止指令重排&#x3D;&#x3D;，因为 <code>instance = new Singleton()</code> &#x3D;&#x3D;并不是一个原子操作，可能会被重排序&#x3D;&#x3D;，导致其他线程获取到未初始化完成的实例。</p>
</blockquote>
<blockquote>
<h3 id="instance-new-Singleton"><a href="#instance-new-Singleton" class="headerlink" title="instance = new Singleton();"></a><code>instance = new Singleton();</code></h3><p>这行代码看起来简单，但实际上涉及了多个步骤：</p>
<ol>
<li>&#x3D;&#x3D;<strong>分配内存</strong>: 为新的<code>Singleton</code>实例分配内存空间。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<strong>初始化</strong>: 在分配的内存上初始化<code>Singleton</code>对象。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<strong>赋值</strong>: 将初始化完成的对象引用赋值给<code>instance</code>变量。&#x3D;&#x3D;</li>
</ol>
<h3 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h3><p>如果&#x3D;&#x3D;没有<code>volatile</code>关键字&#x3D;&#x3D;，&#x3D;&#x3D;上述步骤可能会被重排序&#x3D;&#x3D;，例如，&#x3D;&#x3D;步骤2和步骤3之间的顺序可能被更改&#x3D;&#x3D;，&#x3D;&#x3D;即处理器可能会先执行赋值操作，然后才完成对象的初始化&#x3D;&#x3D;。在&#x3D;&#x3D;多线程环境下&#x3D;&#x3D;，&#x3D;&#x3D;如果一个线程在对象初始化完成之前就看到了<code>instance</code>不为<code>null</code>&#x3D;&#x3D;，那么它可能&#x3D;&#x3D;会获取到一个未完全初始化的对象&#x3D;&#x3D;，从而引发错误或难以预料的行为。</p>
<h3 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a><code>volatile</code>关键字的作用</h3><ul>
<li><p>&#x3D;&#x3D;<strong>可见性</strong>: 确保对<code>volatile</code>修饰的变量的修改能够立即被其他线程看到，消除了缓存一致性问题&#x3D;&#x3D;。</p>
</li>
<li><p><strong>禁止指令重排序</strong>: 关键的是，&#x3D;&#x3D;<code>volatile</code>还隐含地禁止了对它修饰的变量相关读写操作的指令重排序。这意味着，在多线程环境中，对<code>instance</code>的写操作（包括分配内存、初始化对象和赋值）将被视为一个不可分割的整体&#x3D;&#x3D;，保证了其他线程看到的&#x3D;&#x3D;<code>instance</code>要么是<code>null</code>（即实例未被创建）&#x3D;&#x3D;，要么是完全初始化后的对象引用。</p>
<p>下面是<code>volatile</code>如何工作的简要概述：</p>
<ol>
<li><strong>内存屏障（Memory Barrier）</strong>: &#x3D;&#x3D;当一个变量被声明为<code>volatile</code>时，JVM会在其写操作之后和读操作之前插入内存屏障&#x3D;&#x3D;。&#x3D;&#x3D;内存屏障是一种CPU指令，它强制执行一些操作，如刷新缓存、暂停重排序等&#x3D;&#x3D;，来&#x3D;&#x3D;确保某些内存操作的完成顺序&#x3D;&#x3D;。</li>
<li><strong>可见性保证</strong>: 写操作完成后，&#x3D;&#x3D;<code>volatile</code>变量的最新值会立即被刷入主内存&#x3D;&#x3D;，&#x3D;&#x3D;并且任何后续对该变量的读取都会直接从主内存中读取，而不是从线程的本地缓存中读取&#x3D;&#x3D;。这意味着，&#x3D;&#x3D;一旦一个线程修改了<code>volatile</code>变量，其他线程总能看到这个修改，无论它们运行在哪个CPU核心上&#x3D;&#x3D;。</li>
<li><strong>禁止特定类型指令重排序</strong>: <code>volatile</code>除了确保可见性，&#x3D;&#x3D;还禁止了可能导致数据不一致的特定类型的指令重排序&#x3D;&#x3D;。这意味着编译器和处理器不会对涉及<code>volatile</code>变量的读写操作进行可能影响其正确性的重排序，确保了操作的顺序性。</li>
</ol>
</li>
</ul>
<p>总结来说，<code>volatile</code>通过内存屏障和对内存访问规则的强化，确保了多线程环境下对变量访问的正确顺序和可见性，从而间接解决了因缓存导致的数据不一致问题。、</p>
</blockquote>
<h4 id="04、静态内部类如何实现单例？"><a href="#04、静态内部类如何实现单例？" class="headerlink" title="04、静态内部类如何实现单例？"></a>04、静态内部类如何实现单例？</h4><p>利用 Java 的<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/static.html">静态内部类open in new window</a>（Static Nested Class）和<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/class-load.html">类加载机制open in new window</a>来实现线程安全的延迟初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当第一次加载 Singleton 类时并不会初始化 SingletonHolder，&#x3D;&#x3D;只有在第一次调用 getInstance 方法时&#x3D;&#x3D;才会&#x3D;&#x3D;导致 SingletonHolder 被加载&#x3D;&#x3D;，从而实例化 instance。</p>
<h4 id="05、枚举如何实现单例？"><a href="#05、枚举如何实现单例？" class="headerlink" title="05、枚举如何实现单例？"></a>05、枚举如何实现单例？</h4><p>使用<a target="_blank" rel="noopener" href="https://javabetter.cn/basic-extra-meal/enum.html">枚举（Enum）open in new window</a>实现单例是最简单的方式，不仅不需要考虑线程同步问题，还能防止反射攻击和序列化问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">// 可以添加实例方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="单例模式的好处有哪些？"><a href="#单例模式的好处有哪些？" class="headerlink" title="单例模式的好处有哪些？"></a>单例模式的好处有哪些？</h3><p>&#x3D;&#x3D;单例模式能确保一个类仅有一个实例&#x3D;&#x3D;，&#x3D;&#x3D;并提供一个全局访问点&#x3D;&#x3D;来访问这个实例。</p>
<p>这对于&#x3D;&#x3D;需要控制资源使用或需要共享资源的情况非常有用&#x3D;&#x3D;，比如&#x3D;&#x3D;数据库连接池，通过单例模式，可以避免对资源的重复创建和销毁&#x3D;&#x3D;，从而提高资源利用率和系统性能。</p>
<p>单例模式有 5 种实现方式，常见的有&#x3D;&#x3D;饿汉式、懒汉式、双重检查锁定、静态内部类和枚举&#x3D;&#x3D;。</p>
<h2 id="04-什么是策略模式？（行为型模式）"><a href="#04-什么是策略模式？（行为型模式）" class="headerlink" title="04.什么是策略模式？（行为型模式）"></a>04.什么是策略模式？（行为型模式）</h2><p><strong>策略模式</strong> : &#x3D;&#x3D;定义了 算法家族&#x3D;&#x3D; , &#x3D;&#x3D;分别 封装起来&#x3D;&#x3D; , 让它们之间 , &#x3D;&#x3D;可以 相互替换&#x3D;&#x3D; , &#x3D;&#x3D;此模式 让 算法的变化 不会影响到 使用算法的用户&#x3D;&#x3D; ;</p>
<p>将 不同的算法 , 封装到 不同的类 中 , 让&#x3D;&#x3D;它们之间可以 相互替换&#x3D;&#x3D; ,<br>使用&#x3D;&#x3D;算法的用户 即 应用层 , 感知不到 算法已经被替换了&#x3D;&#x3D; ;</p>
<p><strong>实际的业务场景 :</strong></p>
<ul>
<li><strong>不同业务逻辑 :</strong> 商品促销 , 促销策略 , 不同的促销策略算法 , 封装到不同的类中 ;</li>
<li><strong>代码优化 :</strong> 如果代码中 , 有大量的 if … else … 代码 , 可以通过策略模式 , 替换相关逻辑 ;</li>
</ul>
<h3 id="策略模式适用场景"><a href="#策略模式适用场景" class="headerlink" title="策略模式适用场景"></a>策略模式适用场景</h3><blockquote>
<p><strong>行为切换</strong> : 系统有 很多类 , &#x3D;&#x3D;这些类的区别仅仅在于它们的 行为不同&#x3D;&#x3D; ; 使用&#x3D;&#x3D;策略模式&#x3D;&#x3D; , 可以 &#x3D;&#x3D;动态地 让 用户对象 在这些行为中&#x3D;&#x3D;, &#x3D;&#x3D;选择一个行为&#x3D;&#x3D; ;<br>将对象的 不同的行为 , 封装到 不同的类 中 , 每个行为对应一种策略 ;</p>
<p>算法选择 : &#x3D;&#x3D;系统中需要 动态地 在 几种算法 中 选择一种&#x3D;&#x3D; ;<br>算法 就是 策略 , &#x3D;&#x3D;其中封装了一系列的业务逻辑及计算方式&#x3D;&#x3D; ;<br>如 : 计算方式 , 给定两个数字 ; 使用加法策略 , 将两个数相加 ; 使用乘法策略 , 将两个数相乘 ;</p>
</blockquote>
<h3 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h3><blockquote>
<p><strong>策略模式优点</strong> :</p>
<p><strong>开闭原则</strong> : 策略模式 提供了 对 开闭原则 的支持 , &#x3D;&#x3D;可以在不修改原有系统的基础上 , 选择不同的行为 , 也可以 额外扩展其它行为&#x3D;&#x3D; ;<br>避免代码冗余 : 可以 &#x3D;&#x3D;避免使用多重条件判定语句 ; 可以避免出现大量的 if … else … 语句 , switch 语句等&#x3D;&#x3D; ;<br><strong>安全保密</strong> : &#x3D;&#x3D;策略模式可以 提高算法的 保密性 和 安全性&#x3D;&#x3D; ; 在&#x3D;&#x3D;终端使用策略时 , 只需要知道策略的作用即可&#x3D;&#x3D; , 不需要知道策略时如何实现的 ;<br><strong>策略模式缺点 :</strong></p>
<ul>
<li><strong>策略类选择 :</strong> &#x3D;&#x3D;客户端 必须 知道所有的 策略类&#x3D;&#x3D; , 并且&#x3D;&#x3D;自行决定 使用哪个策略类&#x3D;&#x3D; ;</li>
<li><strong>增加复杂性 :</strong> &#x3D;&#x3D;如果系统很复杂&#x3D;&#x3D; , 会 产生很多策略类 ;</li>
</ul>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p><strong>业务场景 :</strong></p>
<p><strong>商场促销活动 :</strong> 促销是商品的一个行为 , 促销行为 , 设置多个促销行为 , 将其封装到类中 ;</p>
</blockquote>
<p><strong>1、促销策略接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 促销策略接口</span></span><br><span class="line"><span class="comment"> *      所有的促销策略 , 都要实现该接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 促销活动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doPromotion</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2、满减促销策略</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 满减促销策略</span></span><br><span class="line"><span class="comment"> *      满 100 减 20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManJianPromotionStrategy</span> <span class="keyword">implements</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPromotion</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满减促销 , 满 100 减 20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>3、返现促销策略</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返现促销策略</span></span><br><span class="line"><span class="comment"> *      购买后返优惠券</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanXianPromotionStrategy</span> <span class="keyword">implements</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPromotion</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返现促销 , 返优惠券 10 元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>4、空促销策略</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空的促销策略</span></span><br><span class="line"><span class="comment"> *      为了防止空指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmptyPromotionStrategy</span> <span class="keyword">implements</span> <span class="title class_">PromotionStrategy</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPromotion</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原价出售&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>满减、返现、空促销是具体的促销策略实现，实现了促销策略接口</strong></p>
</blockquote>
<p><strong>5、促销策略工厂</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 促销策略工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PromotionStrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, PromotionStrategy&gt; PROMOTION_STRATEGY_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.MANJIAN, <span class="keyword">new</span> <span class="title class_">ManJianPromotionStrategy</span>());</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.FANXIAN, <span class="keyword">new</span> <span class="title class_">FanXianPromotionStrategy</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//把具体的实现都放入到map</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数不能被外界访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PromotionStrategyFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的键值获取相应的促销策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promotionKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PromotionStrategy <span class="title function_">getPromotionStrategy</span><span class="params">(String promotionKey)</span> &#123;</span><br><span class="line">        <span class="type">PromotionStrategy</span> <span class="variable">promotionStrategy</span> <span class="operator">=</span> PROMOTION_STRATEGY_MAP.get(promotionKey);</span><br><span class="line">        <span class="keyword">return</span> promotionStrategy != <span class="literal">null</span> ? promotionStrategy : <span class="keyword">new</span> <span class="title class_">EmptyPromotionStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用这种方式声明常量 , 可以起到逻辑上分组的作用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PromotionKey</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">MANJIAN</span> <span class="operator">=</span> <span class="string">&quot;ManJian&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">FANXIAN</span> <span class="operator">=</span> <span class="string">&quot;FanXian&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>6、促销活动</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 促销活动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PromotionActivity</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 促销策略 , 通过构造器注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> PromotionStrategy promotionStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PromotionActivity</span><span class="params">(PromotionStrategy promotionStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.promotionStrategy = promotionStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行促销策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executePromotionStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.promotionStrategy.doPromotion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>7、测试类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取促销策略</span></span><br><span class="line">        <span class="type">PromotionStrategy</span> <span class="variable">promotionStrategy</span> <span class="operator">=</span> PromotionStrategyFactory.</span><br><span class="line">                getPromotionStrategy(PromotionStrategyFactory.PromotionKey.FANXIAN);</span><br><span class="line">        <span class="comment">// 创建促销活动 , 并执行促销策略</span></span><br><span class="line">        <span class="type">PromotionActivity</span> <span class="variable">promotionActivity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PromotionActivity</span>(promotionStrategy);</span><br><span class="line">        <span class="comment">// 执行促销策略</span></span><br><span class="line">        promotionActivity.executePromotionStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="05-什么是模板方法模式？（行为型模式）"><a href="#05-什么是模板方法模式？（行为型模式）" class="headerlink" title="05.什么是模板方法模式？（行为型模式）"></a>05.什么是模板方法模式？（行为型模式）</h2><blockquote>
<ul>
<li>&#x3D;&#x3D;模板方法模式（Template Method Pattern）&#x3D;&#x3D;，又叫模板模式(Template Pattern)，&#x3D;&#x3D;在一个抽象类公开定义了执行它的方法的模板。&#x3D;&#x3D;它的&#x3D;&#x3D;子类可以按需要重写方法实现&#x3D;&#x3D;，但&#x3D;&#x3D;调用将以抽象类中定义的方式进行&#x3D;&#x3D;。</li>
<li>简单说，模板方法模式，&#x3D;&#x3D;定义一个操作中的算法的骨架&#x3D;&#x3D;，而&#x3D;&#x3D;将一些步骤延迟到子类中&#x3D;&#x3D;，使得&#x3D;&#x3D;子类可以不改变一个算法的结构&#x3D;&#x3D;，就可以&#x3D;&#x3D;重定义该算法的某些特定步骤&#x3D;&#x3D;，这种类型的设计模式属于行为型模式。</li>
</ul>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/.io//watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q2i5q2l5YmN6KGM,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>对原理类图的说明：</p>
<ul>
<li>AbstractClass 抽象类， &#x3D;&#x3D;类中实现了模板方法(template)，定义了算法的骨架&#x3D;&#x3D;，具体子类需要&#x3D;&#x3D;去实现 其它的抽象方法 operation2,3,4&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;ConcreteClass 实现抽象方法，假设是operation2,3,4, 以完成算法中特定子类的具体业务步骤&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h3 id="具体需求"><a href="#具体需求" class="headerlink" title="具体需求"></a>具体需求</h3><h4 id="1-豆浆制作"><a href="#1-豆浆制作" class="headerlink" title="1.豆浆制作"></a>1.豆浆制作</h4><p>编写制作豆浆的程序，说明如下：</p>
<ul>
<li>制作豆浆的流程：&#x3D;&#x3D;选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎&#x3D;&#x3D;</li>
<li>通过添加不同的配料，可以制作出不同口味的豆浆</li>
<li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的</li>
</ul>
<p>说明：&#x3D;&#x3D;因为模板方法模式，比较简单，很容易就想到这个方案&#x3D;&#x3D;，因此就直接使用，不再使用传统的方案来引出模板方法模式</p>
<p><strong>思路分析 - 类图</strong></p>
<p><img src="/.io//watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q2i5q2l5YmN6KGM,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抽象类，表示豆浆	SoyaMilk.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">	<span class="comment">// 模板方法：可以做成final，不让子类去覆盖</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">		select();</span><br><span class="line">		addCondiment();</span><br><span class="line">		soak();</span><br><span class="line">		beat();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//选材料</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;第一步：选择新鲜的豆子&quot;</span>); &#125;</span><br><span class="line">	<span class="comment">//添加不同的配料：抽象方法，由子类具体实现</span></span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiment</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//浸泡</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">soak</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;第三步：豆子和配料开始浸泡3H&quot;</span>); &#125;</span><br><span class="line">	<span class="comment">//榨汁</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">beat</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;第四步：豆子和配料放入豆浆机榨汁&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RedBeanSoyaMilk.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">addCondiment</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第二步：加入上好的红豆&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PeanutSoyMilk.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">addCondiment</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第二步：加入上好的花生&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;=======制作红豆豆浆=======&quot;</span>);</span><br><span class="line">		<span class="type">SoyaMilk</span> <span class="variable">redBeanSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadBeanSoyaMilk</span>();</span><br><span class="line">		redBeanSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;=======制作花生豆浆=======&quot;</span>);</span><br><span class="line">		<span class="type">SoyaMilk</span> <span class="variable">peanutSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PeanutSoyaMilk</span>();</span><br><span class="line">		peanutSoyaMilk.make();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="模板方法模式的钩子方法"><a href="#模板方法模式的钩子方法" class="headerlink" title="模板方法模式的钩子方法"></a>模板方法模式的钩子方法</h4><p>在模板方法模式的&#x3D;&#x3D;父类中，可以定义一个方法，它默认不做任何事&#x3D;&#x3D;，子类可以视情况要不要覆盖它，&#x3D;&#x3D;该方法称为“钩子”&#x3D;&#x3D;。还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，&#x3D;&#x3D;请使用钩子方法对前面的模板方法进行改造。&#x3D;&#x3D;代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RedBeanSoyaMilk.java/PeanutSoyaMilk.java同上，略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类，表示豆浆，SoyaMilk</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//模板方法：可以做成final，不让子类去覆盖</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">		select();</span><br><span class="line">		<span class="keyword">if</span>(customerWantCondiment()) &#123;</span><br><span class="line">			addCondiment();</span><br><span class="line">		&#125;	</span><br><span class="line">		soak();</span><br><span class="line">		beat();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.选材料</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;第一步：选择新鲜的豆子&quot;</span>); &#125;</span><br><span class="line">	<span class="comment">//2.添加不同的配料：抽象方法，由子类具体实现</span></span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiment</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//3.浸泡</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">soak</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;第三步：豆子和配料开始浸泡3H&quot;</span>); &#125;</span><br><span class="line">	<span class="comment">//4.榨汁</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">beat</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;第四步：豆子和配料放入豆浆机榨汁&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//钩子方法：决定是否需要添加配料</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">customerWantCondiment</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//默认情况下是要加配料的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PureSoyaMilk.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">addCondiment</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 添加配料的方法 空实现 即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">customerWantCondiment</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;=制作纯豆浆=&quot;</span>);</span><br><span class="line">		<span class="type">SoyaMilk</span> <span class="variable">pureSoyMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PureSoyaMilk</span>();</span><br><span class="line">		pureSoyMilk.make();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相当于就是&#x3D;&#x3D;设置一个标记来决定是否进行执行一个方法&#x3D;&#x3D;，这个&#x3D;&#x3D;标记由子类来实现&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>抽象类中&#x3D;&#x3D;抽象方法只有一个方法签名&#x3D;&#x3D;，但是&#x3D;&#x3D;普通的方法却是有详细的实现细节&#x3D;&#x3D;，如果&#x3D;&#x3D;抽象方法必须被子类实现&#x3D;&#x3D;，但是&#x3D;&#x3D;普通方法可以不被重写&#x3D;&#x3D;</p>
</blockquote>
<h1 id="聊天室顶层设计"><a href="#聊天室顶层设计" class="headerlink" title="聊天室顶层设计"></a>聊天室顶层设计</h1><p><code> Websocket</code>：维护用户得连接通道，可以接收消息，也可以推送消息，为有状态得服务</p>
<p><code> IM服务</code>：负责消息的发送逻辑，处理单聊群聊的消息</p>
<p><code> Logic服务</code>：处理用户的心跳，上下线，联系人，加好友，创群组等逻辑</p>
<p><code> Auth服务</code>：处理用户认证，权限等需求</p>
<p><code>Router</code>：推送消息时，不同用户在不同，<code>Websocket</code>服务上，确保正确推送与可靠推送</p>
<p><strong>交互流程</strong></p>
<blockquote>
<p>1.用户A和<code>WebSocket</code>建立连接。之后通过该连接发送消息接收消息</p>
<p>2.用户A发送了一条信息“在吗”，<code>Websocket</code>服务将消息通过<code>dubbo</code>转发给<code>IM服务</code>，由于<code>IM服务</code>是无状态的，可以通过负载均衡随机发到某一台上</p>
<p>3.<strong>IM服务</strong>将消息持久化然后将消息投递到<code>消息队列MQ</code>，这样就能快速响应前端，并且mq的消费者根据负载慢慢的进行后续的推送，写扩散等操作</p>
<p>4.<code>消费者</code>会判断，根据是否是热点群聊的消息做不同逻辑。如果是热点群聊，只写<code>热点信箱</code>。如果是单聊或者普通群聊，会写扩散到每个<code>群成员信箱</code>。这里假设是小群，会写入B和C的信箱。</p>
<p>5.将消息投递信箱后，需要将消息推送给用户。这里可以根据是否在线，在新的进行<code>WebSocket</code>推送，离线的进行<code>push通知</code>。由于用户的连接在不同的<code>WebSocket</code>上，需要将<code>Router</code>服务推送到B和C所在的不同<code>WebSocket</code>方案有两种，后续进行介绍。</p>
<p>6.推送的时候需要确保消息的可靠性，如何保证一定推送成功？可能要做<code>应用层的ACK</code>，类似tcp的滑动窗口确认。</p>
<p>7.用户在查询自己的会话列表时， 需要有一个<code>聚合层</code>聚合<code>用户信箱</code>，以及<code>热点信箱</code>。再严格排序后返回给用户。所谓之<code>推拉结合</code>。</p>
</blockquote>
<h2 id="集群推送"><a href="#集群推送" class="headerlink" title="集群推送"></a>集群推送</h2><p>http和websocket的底层其实都是依赖tcp建立连接进行通信的。他们的差别就是：</p>
<ol>
<li>http是无状态的。每次请求都会重新握手建立tcp链接再发送消息，并获取响应。因此http请求可以随意的进行负载均衡。第一次请求发给了机器A，第二次请求就发给了机器B。</li>
<li>websocket是有状态的，当他建立tcp连接后，就会一直复用那个连接进行通信。假设一开始连上了机器A，收发信息就一直在机器A。直到连接断开，重连后才会更换连接。</li>
</ol>
<p><img src="/.io//1692879184758-c8e488ec-80a6-408a-96bf-1dfe1c0f4b5c.webp" alt="img"></p>
<pre><code>我们项目用的[netty](https://www.yuque.com/snab/mallchat/skb0r8tesr7yitvf)来实现websocket，和用户的连接就是一个channel。需要给用户推送消息的时候，直接往`channel`里面`write`消息就好了。
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给本地channel发送消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wsBaseResp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(Channel channel, WSBaseResp&lt;?&gt; wsBaseResp)</span> &#123;</span><br><span class="line">    channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(JSONUtil.toJsonStr(wsBaseResp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>在之前的[微信登录技术方案](https://www.yuque.com/snab/mallchat/bsld797perd3xb85)，我们已经描述了如何在用户登录的时候，将uid和channel关联起来缓存在jvm的map里，这样要推送的时候只需要通过uid取出channel进行推送。
</code></pre>
<p><img src="/.io//1692880369836-f4bc0cfd-2855-4435-b846-be1ec7b115ed.webp" alt="image.png"></p>
<p>但是在集群的场景，这样的方案就失效了。</p>
<p><img src="/.io//1692880732535-9ae1c5f8-395b-4afc-80c7-bb6036f980f2.webp" alt="image.png"></p>
<p>你要推送的用户，在别的机器上，你怎么找到对应的机器？根本的原因是因为连接的管理在jvm层面，假设A要发消息给C，我们不知道C在哪一台<code>WebSocket</code>。所以这时候可以借助一个中心化的中间件，比如redis，来存储他们的关系。</p>
<p><strong>redis存储Channel</strong></p>
<p>&#x3D;&#x3D;这个方案不可行&#x3D;&#x3D;：channel和uid的关系存在了本地，导致我们想推送消息给C的时候拿不到channel</p>
<p><img src="/.io//1692887667160-3fcbe508-9da1-451e-8f55-476d2e95ee00.webp" alt="image.png"></p>
<p>有个小伙伴想着既然<code>websocket</code>集群部署了，那就用中心化的redis来存<code>uid</code>和<code>channel</code>映射关系。通过<code>redis.get(uid)</code>拿到字符串，并反序列化成<code>channel</code>，然后发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">( WSBaseResp&lt;?&gt; wsBaseResp,Long uid)</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RedisUtils.get(uid.toString(), Channel.class);</span><br><span class="line">    channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(JSONUtil.toJsonStr(wsBaseResp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为websocket里面的信息包含着状态所以没办法进行&#x3D;&#x3D;序列化和反序列化&#x3D;&#x3D;</p>
<h3 id="精准投递消息"><a href="#精准投递消息" class="headerlink" title="精准投递消息"></a>精准投递消息</h3><p>本地依然要维护uid和channel的关系（&#x3D;&#x3D;这可是根基&#x3D;&#x3D;），redis再维护一个用户的连接状态，比如用户在哪台机器上连接。这样通过router发送消息的时候，就知道用户的消息应该发送到哪台机器上。</p>
<p><img src="/.io//1692890899542-df7b7384-41db-4a7b-8a8a-c0730153e632.webp" alt="image.png"></p>
<blockquote>
<p>大概流程：</p>
<p>1.A发送了一条消息给C，通过channel发送给了10.102.1.1这台Websocket，它通过dubbo将消息转发给了一台IM服务。</p>
<p>2.IM服务将消息持久化后，调用Router，推送消息给C</p>
<p>3.Router差redis的中心化管理，查到C目前连接在10.102.1.2上，并通过tcp连接将C的消息推送给10.102.1.2。Router会和所有WebSocket都维护一条tcp连接。查到具体的ip后，对指定的websocket服务器进行消息推送</p>
<p>4.webSocket服务说到的请求格式为，<code>给uid发送消息xxx</code>，所以它会通过uid在本地的<code>连接管理</code>中，查出用户具体的channel。然后调用channel.write（消息）方法，给用户推送消息</p>
</blockquote>
<p>以上是大致的流程，咱们只管集群的推送，不管推送的可靠性保证等问题，后续再讨论</p>
<p>&#x3D;&#x3D;方案的问题&#x3D;&#x3D;</p>
<p>1.需要频繁的更新redis去维护用户和websocket的连接关系。（&#x3D;&#x3D;我们许需要做用户的上下线，也需要复用这个功能&#x3D;&#x3D;）</p>
<p>2.连接数爆炸：websocket的瓶颈在于连接数，如果连满了，就要水平扩容websocket，这样才能更多人同时在线。如果体量更多的话，甚至需要上千个websocket和上千个router</p>
<p><img src="/.io//1692889700004-bff5fd35-06d2-40f3-9251-f54034a261a6.webp" alt="image.png"></p>
<p>如果单纯的&#x3D;&#x3D;路由就达到了上千&#x3D;&#x3D;，占用了websocket的连接资源，就会导致&#x3D;&#x3D;websocket能连接的用户数就会变少&#x3D;&#x3D;。</p>
<p>这样的问题也会出现再dubbo服务中，dubbo单实例集群达到1000以上，他们是怎么做的呢？</p>
<p>由于传统的service服务都是<strong>无状态的</strong>，我们的连接可以<strong>分组管理</strong>。每台service只需要和少数的下游实例维护tcp连接即可，不需要连接所有。</p>
<p>但是websocket是有状态的，一条router必须连接所有的websocket，它的消息有可能需要路由到任意的一台websocket上。</p>
<p><img src="/.io//1692890136311-be25b8bb-9951-4524-af6b-485c61c30b8e.webp" alt="image.png"></p>
<pre><code>我们可以用分层路由的思想，中间加一层路由，设定路由规则。这样可以**有效减少连接数**，但是会**增加消息的推送链路**，适用于真的很大型的集群场景。

当然还有很多方案，甚至我们可以思考，为啥去保证tcp连接？如果每次发消息都建立tcp连接，那就是三次握手3倍的RTT（==RTT（Round-Trip Time）是计算机网络中的一个关键性能指标，它代表了数据包从发送端发出，到接收端接收到数据并发送确认，然后再返回到发送端所花费的总时间==）。如果我们不在乎这些连接耗时，也可以直接采用**http推送**，或者**临时建立连接**的方式。

![image.png](面试问题.assets/1694837770260-94c263b1-4042-48c7-be8f-4baf95cca63e.webp)
</code></pre>
<p>这种订阅表，路由节点，就也有点想分布式集群的mq，<a target="_blank" rel="noopener" href="https://www.emqx.io/docs/zh/v5.2/deploy/cluster/introduction.html">文档</a></p>
<blockquote>
<p>1.实现复杂，需要指定ip推送，维护tcp连接。如果用dubbo会稍微简单一些。</p>
<p>2.<code>消息发送开销</code>：对于群聊，多个接收者需要发送多份消息的副本，增加了消息发送的开销（这个对比后面的方案就能理解）</p>
<p>3.<code>延迟叠加</code>：哪怕开启了多线程，也依然会有一台机器的单点，需要对所有的群成员进行消息的<strong>扇出</strong>（写扩散）。这里会导致接收者接到的消息延迟叠加。（当然，用线程池异步扇出可以提高速度，但是会回到问题4，总体开销依然是不变的）</p>
<p>4.<code>雪崩问题</code>：如果系统负载提高，比如需要推送的消息量突然变大，导致瓶颈从<code>websocket</code>一直传导到<code>router</code>再传到<code>im服务</code>，整个集群会出现雪崩，需要有一个消息队列来进行削峰填谷。</p>
</blockquote>
<h4 id="router是什么？"><a href="#router是什么？" class="headerlink" title="router是什么？"></a>router是什么？</h4><p>router是为了让你能够精准投递的重要功能。</p>
<p><strong>他可以是一个服务</strong>，这样你的消息只需要发送到任意一个router上，他就能帮你转发到对应的websocket。</p>
<p>他也可以<strong>是一个SDK</strong>，这样减少一次服务与Router服务的交互，简短链路。SDK提供的能力就是根据接收人UID，去redis查到UID所在位置，直接精准请求到Websocket服务。</p>
<h3 id="集群广播消息"><a href="#集群广播消息" class="headerlink" title="集群广播消息"></a>集群广播消息</h3><pre><code>针对于以上精准推送的问题，如果我告诉你，有一种方案，能够**无需维护连接**，消息的发送只需要一个**消息副本**，并且没有**消息扇出**的压力，只需要写一次。你满不满意？它就是集群广播。
</code></pre>
<p><img src="/.io//1692892642246-a075665f-3fa5-4ca3-8051-be63c751b222.webp" alt="image.png"></p>
<pre><code>对于万人群聊，==一般系统的压力就在于消息的**扇出**（**写扩散**）==。如果按照精准投递的话，==我们的消息需要查询redis中心路由，然后将消息投递1w次==。而如果用消息广播的形式，==消息只需要投递一次==。由websocket自己进行广播消息的**拉取**与**过滤。**
</code></pre>
<p><strong>过滤流程</strong></p>
<p><img src="/.io//1692893036052-76bbecc3-741f-43ba-a6f1-c0d15c7cebb8.webp" alt="image.png"></p>
<blockquote>
<p>1.mq的消息消费模式为集群消费，确保每台websocket都能消费到所有需要投递的消息。（&#x3D;&#x3D;这个有点拿捏不准，精准投递中有很多目标的websocket是分散的，所以要采取集群消费，后续如果是一个机器上面都是目标websocket的话就可以采取广播投递了，不知道是不是这个意思&#x3D;&#x3D;）</p>
<p>2.对比推送的uid在不在<code>本地连接管理</code>的列表，如果不在，直接丢弃消息，也叫过滤消息</p>
<p>3.如果在本地连接管理，根据uid取出channel，就可以进行消息推送了</p>
</blockquote>
<p><strong>优化1：消息副本优化</strong></p>
<p>集群广播和精准投递比起来，消息副本少了很多。但是如果用刚刚的图展示，反而看不出来效果。</p>
<p><img src="/.io//1692893821809-f1f05bb6-a1e7-44e3-b2c8-56e3518f7a67.webp" alt="image.png"></p>
<p>这样比较起来，反而是集群广播的消息副本整体多了。假设B发送消息给<strong>A</strong>和<strong>C</strong>。</p>
<p>精准投递总共传输了2<em>3&#x3D;6份消息，集群广播传输了2</em>4&#x3D;8份消息。</p>
<p>既然是集群广播，我们就应该利用好广播的特性。</p>
<p>一份消息由uid和消息体组成，uid就是对应的<strong>紫色方块</strong>，消息体就是对应的<strong>黑色信封</strong>，一般消息体远大于uid。</p>
<p><img src="/.io//1692894214945-2b25da5e-e51f-499f-89eb-0f0088efb6e6.webp" alt="image.png"></p>
<p>在万人群聊下，其实大家收到的消息都一样的，可以共用一个消息副本，我们在投递消息进mq的时候，可以设置投递的消息为<code>list&lt;long&gt;</code>的<code>uids</code>。而不是拆成多次的消息投递.</p>
<p>改造后的效果如下：</p>
<p><img src="/.io//1692894313076-bf5de3ae-6a1d-484a-bc23-4f6f86584618.webp" alt="image.png"></p>
<p>这差别可就大了，假设是万人群聊。</p>
<p>精准投递总共传输了<strong>1w*3&#x3D;3w</strong>份消息， <strong>1w*3&#x3D;3w</strong>个uid，</p>
<p>集群广播传输了<strong>1w+3</strong>份消息，<strong>2w+1w*2&#x3D;4w</strong>个uid。</p>
<p>&#x3D;&#x3D;因为终端投递是省不了的，但是可见消息副本数大大下降。&#x3D;&#x3D;大家可能会觉得有些赖皮，1w个连接涉及到的websocket其实会有更多个。消息大小远大于uid，我们以消息为准</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">精准投递：u*3份消息，u=群聊在线人数，3=消息传输的链路，固定值</span><br><span class="line">集群广播：u+n份消息，u=群聊在线人数，n=websocket的集群数，不固定，但是极小。</span><br></pre></td></tr></table></figure>

<p>可见该优化在大群聊下的效果有多强，当然其实集群广播方案也有缺点，就是在im中，<strong>小群聊甚至单聊的占比</strong>很大，&#x3D;&#x3D;在u很小，且n很大的情况下，集群广播就失去了他的优势。&#x3D;&#x3D;</p>
<p><strong>优化2：消息过滤优化</strong></p>
<pre><code>根据刚刚的过滤流程，我们可知道消息内的uid过滤，都是在本地消费者逻辑去过滤的，不存在就直接丢弃消息。这时候大量与本`websocket`无关的消息都被拉取过来了，中间的网络io都浪费了。这还真没啥办法解决。但是我们可以在海绵里挤水呀，想想还有啥能优化的。
</code></pre>
<blockquote>
<p>大胆假设，小心求证</p>
</blockquote>
<pre><code>集群广播==最大的毛病==就在于，很多==不属于我们websocket的消息推送==，也会被我们读取，==然后在本地过滤扔掉==。这里==浪费了**网络IO**==，浪费了==本地**反序列化的cpu**==。
</code></pre>
<p>这两点能不能改善呢？？？</p>
<p>&#x3D;&#x3D;解决1&#x3D;&#x3D;：</p>
<blockquote>
<p>我们可以通过设置header的方式。将推送的uids存在header里。这样我们拉取消息到消费端的时候。就可以在序列化前，先在<strong>mq的过滤器</strong>里去过滤消息，<strong>节省不必要的反序列化</strong>。</p>
<p>这里需要注意一点，header有长度限制。我们需要注意大群聊uid过多分批发送。或者群聊压根不过滤，就考虑单聊场景。&#x3D;&#x3D;有效&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<h3 id="方案概述"><a href="#方案概述" class="headerlink" title="方案概述"></a>方案概述</h3><ol>
<li><strong>&#x3D;&#x3D;利用Header存储目标UIDs&#x3D;&#x3D;</strong>: 在将消息推送到消息队列之前，将该消息预期的目标用户ID（uids）放在消息的头部（header）中。这样做的目的是在消息实际被消费者处理之前，提供一种快速筛选机制。</li>
<li><strong>MQ过滤器进行预处理</strong>: 消费端在完全接收和反序列化消息内容之前，MQ服务提供了过滤器功能。这个过滤器可以根据消息头中的信息（在这里是目标UIDs）预先判断该消息是否应该被当前消费者处理。如果不符合条件（即消费者所代表的用户不在目标UID列表中），则直接丢弃或跳过此消息，无需进一步处理。</li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>**&#x3D;&#x3D;Header长度限制&#x3D;&#x3D;**：大多数消息队列系统对消息头的大小有限制，这意味着如果目标用户非常多（如大型群聊），可能无法将所有UIDs放入单一消息的头部。因此，需要考虑分批发送策略，或将群聊消息设计为不经过此过滤过程直接广播。</li>
<li><strong>分批发送与群聊处理</strong>：对于群聊消息，如果因头部限制无法直接利用过滤器，可以考虑群聊消息不采用这种方式过滤，而是在消费者端实现更智能的处理逻辑，或者采用其他优化手段，如使用特殊标记来标识群聊消息，然后在消费者端统一处理。</li>
<li><strong>设计考量</strong>：在实施此方案时，需要权衡消息的处理速度与系统复杂度之间的关系，确保方案的可行性和维护性。</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;解决2：&#x3D;&#x3D;</p>
<pre><code>上面的方案是在消费端才过滤，只节省了反序列化。我还想贪心点，在broker端过滤消息，直接节省IO的传输成本。

调研了两种broker端过滤方案，tag的方式首先不支持我们的需求，没法存到用户纬度那么大。我们可以用sql29的方式写表达式匹配。

把uids写到消息的header里，sql29表达式可以去匹配。过滤出包含我们有的uid的消息。

但是sql29并不支持动态过滤。而我们websocket的连接用户是会一直变化的。每一次请求都需要做到不一样。

所以解决方案2的方案相当于破产了，但是rocketmq最大的**优势**，就是纯java编写。我们可以去**魔改源码**改broker的逻辑呀，专门改一个更适合im场景的mq过滤交互框架，也是一个不错的选择。==无效==



虽然方案不行，但是我依然带着大家去大胆假设，小心求证。目的是带着大家了解我们使用的工具，以及它的能力。**这是一次对rocketmq高级用法的探索**，和我们业务的完美结合，希望大家用心去思考，去感受。
</code></pre>
<p><strong>这个方案有啥问题？</strong></p>
<p>其实问题也比较明显。每个websocket都需要接收<strong>全站所有消息</strong>的广播消息，然后内部进行过滤。如果全站的消息都是单聊消息，结果每个websocket都拉取消息，并且内部过滤，是带宽的浪费，以及cpu的浪费。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>根据前面的计算公式对比，我们很容易的得出一个简单的结论。</p>
<blockquote>
<p>单聊消息多的，用精准投递。群聊消息多的，用广播消息。</p>
</blockquote>
<p>对于抹茶，我们是有个全员群聊，很多个小群聊，和很多的单聊。发言频率最多的场景是全员群。所以抹茶最应该使用集群广播推送的方案。</p>
<p>接下来再讨论一个极端场景的解决方案。</p>
<h4 id="百万直播间推送方案"><a href="#百万直播间推送方案" class="headerlink" title="百万直播间推送方案"></a>百万直播间推送方案</h4><p>假设在抖音直播的场景下，&#x3D;&#x3D;一个热门的直播间<strong>100w</strong>人同时在线&#x3D;&#x3D;，大量的礼物，互动消息充斥在直播间，如何通知到每个人。保证消息的<strong>即时性</strong>，<strong>可靠性</strong>。<br>首先这明显更倾向于大群聊的一种场景，如果用精准投递，&#x3D;&#x3D;那么消息的扩散系数就是100w级&#x3D;&#x3D;。如果采用的是集群推送，假设100w的用户需要&#x3D;&#x3D;500台websocket进行连接，那么扩散系数只是500的级别&#x3D;&#x3D;。</p>
<p>但是这个假设是整个平台只有这个直播间，如果平台有更多的直播间。&#x3D;&#x3D;websocket会更多，mq的扩散系数也会更大&#x3D;&#x3D;。</p>
<p><img src="/.io//1694838682316-6244f4d6-f8b9-423e-8c3f-e16bf72f4141.webp" alt="image.png"></p>
<p>每个方案又都优缺点，而应对极端场景，通常都是方案的组合，扬长避短。很类似于我们后面会提到的推拉结合。</p>
<p>这个场景的方案，我们可以设置一个热门阈值，比如1w。超过1w的直播间，我们会进行直播间升级，升级成热门直播间。热门直播间的websocket单独管理。把直播间用户的websocket连接都统一路由到固定的几百台websocket上。由于目标用户都集中了，也就不需要精准投递了，可以采用广播投递消息到这指定500台机器上。再对应的推送给直播间的观众。</p>
<p><strong>这里其实是精准投递和集群推送的一个结合</strong>（你会发现，很多方案都是有优劣的，最后都是结合起来使用扬长避短）</p>
<p>这个方案的核心，就是要能将直播间所有用户通过<strong>网关路由</strong>到相同的500台websocket上，有了这个基础，才能用广播消息，那500台websocket都监听同一个topic的<strong>广播mq消息</strong>。能省下很大的带宽开销。而消息的发送端，需要知道消息究竟是发送到热门直播间的topic进行<strong>集群广播</strong>还是普通直播间的<strong>精准推送</strong>。还是得依赖<strong>router</strong>服务进行路由推送。</p>
<p>再讨论下面几个功能的细节：</p>
<p><code>热门直播间升级</code>：一开始的普通直播间，&#x3D;&#x3D;用户都分散在不同的websocket机器上&#x3D;&#x3D;。&#x3D;&#x3D;等到直播间人数突破阈值1w&#x3D;&#x3D;。&#x3D;&#x3D;就需要开始直播间的<strong>热点升级</strong>&#x3D;&#x3D;。这时候服务器检测到直播间需要升级，**&#x3D;&#x3D;动态扩缩容&#x3D;&#x3D;**，&#x3D;&#x3D;启动一系列配套措施（k8s现在已经使用的比较多了）&#x3D;&#x3D;。一系列措施准备好后，&#x3D;&#x3D;相应的配置推送到网关路由机器上&#x3D;&#x3D;。&#x3D;&#x3D;指定以后该直播间的连接路由到我们新启动的50台websocket上&#x3D;&#x3D;。&#x3D;&#x3D;然后对当前在线的所有用户发送断连替换指令&#x3D;&#x3D;。所有在线用户都断开连接，&#x3D;&#x3D;重连的时候会被网关路由到新的websocket上&#x3D;&#x3D;。优化：&#x3D;&#x3D;对于经常突破1w人的直播间，可以打个标。以后该直播间上线，默认就是热点，省略升级过程&#x3D;&#x3D;。</p>
<p><code>消息合并</code>：直播间的点赞操作，一般发生在主播求赞的时候，&#x3D;&#x3D;大量人在同一时间段点赞&#x3D;&#x3D;。并且单人在同一时间也快速点赞。&#x3D;&#x3D;可以在客户端对每个人的多次点赞首先进行合并一次（用户a点赞20）&#x3D;&#x3D;。请求到后端后，由于路由已经做好，在每个点赞服务器，&#x3D;&#x3D;可以对多人的点赞再合并一次（用户a+b总点赞40）&#x3D;&#x3D;，进行入库。&#x3D;&#x3D;给前端推送的时候，也可以合并推送，不需要每条点赞都推送&#x3D;&#x3D;。每隔1s推送一次直播间点赞总量达到（100w）。</p>
<p><code>优先级隔离</code>：在100w直播间里，&#x3D;&#x3D;推送的消息会有很多。会导致部分消息到达产生延迟&#x3D;&#x3D;。这就类似push系统，&#x3D;&#x3D;消息应该<strong>区分优先级</strong>&#x3D;&#x3D;，不要被互相影响。&#x3D;&#x3D;大礼物，和主播发言消息，这些应该独立在一个广播topic里&#x3D;&#x3D;，其他的不重要的消息，&#x3D;&#x3D;可以设置另一个topic，区分优先级&#x3D;&#x3D;，不要影响重要消息。</p>
<blockquote>
<p>连这个极端场景都能搞定，其中的思想只要能理解透，还有啥im能够难倒你？</p>
</blockquote>
<h2 id="消息时序性"><a href="#消息时序性" class="headerlink" title="消息时序性"></a>消息时序性</h2><p>消息时序性，主要解决的就是消息展示的顺序问题。它为啥那么难？</p>
<p>如果用户a给用户b同时发了三条消息 aa bb cc。而服务端接收到的消息是并发的，可能入库就是aa cc bb。</p>
<p>就产生了发送方顺序和接收方顺序不一致的情况。</p>
<p><img src="/.io//1694797825724-8a10c660-6e1f-4cb9-9b35-17e7227b49bb.webp" alt="image.png"></p>
<h3 id="客户端排序"><a href="#客户端排序" class="headerlink" title="客户端排序"></a>客户端排序</h3><p>这时候可以让a发送的每条消息带上时间戳，服务存储a的消息时间戳。b的展示根据时间戳排序。</p>
<p><img src="/.io//1694797928410-693cd25d-a7ed-45da-98b0-8a5ea90422fc.webp" alt="image.png"></p>
<p>但是如果在多端发送的情况下，a有电脑端，手机端，&#x3D;&#x3D;<strong>每个端的时间</strong>可能是不一样的&#x3D;&#x3D;，就会出现发送的乱序问题</p>
<p><img src="/.io//1694798178170-73f6143c-a83d-4d39-980f-04e05165bfa0.png" alt="img"></p>
<p>回头想想，&#x3D;&#x3D;只是为了解决用户快速发两三条消息时间内的<strong>局部排序</strong>而已&#x3D;&#x3D;。可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/269/2282">腾讯sdk</a>的实现。</p>
<p>&#x3D;&#x3D;给消息设置一个本地的自增id，发送消息的时候带上&#x3D;&#x3D;。&#x3D;&#x3D;排序整体以服务器的时间为准&#x3D;&#x3D;，&#x3D;&#x3D;相同秒内&#x3D;&#x3D;的排序&#x3D;&#x3D;以自增id为准&#x3D;&#x3D;。</p>
<p><img src="/.io//1694798650596-34e5c323-90b4-4b4c-881a-1ce2b4da2a60.webp" alt="image.png"></p>
<p>这样赌的就是，&#x3D;&#x3D;你发的消息再快，哪怕存储顺序变了，但是也都在1s内，对于b来说，1s内的消息，按照自增id额外排序就好了&#x3D;&#x3D;。</p>
<p>这样发送者&#x3D;&#x3D;只需要保证指定时间内的消息自增就好。如果哪天seq丢失，或者在其他端发消息seq不一致，都没关系&#x3D;&#x3D;。</p>
<p>但是在群聊的场景下，每个群成员的客户端时间也是不一样的，没法作为排序的统一基准时间。只能采用服务端时间。并且seq也是不同的，相同秒内也没法排序，不适用该方案</p>
<p><img src="/.io//1694798952659-63fd7155-8076-4dd4-bfc4-37164b47a6df.webp" alt="image.png"></p>
<h3 id="服务端排序"><a href="#服务端排序" class="headerlink" title="服务端排序"></a>服务端排序</h3><p>对于群聊的场景，我们需要&#x3D;&#x3D;采用服务端排序&#x3D;&#x3D;。服务端排序其实本应该很简单。</p>
<p>对于单表来说，&#x3D;&#x3D;我们可以采用<strong>主键id</strong>来排序&#x3D;&#x3D;，也可以通过&#x3D;&#x3D;<strong>消息的时间戳</strong>来排序&#x3D;&#x3D;。&#x3D;&#x3D;id肯定是严格自增了&#x3D;&#x3D;，&#x3D;&#x3D;时间戳要考虑**精度问题&#x3D;&#x3D;**，一般设置的精度是毫秒，也基本足够进行消息的排序了。&#x3D;&#x3D;因为毫秒内的消息，本身就没有上下文的关系&#x3D;&#x3D;，对顺序要求不高。</p>
<p><img src="/.io//1694799542835-de99d806-780e-4fbd-a832-99998c728dbe.webp" alt="image.png"></p>
<pre><code>小绿小王小马，他们的消息还在发送中，互相都是根据上面已发的消息做的决策，所以他们三的顺序，并不重要，以服务端的时间为准即可。

除了消息的**顺序性**外，还有一个很重要的点，==就是消息的**唯一性**==。在[游标翻页](https://www.yuque.com/snab/mallchat/kf0dtv51houe86nh)的场景下。==翻页的游标字段，需要同时保证顺序性与唯一性的作用。==如果==单纯用时间戳，毫秒内的消息，就没办法区分与排序==，得额外再拼接其他唯一字段一同排序，==不如就直接用唯一且有序的id作为游标==。
</code></pre>
<p><img src="/.io//1685189899438-884c817d-0ee5-4b7d-a540-6be3bb135975.webp" alt="img"></p>
<p>因此消息的时序性，我们通常都是用一个唯一id来保证。<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/269/2738">微信sdk</a>也是用一个id来进行翻页。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>通常没有绝对的客户端排序，单聊场景可以用客户端seq。保证单位时间内多条消息的顺序性。</p>
<p>消息不仅要保证时序性，也要保证唯一性。通常用消息id一个字段满足两个需求。、</p>
<h2 id="消息ID"><a href="#消息ID" class="headerlink" title="消息ID"></a>消息ID</h2><p>消息id被我们给予厚望，不仅要<strong>唯一</strong>，还要<strong>有序</strong>（递增）</p>
<p>保证唯一很简单，随便一个分布式id都能实现。重点是消息的有序，如何去保证。</p>
<h3 id="全局递增"><a href="#全局递增" class="headerlink" title="全局递增"></a>全局递增</h3><pre><code>消息在整个IM系统都是唯一且递增的。一般对于单表来说**主键**就自然保证了递增。但是如果消息量大了，省不了分库分表，分库分表后的消息递增，通常采用分布式id。但是分布式id通常保证的是**趋势递增**，而不是**单调递增**。
</code></pre>
<p><img src="/.io//1691922802574-2086caa2-e1b9-48df-92c2-438451e0ad3e.webp" alt="img"></p>
<p><img src="/.io//1691922818312-48ecbc4e-f52f-4598-92e4-def6f6c0e099.webp" alt="img"></p>
<pre><code>所以==雪花id不适用于IM这种严格时序性的系统==（高并发环境下，特别是在同一毫秒内，不同的线程或机器可能会生成ID，这时序列号的分配可能会导致ID在局部上不是严格递增的。==例如，机器A在某一毫秒内生成了一个序列号为10的ID，紧接着机器B在同一毫秒内生成了一个1的ID，那么从全局看ID并非严格按照事件顺序递增==）。对分布式id感兴趣可看《架构之路》的[分布式id方案](https://www.yuque.com/snab/architecture/crefklebmccw1vpr)文章

事实上，**严格的单调递增**，意味着**严重的单点竞争**问题。对于一个都需要分库分表的系统，是很难实现这样的方案的
</code></pre>
<blockquote>
<h3 id="Leaf-Segment（数据库方案）"><a href="#Leaf-Segment（数据库方案）" class="headerlink" title="Leaf-Segment（数据库方案）"></a>Leaf-Segment（数据库方案）</h3><pre><code>美团Leaf是美团点评开源的分布式ID生成系统，旨在解决在高并发环境下全局唯一ID生成的需求。Leaf提供了两种主要的ID生成策略：Leaf-Segment和Leaf-Snowflake，都是对传统ID生成方法的改进和优化。
</code></pre>
<ol>
<li><strong>基本原理</strong>：Leaf-Segment方案基于数据库实现，使用&#x3D;&#x3D;一张专门的Ticket表&#x3D;&#x3D;来持久化ID的分配信息。每当需要新的ID时，服务不是直接生成单个ID，&#x3D;&#x3D;而是从数据库中批量获取一段ID（Segment）&#x3D;&#x3D;，&#x3D;&#x3D;并将这一段ID的起始值和结束值保存在内存中&#x3D;&#x3D;。这样，&#x3D;&#x3D;后续的ID请求就可以直接从内存中快速分配&#x3D;&#x3D;，极大地减少了数据库的访问压力。</li>
<li><strong>优化点</strong>：为了解决每次生成ID都要访问数据库带来的性能瓶颈，Leaf采用了预取ID段的方式，&#x3D;&#x3D;即一次性从数据库中取出一批ID并缓存在内存中&#x3D;&#x3D;，直到&#x3D;&#x3D;这批ID即将用尽时&#x3D;&#x3D;再从数据库获取新的ID段。此外，还通过乐观锁机制确保了在高并发场景下的数据一致性。</li>
</ol>
<h3 id="Leaf-Snowflake（雪花算法改进版）"><a href="#Leaf-Snowflake（雪花算法改进版）" class="headerlink" title="Leaf-Snowflake（雪花算法改进版）"></a>Leaf-Snowflake（雪花算法改进版）</h3><ol>
<li><strong>基本原理</strong>：Leaf-Snowflake是基于Twitter的Snowflake算法的改进版本，&#x3D;&#x3D;该算法使用一个64位的ID，包含时间戳、数据中心ID、机器ID和序列号几个部分，能够保证全局唯一性。&#x3D;&#x3D;美团在此基础上进行了优化，例如，改进了worker ID的分配方式，使其更加灵活和可扩展。</li>
<li><strong>改进点</strong>：<ul>
<li><strong>Worker ID管理</strong>：&#x3D;&#x3D;Leaf改进了worker ID的分配方式，原本Snowflake算法中的worker ID是固定的，而Leaf可以通过Zookeeper或Nacos这样的分布式协调服务动态分配和管理worker ID&#x3D;&#x3D;，使得系统在扩展时无需重启或重新配置。</li>
<li><strong>时钟回拨处理</strong>：针对时钟回拨问题，Leaf设计了相应的处理逻辑，确保在服务器时钟异常情况下也能正确生成ID，避免因时钟回拨导致的ID重复或错乱。</li>
<li><strong>性能与可用性</strong>：通过优化算法细节和分布式组件的使用，提升了ID生成的性能和系统的整体可用性。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="会话级别递增"><a href="#会话级别递增" class="headerlink" title="会话级别递增"></a>会话级别递增</h3><pre><code>上面也说到，全局的单调递增，意味着严重的单点竞争。话说回来，我们为啥需要递增呢？不就是为了消息的顺序性展示吗？只需要保证单个群组内的消息id是有序的且唯一的，就足够了。QQ就是这样的架构。

那么如何保证会话级别的递增呢？一个简单的做法分库分表**以会话id分表**（==水平分表==）。这样相同的==会话必定在同一张表，又重新用回了**主键自增====**==。

==一般分表就不用主键自增了，都是用分布式id==。因为这种方案很难支持之后的扩容，比如4扩8。

用==**分布式id**保证会话级别的单调递增==（这里我觉得是因为它通过==以会话id分表所以是在单个节点==上，==分布式id如果在单个节点==上就可以保证是==单调递增==）

==**单调递增**，同时意味着**单点问题。**==两者是不可两全的。分布式id之所以没有单点问题，所以大多都是趋势递增。这里面涉及的可用性，以及单调递增这种一致性的取舍。非常有意思。最终实现的效果，类似mysql的主从，单点的mysql用于自增id，以及主从保证高可用的切换。实现参考：[微信序列号生成器架构设计](https://cloud.tencent.com/developer/article/1004444)
</code></pre>
<blockquote>
<p>主从节点高级玩法</p>
<p>1 2 3 4 （第一行代表不同机器的主节点）</p>
<p>2 1 4 3 （第二行代表不同机器的从节点）</p>
<p>这个相当于做了两步负载均衡，第一个是对其中一个进行了读写分离，另外一个相当于主从复制，不在同一个节点上进行分流</p>
</blockquote>
<h2 id="收信箱递增"><a href="#收信箱递增" class="headerlink" title="收信箱递增"></a>收信箱递增</h2><pre><code>==**会话级别的递增**，更多的适用于**读扩散**的场景==。所有人拉取消息列表的时候，都去会话的消息表拉取。
</code></pre>
<p><img src="/.io//1694805584259-c669c4a3-5828-4ec4-a54a-72ffb66a95d4.webp" alt="image.png"></p>
<pre><code>==**收信箱的递增**，适用于**写扩散**的场景。==所有人都有自己的一个收信箱，维护自己的时间线即可。	
</code></pre>
<p><img src="/.io//1694805861395-ce36e294-2c1d-4508-a798-584fa8f4a9dc.webp" alt="image.png"></p>
<pre><code>收信箱的时间线的单调递增和uid相关。实现的方式和上面都一样，一个是以会话为key，一个是以uid为key。

实现参考：[微信序列号生成器架构设计](https://cloud.tencent.com/developer/article/1004444)

==微信就是典型的写扩散场景==，所以他的群聊最多只能500人。
</code></pre>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>我们讨论了消息id重要的使命，用来确保&#x3D;&#x3D;唯一和有序&#x3D;&#x3D;。</p>
<p>对于有序顺带提了单调递增和趋势递增。现实中分布式id大多数都是趋势递增的，这样比较高可用。</p>
<p>而有序，又讨论是三种有序的情况，为啥全局单调递增不好实现（因为单点竞争）。引出了单调递增id生成器的方案，和可用性保证。</p>
<p>如果你能了解市面上大多<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/architecture/crefklebmccw1vpr">分布式id方案</a>的优缺点，同时了解IM的业务诉求，&#x3D;&#x3D;必须单调递增的限制。又能够引出业界的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1004444">解决方案</a>&#x3D;&#x3D;。基本上能折服非该行业的面试官了，同时体现出你的专业性。</p>
<p>说了这么多，&#x3D;&#x3D;虽然抹茶用的就是单表id自增&#x3D;&#x3D;。但是哪怕问到亿级数据的方案，我们也不带怕的!</p>
<h2 id="消息可靠ACK"><a href="#消息可靠ACK" class="headerlink" title="消息可靠ACK"></a>消息可靠ACK</h2><p>消息时序性和可靠性室IM产品最重要的功能。如果你发出去的消息，都不能确保对方不能收到。那谁还会还会是使用这个软件呢？</p>
<p>IM的消息发送一般分为两个场景。</p>
<blockquote>
<ul>
<li>发送发下哦那个消息给服务端，服务端入库成功返回ack</li>
<li>服务端发送消息给接收方，接收方返回ack</li>
</ul>
</blockquote>
<h3 id="发送可靠"><a href="#发送可靠" class="headerlink" title="发送可靠"></a>发送可靠</h3><pre><code>如何确保发送的消息可靠，基本都是靠ack来保证。有人会好奇，==能不能借助tcp的ack呢？答案是不能的==，==业务层的ack不能靠网络层来保证==。举一个简单的例子你就知道了，==假设我发送消息，到达服务器了，这时候tcp的ack已经响应了，代表服务器接收到了请求==。==但是服务器在入库的时候失败了。==业务层可能有很多的失败情况，业务校验，db入库，代码执行。。。等等。==只有业务层返回的ack，才是业务可靠的保证。==
</code></pre>
<p><img src="/.io//1694841895526-7e9134fc-5820-46f4-9c62-43020b324f1d.webp" alt="image.png"></p>
<ul>
<li>如果是&#x3D;&#x3D;从<strong>websocket</strong>发出的消息，需要websocket再主动返回一个ack的消息&#x3D;&#x3D;。websocket底层是tcp协议，&#x3D;&#x3D;他的特点就是<strong>发消息</strong>和<strong>接收消息</strong>是没关系的。需要通过一个唯一标识，标识推出去的消息是用来响应上一个接收的消息的。&#x3D;&#x3D;同时&#x3D;&#x3D;发消息的客户端，也需要发送完进行阻塞等待（可超时），等待响应的到来&#x3D;&#x3D;。类似dubbo的底层交互原理。</li>
</ul>
<p><img src="/.io//1694842964385-ae96b9d4-090f-45e1-a6b5-86aff19eec6f.webp" alt="image.png"></p>
<ul>
<li><p>如果是http协议，他的协议能够在tcp之上，通过收发的报文进行请求和响应的关联。</p>
</li>
<li><p>我们的抹茶，&#x3D;&#x3D;就是用的http来发送消息，通过返回的标识，判断是否发送成功即可&#x3D;&#x3D;。</p>
<p>如果发送方发送失败（ack明确失败，ack超时）如果是明确失败，可能是业务校验问题，提示用户即可。如果是超时，底层帮助自动重发。确保发送可靠。</p>
</li>
</ul>
<h3 id="推送可靠"><a href="#推送可靠" class="headerlink" title="推送可靠"></a>推送可靠</h3><p>推送可靠一般体现在服务端消息入库成功后。推送给对应的消息接收方。需要保证消息能够到达消息的接收方。</p>
<p>为了保证严格的可靠性，&#x3D;&#x3D;这些推送给每个人的ack都是需要入库的&#x3D;&#x3D;，&#x3D;&#x3D;可以写到每个人的消息表持久化&#x3D;&#x3D;。接收到ack后，修改消息状态。</p>
<p><img src="/.io//1694845013491-2538e540-76c3-41ed-bcb4-2a4ef044de34.webp" alt="image.png"></p>
<p><code>定时重试</code>：可靠性，基本离不开一个不断check的重试节点。这个重试可能是后端，也可能是前端。如果信箱没有收到ack。说明消息没有到达接收端，需要进行重新推送。&#x3D;&#x3D;可靠的前提&#x3D;&#x3D;，&#x3D;&#x3D;在于信箱是<strong>持久化</strong>的。定时任务又支持<strong>不断重试</strong>的&#x3D;&#x3D;。</p>
<p><img src="/.io//1694845092656-b6391f16-9e45-4946-b9f2-840976e23e81.webp" alt="image.png"></p>
<p>但这有个问题，如果用户一直不在线，难道你的定时任务就一直拉取全部信箱消息，在逻辑判断是否在线，再推送吗？这每次拉取的消耗可不小。</p>
<p><code>在线推送</code>：推送服务增加一个判断，如果是在线消息，才会进行推送，并且记录消息在内存中，定时任务也只会拉取内存ack队列的消息，进行推送重试。</p>
<p>  <img src="/.io//1694845759730-03316ff3-f98b-41b3-ba50-9bc877ee7f7c.webp" alt="image.png"></p>
<pre><code>如果接收到ack。内存队列会移除对应的待ack消息。并且对持久化的信箱进行ack标识。如果内存待ack队列过多，可以采用lru的方式，排除最早入队的消息。
</code></pre>
<p><img src="/.io//1694846361596-d143d38d-7f00-4a1b-8ef4-5ed783b7e733.webp" alt="image.png"></p>
<p>当然内存队列是肯定不可靠的，但他只是为了<strong>加速</strong>我们的可靠性推送的效率，最终还有我们的持久化收信箱做兜底。<strong>最后的保障</strong>，也就是我们的离线推送。</p>
<p><code>离线推送</code>：对于不在线的用户，只能确保他在下一次连接上的时候，保证消息的可靠推送。在此之前，还有友情通过push的方式提示他消息到达。让他打开软件。</p>
<p><img src="/.io//1694847104347-948f1f30-fc74-477d-a625-439d3c0e4b9c.webp" alt="cf02610b49dbf3a8c6b737e36a4ff1c.jpg"></p>
<p><img src="/.io//1694847189240-0306c1c5-8842-4dd5-b298-60900ffb24ab.webp" alt="image.png"></p>
<pre><code>所有的复杂点都在用户上线的时间点。==发现用户上线后，要立马查出他所有未ack的消息，一股脑全部推送给他。并且copy一份到内存ack队列，确保可靠性==。后面的流程就差不多了，定时任务继续重试，保证最终的一致性。
</code></pre>
<p><strong>一次性推送所有消息，也可能会有瓶颈，对于一个很久没上线的用户来说。</strong></p>
<p>可以做到分批推送，感兴趣看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LSE-8iOwrySuHdHlDK0pXA">b站文章</a>。</p>
<p><img src="/.io//1694849424519-aa3d5ee7-41c5-4943-ae19-c3b98f5e0d35.webp" alt="image.png"></p>
<p>这样已经是一个完整的消息可靠性方案了。做到了持久化，重试，就能达到最终一致性。<strong>但是</strong>。。。</p>
<p>在我们的&#x3D;&#x3D;万人群聊场景下，一条消息，就意味着需要写入1w人的收信箱&#x3D;&#x3D;。你知道这种<strong>写扩散</strong>的系数有多爆炸吗？？？再&#x3D;&#x3D;换个角度来说，每条消息都存一份消息id到用户的个人信箱。对应的存储也增长了好多倍。微信为了降低写扩散的影响，都把群限制了只能500个人。&#x3D;&#x3D;（不是说解决不了，只是代价挺大的）。</p>
<p>以上我们讨论的都是<strong>消息推送的可靠性</strong>，遇到的热点问题，实际上还有一些优化方案，&#x3D;&#x3D;后面的<strong>推拉结合</strong>，和<strong>热点群聊</strong>&#x3D;&#x3D;，都会再讨论这个问题，综合一个更好的方案。</p>
<p>上面的讨论，我们了解了消息可靠的基本方案。虽然抹茶没做到消息的可靠保证，但是面试官问的的时候，你也能答得出来了。</p>
<p>抹茶为啥不做消息可靠的保证呢？一方面是复杂。另一方面抹茶是一个web项目，压根就不存储消息，消息到没到问题不是很大，哪怕消息到了，你刷新一下，消息也又没了。</p>
<h2 id="消息重复避免"><a href="#消息重复避免" class="headerlink" title="消息重复避免"></a>消息重复避免</h2><pre><code>分布式下的一致性方案，我们都老生常谈了。几个关键点，**最终一致性** ，**持久化**，**重试**，**幂等**。在分布式场景下一般为了达到最终一致性，失败了我们也需要进行重试，重试就有幂等问题，如何标明两次重试是一次操作，不能因为重试插入了两条数据。
</code></pre>
<p>&#x3D;&#x3D;保证幂等关键的点就是幂等标识&#x3D;&#x3D;。</p>
<h3 id="发送消息幂等"><a href="#发送消息幂等" class="headerlink" title="发送消息幂等"></a>发送消息幂等</h3><pre><code>==消息发送的时候==，如果遇到网络波动，==底层会自动帮忙重试==。如何==唯一的标识这条消息==？靠的是==发送端生成一个唯一的标识==，如果重试的时候，==相同的消息带的是相同的标识==。后端服务就能够检测出来，保证幂等。

类似kafka发消息到broker的重试，也会在发送时生成个幂等标识。[腾讯sdk的文档](https://cloud.tencent.com/document/product/269/2282)，也能看到发送消息的一个随机md5，保证幂等标识。
</code></pre>
<p><img src="/.io//1694851387465-57d7e1f7-a968-4b05-98b1-146e83c68a5f.webp" alt="image.png"></p>
<pre><code>1s内的去重保证，是比较好的做法。否则需要去重判断的范围太大了，涉及的历史数据也太多了。这样的话，发送端的自动重试也要限制一下超过1s还没成功，就放弃重试了。
</code></pre>
<h3 id="接收消息幂等"><a href="#接收消息幂等" class="headerlink" title="接收消息幂等"></a>接收消息幂等</h3><pre><code>服务端对接收方的消息推送，也是有可靠性保证的。==如果没有及时收到ack，定时任务就会进行消息推送重试==。同样需要考虑到幂等问题。
</code></pre>
<p>假设&#x3D;&#x3D;服务端对接收方推送了相同的消息两次&#x3D;&#x3D;。接收方会怎么展示呢？一般&#x3D;&#x3D;能够想到对消息做幂等判断&#x3D;&#x3D;，如果&#x3D;&#x3D;是客户方已经展示的消息&#x3D;&#x3D;，就跳过。那么这个唯一性怎么判断呢？</p>
<p>消息的唯一性，基本&#x3D;&#x3D;就靠消息id来判断了&#x3D;&#x3D;。上面也讨论了消息id的唯一性问题。一&#x3D;&#x3D;般全局消息唯一的话。直接用唯一消息就好了&#x3D;&#x3D;。</p>
<p>如果是会话级别的消息id唯一，那判断的时候就需要判断<code>==会话id+消息id==</code>唯一。</p>
<h2 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h2><p>我们刚刚讨论的消息可靠性，讨论的都是后端主动推送给前端。实际上新消息的获取，方案可以有很多。</p>
<p>是推还是拉，用哪些方案，之前的<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/mallchat/skb0r8tesr7yitvf">一篇文章</a>也有相关讨论，大家可以看看</p>
<h3 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h3><p>有新消息，&#x3D;&#x3D;服务端需要主动推送给前端&#x3D;&#x3D;。&#x3D;&#x3D;需要用到websocket。并且后台会维护一个定时任务&#x3D;&#x3D;，&#x3D;&#x3D;定时推送还未接收到ack的消息&#x3D;&#x3D;。保证消息的实时性。</p>
<h3 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h3><p>&#x3D;&#x3D;拉模式&#x3D;&#x3D;又分为&#x3D;&#x3D;短轮询和长轮询&#x3D;&#x3D;。前端主动询问后端是否有新消息。以定时的频率访问。我们项目已经用到了websocket，一般就不用拉模式了。**&#x3D;&#x3D;拉模式可以用在历史消息列表&#x3D;&#x3D;<strong>。&#x3D;&#x3D;新消息，还是要保证消息的</strong>即时性**&#x3D;&#x3D;。</p>
<p>缺点：</p>
<p>延迟较高：&#x3D;&#x3D;拉模式&#x3D;&#x3D;需要&#x3D;&#x3D;消费者主动请求数据&#x3D;&#x3D;，可能&#x3D;&#x3D;导致较高的延迟&#x3D;&#x3D;。</p>
<p>重复请求：如果&#x3D;&#x3D;消费者频繁请求相同数据&#x3D;&#x3D;，可能导致&#x3D;&#x3D;带宽浪费和系统效率降低&#x3D;&#x3D;。</p>
<h3 id="推拉结合-1"><a href="#推拉结合-1" class="headerlink" title="推拉结合"></a>推拉结合</h3><pre><code>理论上保证==消息的及时性，推模式==足够了，为什么还要拉模式？==推模式需要考虑推送失败的情况==，==又需要服务端启动定时任务==，==确保ack，方案比较复杂，对服务器消耗也大==。

实际上推送的失败概率没有那么高，如果客户端每隔一定的频率进行消息拉取。相当于==客户端是那个定时任务==。就能达到最终一致性。

采用推拉结合。**==推主要是保证及时性==**。而**==拉主要是保证最终一致性==**，也就是消息到达的可靠性。
</code></pre>
<p><img src="/.io//1694856070259-99191750-30be-4698-95d4-39ffe3ee93ac.webp" alt="image.png"></p>
<ol>
<li>&#x3D;&#x3D;推送新消息到达&#x3D;&#x3D;，里面没有任何特殊消息，仅仅是&#x3D;&#x3D;为了及时触发客户端的消息拉取动作&#x3D;&#x3D;。这个&#x3D;&#x3D;推是无状态的&#x3D;&#x3D;，也就可以任意调用，实现超级简单。</li>
<li>客户端&#x3D;&#x3D;接收到新消息提醒&#x3D;&#x3D;，或者是&#x3D;&#x3D;定时任务到达指定时间&#x3D;&#x3D;。对服务端发送拉取新消息的请求。&#x3D;&#x3D;只需要带个token&#x3D;&#x3D;就好了</li>
<li>服务端&#x3D;&#x3D;查询用户信箱里未ack的消息&#x3D;&#x3D;，全部返回给客户端。&#x3D;&#x3D;达到返回增量消息的目的&#x3D;&#x3D;。</li>
<li>客户端收到消息后，&#x3D;&#x3D;可批量ack，服务端收到ack&#x3D;&#x3D;。将信箱标记为已读取。</li>
</ol>
<p>接下来讨论几个问题。</p>
<p>&#x3D;&#x3D;服务端在拉取新消息&#x3D;&#x3D;的时候，指定的是两个字段，&#x3D;&#x3D;<code>uid</code>&#x3D;用户，<code>ack</code>&#x3D;false&#x3D;&#x3D;。为了能快速拉取到新消息。是不是需要&#x3D;&#x3D;一个联合索引，<code>uid&amp;ack</code>的联合索引&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;新消息的推送，仅是一个<strong>无状态通知</strong>&#x3D;&#x3D;，&#x3D;&#x3D;最终一致性是靠客户端的拉取实现的&#x3D;&#x3D;。也就意味着我们先后到达两条消息</p>
<p>aa，bb。&#x3D;&#x3D;aa触发的新消息通知，由于网络异常丢失了。bb消息入库时，进行新消息通知。&#x3D;&#x3D;这时候a拉取新消息的时候，也能把aa给拉到。&#x3D;&#x3D;这是单纯用消息推送无法做到的点。&#x3D;&#x3D;</p>
<p>由于整体的流程都变成无状态的请求了。&#x3D;&#x3D;这样客户端在请求新消息的时候，可以请求到批量的消息&#x3D;&#x3D;。&#x3D;&#x3D;客户端在ack&#x3D;&#x3D;的时候，也从原来的&#x3D;&#x3D;一条条ack，变成了可以批量ack。&#x3D;&#x3D;在&#x3D;&#x3D;大群聊很多消息&#x3D;&#x3D;的时候，我们可以通过&#x3D;&#x3D;控制新消息推送的速度，很很容易的达到合并拉取&#x3D;&#x3D;的效果。</p>
<p>只要我们在&#x3D;&#x3D;<strong>索引上下了功夫</strong>，查询未ack的速度就很快&#x3D;&#x3D;。客户端定时向后端的新消息拉取请求，<strong>不会占用多少cpu</strong>。另外由于没有新消息，拉取到的为空，<strong>也不占用多少带宽</strong>。</p>
<p>通过推拉结合的组合，&#x3D;&#x3D;通过无状态通知，减少服务端的压力&#x3D;&#x3D;。由&#x3D;&#x3D;客户端的请求触发最终一致性&#x3D;&#x3D;。&#x3D;&#x3D;收口了核心的接口达到复用效果&#x3D;&#x3D;。</p>
<p>但是&#x3D;&#x3D;依然<strong>没有解决热点群聊的写扩散</strong>问题&#x3D;&#x3D;，所有的消息依然需要写入到用户收信箱。</p>
<p>抹茶用的很简单，没用到这个方案。但是不妨碍我们被问到的时候，能够回答出来。</p>
<h2 id="多端同步"><a href="#多端同步" class="headerlink" title="多端同步"></a>多端同步</h2><pre><code>上文提到的推拉结合是个好方案，但是在多端同步的场景下就失效了。多端同步的核心，是确保消息可靠的到达多端。消息的可靠是通过ack完成的，问题就出来这里。

用户信箱只有一个，消息的状态分为ack=true，false。代表用户是否已经收到消息。但是在多端的场景下，如何去标识用户收到消息呢？
</code></pre>
<p><img src="/.io//1694875066927-747fcc4d-4054-41ea-b941-74e9aab836ec.webp" alt="image.png">、</p>
<p>&#x3D;&#x3D;这样每个端的ack，都需要独立去维护自己的ack信箱了&#x3D;&#x3D;。手机收到了两条消息，电脑收到了一条。在电脑进行新消息拉取的时候，拉取到的消息应该是2，3，4。而手机端拉取到的应该是3，4。这样的设计可太烂了。难道我们要为每个端都准备一个信箱吗？如果有新的端加入，信箱还需要做历史数据修复吗？为了兼容这个场景，我们不得不去设计一套新的交互方案。</p>
<p>我们来思考一个问题。可靠性，究竟是怎么保证的？是靠状态的持久化来保证的。&#x3D;&#x3D;比如收信箱里的ack，就明确标识了用户接收了哪些，没接收到哪些，之后才能够推送未ack的。&#x3D;&#x3D;保证最终一致性。而现在的状态存储遇到了问题。&#x3D;&#x3D;多端场景下，需要服务端维护<strong>多端状态</strong>。&#x3D;&#x3D;这是一个难题，那么能不能把多端状态抛给客户端？？</p>
<p><img src="/.io//1694876581542-d9e90c2a-e4e7-4224-9a8b-5a6b06f5e2f8.webp" alt="image.png"></p>
<pre><code>服务端不再维护ack状态，由客户端维护。==客户端维护该端读取到的最后一条消息的游标==。这个**游标**的选择，需要==具备**唯一性**和**有序性**==。关联上我们前面介绍的，也就是用消息id来保证了。
</code></pre>
<p>每次推送，都&#x3D;&#x3D;需&#x3D;&#x3D;&#x3D;&#x3D;要对多端进行新消息通知&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;每次拉取新消息的时候，客户端不仅需要带上token&#x3D;&#x3D;，&#x3D;&#x3D;还需要带上自己当前读到的游标&#x3D;&#x3D;。服务端&#x3D;&#x3D;根据游标，查询到id大于游标的消息&#x3D;&#x3D;，全部返回给客户端。</p>
<p>手机请求新消息时，&#x3D;&#x3D;带上的是自己的游标是2。查到大于2的消息3，4。&#x3D;&#x3D;</p>
<p>电脑请求新消息时&#x3D;&#x3D;，带上的是自己的游标是1。查到大于1的消息2，3，4&#x3D;&#x3D;。</p>
<p>这一切的前提，&#x3D;&#x3D;是<strong>id是全局递增</strong>的&#x3D;&#x3D;。这样服务端&#x3D;&#x3D;只需要维护一个游标&#x3D;&#x3D;。每次拉取新消息，都是拉取多个会话的消息。</p>
<p>如果&#x3D;&#x3D;id是<strong>收信箱递增</strong>的&#x3D;&#x3D;，对于单个用户来说，其实&#x3D;&#x3D;相当于是全局递增了&#x3D;&#x3D;。用的是&#x3D;&#x3D;收信箱的id做游标，而不是用消息id&#x3D;&#x3D;。也能达到全局的效果。微信就是这个方案。（&#x3D;&#x3D;这里是直接根据收件箱的id做游标，可行&#x3D;&#x3D;）</p>
<p>如果&#x3D;&#x3D;id是<strong>会话级别递增</strong>&#x3D;&#x3D;的，那么&#x3D;&#x3D;客户端就需要维护每个会话的游标了&#x3D;&#x3D;，&#x3D;&#x3D;每次拉取消息的时候需要带上<code>会话id＋游标id</code>&#x3D;&#x3D;。每次定时任务的拉取，&#x3D;&#x3D;也需要带上<strong>多个</strong><code>会话id＋游标id</code>，为每个会话都尝试拉取最新消息&#x3D;&#x3D;。整体实现复杂了不少。这种方案通常不常见。</p>
<p><img src="/.io//1695130491354-2805f3d6-1e7d-4dd7-b916-e398448e232e.webp" alt="image.png"></p>
<pre><code>对于抹茶来说，==是全局递增的id==，==完全可以客户端存储阅读游标的方式实现多端消息同步。==虽然我们暂时没有去做，但是大家可以这样去回答。

抹茶的多端同步也比较简单，==毕竟是一个web项目不保存消息。登录每个端都一样==。==拉取最新的一页消息。后续新消息通知就拉取新消息。感兴趣历史消息，也可以通过翻页加载的方式加载老消息。==对于==客户端缓存消息来说，看老消息直接从库里查==，都不需要翻页加载了。
</code></pre>
<h2 id="单聊群聊"><a href="#单聊群聊" class="headerlink" title="单聊群聊"></a>单聊群聊</h2><pre><code>==消息表怎么兼容单聊和群聊==。我看市面上很多的设计都是这样的。
</code></pre>
<p><img src="/.io//1694881218413-cad8e188-0c7d-49e9-af92-09e7c3705429.webp" alt="image.png"></p>
<pre><code>目标类型分为单聊和群聊。**单聊**的情况下目标id填**uid**。**群聊**情况下，目标id填**群组id**。这样消息是兼容了，但是其他地方也都要兼容了。==比如我们的个人收信箱。需要存所有消息。同时还要知道这个消息在哪个会话下的。单聊群聊的会话要怎么去唯一标识呢，首先个人信箱，都需要个人uid去标识。一般单聊是加上好友uid，就代表会话。群聊加上群id。==
</code></pre>
<p><img src="/.io//1694881895993-0e8f3911-f315-40a8-856c-5048a037abcd.webp" alt="image.png"></p>
<p>这样收信箱也需要兼容单聊和群聊，&#x3D;&#x3D;设计两个字段，后续为了能快速命中会话，还需要设计<strong>组合索引</strong>&#x3D;&#x3D;。</p>
<pre><code>后续其他表只要是==涉及会话id的都需要这两个字段==。想想就麻烦。本着复用和抽象的原则。能复用的地方，就给它抽出来，看看我们要怎么去优化它。
</code></pre>
<p><img src="/.io//1694882377438-8c76afd6-ad37-4eab-a9d4-196dd82a3d70.webp" alt="image.png"></p>
<pre><code>我们可以==抽象一个房间表出来，群聊所有人在一个房间里面聊天。单聊无非就是两个人在房间里面聊天==。这样房间关联上单聊或者群聊的相关信息。有了这层抽象。==消息表和个人信箱都不需要两个字段标识会话了==。直接用==房间id就是会话id==。通过房间id，自然就关联出对应的单聊群聊信息了。
</code></pre>
<p><a target="_blank" rel="noopener" href="https://drawsql.app/teams/-328/diagrams/-6">https://drawsql.app/teams/-328/diagrams/-6</a></p>
<p><img src="/.io//1694880682366-4a1e72a0-cff5-45ca-834f-c405eab3d6b6.webp" alt="image.png"></p>
<pre><code>所以表结构设计就是这样的。==通过房间表room，抽象了一层，**屏蔽了单聊群聊的差异**，==让其他关心会话的表设计起来更加简单。只需要关联一个房间id字段。

**单聊群聊**和**房间**，都是一对一的关系。==相当于单聊表和群聊表都是扩展表==。本质上是==可以直接在room上面添加字段的==。选择扩展能划分更加明确。

**群聊**有对应的头像，群名称等。另外还有一个很重要的群成员。==由于群成员和群是多对一的关系。一个群可以有多个群成员==。

==**群成员**单独建了一张表==。==里面有个role字段==，记录群成员在群里的属性，==比如群主，管理员，普通成员==。如果我们需要快速判断一个群的群主怎么办？为了走索引，==所以设计了`group_id和role`的联合索引==。当然你也可以作为冗余字段，直接记录在group表，添加个群主uid字段。

==**单聊表**有个很重要的点，就是怎么去唯一确认一个房间==。比如我新加了一个好友，==系统为我们生成了一个单聊房间。==后续在好友列表找到这个好友，对他发消息。==这时候怎么找到我们之前的那个房间==。==这时候我只知道我的uid和好友的uid==。
</code></pre>
<p>所以在单聊表中有两个重要的字段，&#x3D;&#x3D;uid1和uid2代表好友双方的uid&#x3D;&#x3D;。为了能保证双方建立的房间的唯一性。我们增加了一个唯一字段&#x3D;&#x3D;<code>room_key</code>&#x3D;&#x3D;来唯一标识两个好友的房间。</p>
<p>他的生成规则很简单。<code>uid1_uid2</code>。其中uid1是双方uid较小的那个，uid2是双方uid较大的那个。这样避免不同的排列顺序，产生二义性。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><pre><code>上面的设计完全是抹茶的设计。==通过抽象一层房间表，来屏蔽单聊群聊的差异，让消息表和会话表的存储变得更加简单。==这是后续面试官会无数次问到你的问题。了解其中的背景和方案，让你在后续的面试中能够对答如流。
</code></pre>
<h2 id="消息的已读和未读"><a href="#消息的已读和未读" class="headerlink" title="消息的已读和未读"></a>消息的已读和未读</h2><p>为了满足各位老板的诉求，钉钉和企业微信都支持查看消息的已读未读。</p>
<p><img src="/.io//1690708033267-a86c050b-7c97-435f-9d3e-ce03138bb685.webp" alt="img"></p>
<pre><code>这里面有几个关键的元素，总共==**多少人已读**，**多少人未读**，**已读未读列表。**==一条消息怎么知道对方读没读了？这又回到了ack的问题。==刚刚我们的多端同步好不容易把ack给取消了，通过客户端维护自己的**阅读游标**，来保证消息的可靠性。==现在服务端还是需要维护每个人的ack，这样才知道消息读没读
</code></pre>
<blockquote>
<p>这里记得是通过维护各端的游标来取消ack的</p>
</blockquote>
<p><img src="/.io//1694930308758-683605d3-6cae-47a7-b2d4-7c72e3b73de8.webp" alt="image.png">、</p>
<pre><code>相当于每条消息，都需要投递到用户的收信箱，并且需要记录已读未读的状态。用户读取消息后，需要返回ack。消息投递的可靠性依然由客户端拉取消息自行保证。收信箱的ack是用于已读未读的统计。
</code></pre>
<ol>
<li>&#x3D;&#x3D;有人发了条消息1&#x3D;&#x3D;，群消息入库，&#x3D;&#x3D;并插入到群成员A和B的收信箱&#x3D;&#x3D;，此时都是未读状态</li>
<li>&#x3D;&#x3D;推送服务通知A和B拉取新消息&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;A正好在线，拉取了新消息1，拉到消息后，返回ACK&#x3D;&#x3D;。</li>
<li>推送服务标记A对消息1的ACK。</li>
<li>&#x3D;&#x3D;ack的消息同时需要推送给消息的发送者&#x3D;&#x3D;，同步更新</li>
<li>&#x3D;&#x3D;发消息的人想看看消息的相关情况&#x3D;&#x3D;。</li>
</ol>
<blockquote>
<p>已读数:<code>select count(0) from 信箱 where msgId=xx and ack=true;</code></p>
<p>未读数:<code>select count(0) from 信箱 where msgId=xx and ack=false;</code></p>
<p>已读列表：<code>select uid from 信箱 where msgId=xx and ack=true order by ack_time;</code></p>
<p>未读列表：<code>select uid from 信箱 where msgId=xx and ack=false order by create_time;</code></p>
<p>这里面有几个瓶颈，咱们可以一个个尝试解决。</p>
</blockquote>
<h3 id="收信箱写指数扩散"><a href="#收信箱写指数扩散" class="headerlink" title="收信箱写指数扩散"></a>收信箱写指数扩散</h3><pre><code>对于一个万人群聊，==每条消息都需要记录所有人的ack==。==一条消息就需要写入1w条收信箱记录==。==每人发一条消息，那就是1w*1w=1亿==的记录量。对存储来说是个很大的负担，有没有可能减轻负担呢？

换个思路，==用户的收信箱能不能不为每条消息记录ack==，==只记录用户阅读的最新时间线（类似之前的客户端存游标）==。这样用户ack的时候，==后台只需要更新ack的最新时间==。
</code></pre>
<p><img src="/.io//1694932870774-221b3d26-6a96-4bd8-b015-0d9da08552dc.webp" alt="image.png"></p>
<p>A收到新消息10003后，提交ack。收信箱记录A最后的阅读时间10003。这样存储就不会因为消息而指数扩散了。</p>
<p>只和群成员数有关，每个人都只有一行阅读记录。</p>
<p>因此我们设计了&#x3D;&#x3D;如下的用户收信箱表，也叫会话表&#x3D;&#x3D;。</p>
<p><a target="_blank" rel="noopener" href="https://drawsql.app/teams/-328/diagrams/-7">https://drawsql.app/teams/-328/diagrams/-7</a></p>
<p><img src="/.io//1694936653684-cf437a2a-a5cc-4c82-9339-de9f5d650e5f.webp" alt="image.png"></p>
<p>我们是知道消息的发送时间的。</p>
<blockquote>
<p>已读数:<code>select count(0) from 信箱 where room_id=xx and read_time&gt;消息时间;</code></p>
<p>未读数:<code>select count(0) from 信箱 where room_id=xx and read_time&lt;消息时间;</code></p>
<p>已读列表：<code>select uid from 信箱 where room_id=xx and read_time&gt;消息时间 order by create_time;;</code></p>
<p>未读列表：<code>select uid from 信箱 where room_id=xx and read_time&lt;消息时间 order by create_time;;</code></p>
</blockquote>
<pre><code>所以这里面有个关键，需要==room_id和read_time==的联合索引，才能够加速查询。

目前抹茶就采用的这个方案，对于我们来说消息id是**全局单调递增**的。其实可以用消息id来进行比较和游标。没必要用时间来比较。这是后面可以优化的点。
</code></pre>
<h3 id="消息阅读推送"><a href="#消息阅读推送" class="headerlink" title="消息阅读推送"></a>消息阅读推送</h3><pre><code>类似钉钉和微信，发送完每条消息，就能看见他的阅读数在蹭蹭上涨。只要有人阅读了，他就加1，看起来是实时增加的。这个怎么设计呢？

最暴力的做法。==每个人阅读完群消息，都通知给发送方。然后消息阅读数+1==。
</code></pre>
<p><img src="/.io//1694934319042-c125f3be-5ebb-4fed-90ba-5e19a005dc5d.webp" alt="image.png"></p>
<pre><code>这样的消息推送频率也是很高的，特别是在万人群聊下，==发一条消息，就要收到几千次的ack推送==。又要==几千次的ack给小王==。

==优化一下，将推送合并==。可以采用**服务端定时任务**的方式。==定时任务的间隔==，就成为了合并的时间窗口。
</code></pre>
<p><img src="/.io//1694934553162-c79fc616-5199-48f2-a766-1585b3adfbb1.webp" alt="image.png"></p>
<p>小王发送新消息后，&#x3D;&#x3D;后端起个定时任务。每5，20，40，100，200,指数上升的时间&#x3D;&#x3D;，给他推送一次消息的总阅读数。&#x3D;&#x3D;这样在5s内的ack都会被合并成一次总的阅读数推送给小王&#x3D;&#x3D;。</p>
<p>这样做的前提，是&#x3D;&#x3D;业务允许小王对消息阅读数一开始很关注&#x3D;&#x3D;，&#x3D;&#x3D;过了30s后，就不那么着急更新的时间了&#x3D;&#x3D;。&#x3D;&#x3D;过了几分钟后&#x3D;&#x3D;，小王压根就不关心消息的阅读数了。定时任务也可以停止了。</p>
<p>&#x3D;&#x3D;这个方案可以节省很大的性能。但是后端维护一个定时任务还是有些麻烦&#x3D;&#x3D;，小王<strong>真的有那么关心消息的阅读吗</strong>？这5分钟内，他都会在这个页面等着看最新的阅读数吗？</p>
<p><img src="/.io//1694935196869-922dfa70-cb91-4577-b33b-0eff6e2eede7.webp" alt="image.png"></p>
<p>由前端自己查询消息的未读数。假设我发了十几条消息。我真的在乎那些消息有谁阅读了嘛？</p>
<p>只有我停留在那个房间，且一个屏幕内有我的发送过的消息，我才需要实时更新未读数。</p>
<p><img src="/.io//1694935301440-09120016-7b3f-4c8c-ad80-2952720816cb.webp" alt="image.png"></p>
<p>比如这一屏内，我只有这两条消息需要看到未读数的更新，我只需要前端启个定时任务自己查这两条消息就好了。这样又节省了很大的性能，更多的时候，我可能已经退出了页面，就一条消息的未读数都不查了。</p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>我们抹茶目前就采用这样的方案。</p>
<p>通过只记录用户阅读的时间线，减少了每条消息ack存储的成本。</p>
<p>通过合理的索引，让消息已读未读数的统计变得飞快。</p>
<p>通过前端的定时请求，让消息的已读数更新，避免了性能的无效浪费。</p>
<h2 id="会话列表设计"><a href="#会话列表设计" class="headerlink" title="会话列表设计"></a>会话列表设计</h2><p><a target="_blank" rel="noopener" href="https://drawsql.app/teams/-328/diagrams/-7">https://drawsql.app/teams/-328/diagrams/-7</a></p>
<p><img src="/.io//1694936650475-f26874de-9316-4b1e-9660-88e6cf5b25bd.webp" alt="image.png"></p>
<p>有了这样的设计，我们还能很轻松的实现会话列表的功能。</p>
<p><img src="/.io//1694936308310-68841798-91c9-4cae-a4fb-722f0d57ae5f.webp" alt="image.png"></p>
<p>这张&#x3D;&#x3D;会话表&#x3D;&#x3D;，就是&#x3D;&#x3D;用户优化过后的收信箱&#x3D;&#x3D;。来看看怎么靠他实现对应的功能。</p>
<p>会话表记录的是&#x3D;&#x3D;<code>uid</code>在某个<code>room</code>&#x3D;&#x3D;内的消息详情，比如&#x3D;&#x3D;<code>最新消息时间</code>，自己<code>阅读到的时间</code>&#x3D;&#x3D;。</p>
<p>会话列表：&#x3D;&#x3D;<code>select room_id from contact where uid =我  order by active_time desc</code>&#x3D;&#x3D;。查到我的所有会话，&#x3D;&#x3D;并按照每个会话的最新消息时间倒序排序。&#x3D;&#x3D;为了能快速命中索引，需要&#x3D;&#x3D;<code>uid和active_time</code>&#x3D;&#x3D;的联合索引</p>
<p>会话消息未读数：&#x3D;&#x3D;<code>select count(0) from msg where room_id=我房间 and create_time&gt;我阅读</code>&#x3D;&#x3D;。拿着自己会话表的阅读时间去消息表比较&#x3D;&#x3D;，由于有<code>room_id和create_time</code>的联合索引&#x3D;&#x3D;。查找速度很快。</p>
<p>优化：假设我很多年没上线了。消息的未读数达到了几万条，就算我有索引，也得扫描几万条记录，统计未读数。这个还是比较耗时的，怎么办呢？参考微信最大只展示99条消息的未读数。我们的未读数统计可以优化成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select <span class="title function_">count</span><span class="params">(<span class="number">0</span>)</span> from</span><br><span class="line">(</span><br><span class="line">  SELECT <span class="number">1</span></span><br><span class="line">    FROM msg</span><br><span class="line">    WHERE room_id=我房间 and create_time&gt;我阅读</span><br><span class="line">    LIMIT <span class="number">100</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样未读数最多只会扫描100条，避免了极端的场景。</p>
<p>抹茶的会话表设计，目前就采用了这样的方案。通过记录阅读<strong>时间线</strong>而不是记录每条<strong>消息的ack</strong>。完美适配了会话列表的功能，和消息已读未读数的功能。</p>
<h2 id="热点群聊（读写扩散混合）"><a href="#热点群聊（读写扩散混合）" class="headerlink" title="热点群聊（读写扩散混合）"></a>热点群聊（读写扩散混合）</h2><p>前面留了那么多个坑，都依然没有解决万人群聊写扩散的问题。但是通过一步步的表结构设计的优化，已经逐渐接近了。</p>
<p>&#x3D;&#x3D;万人群聊最大的问题，就是每条消息，都需要写入用户的收信箱。&#x3D;&#x3D;也就是&#x3D;&#x3D;那个会话表的<code>active_time</code>字段&#x3D;&#x3D;。更新了这个字段，&#x3D;&#x3D;最新消息的那个会话才能排序在最前面。&#x3D;&#x3D;如果不更新，这个房间在用户的会话列表就排在很后面了。</p>
<p>这个&#x3D;&#x3D;更新时间可以记&#x3D;&#x3D;，但是&#x3D;&#x3D;能不能单独记，不扩散写到用户的收信箱&#x3D;&#x3D;，而是&#x3D;&#x3D;单独写到热点信箱，用户读取的时候综合读取自己收信箱的会话，合并热点信箱的会话&#x3D;&#x3D;。</p>
<p><img src="/.io//1694938909569-0647c645-2367-48fd-ae7a-7f663a35aa73.webp" alt="热点群聊.png"></p>
<p>这样每个小方块都是一个房间，里面的数字代表这房间的最新消息<strong>游标</strong>。</p>
<ul>
<li>对于&#x3D;&#x3D;<strong>小群聊</strong>写扩散到用户的每个收信箱，更新房间的最新消息<strong>游标</strong>&#x3D;&#x3D;。</li>
<li>对于&#x3D;&#x3D;<strong>热点群聊</strong>，直接<strong>单独记录</strong>该房间的最新<strong>游标</strong>&#x3D;&#x3D;。</li>
<li>用户在查询自己会话列表的时候，通过&#x3D;&#x3D;<strong>聚合层</strong>。聚合自己<strong>收信箱</strong>，和自己参与的<strong>热点群聊</strong>的<strong>排序</strong>&#x3D;&#x3D;，然后展示给用户</li>
</ul>
<p>这样就可以&#x3D;&#x3D;节省每次热点群聊写扩散的消耗了，对热点群聊&#x3D;&#x3D;来说是个极致的提升。</p>
<p><a target="_blank" rel="noopener" href="https://drawsql.app/teams/-328/diagrams/-7">https://drawsql.app/teams/-328/diagrams/-7</a></p>
<p><img src="/.io//1694939418984-09f0d450-0f5e-4ae4-98c7-3b23599ffbf3.webp" alt="image.png"></p>
<p>热点群聊相关的信息，&#x3D;&#x3D;直接记录在room表里&#x3D;&#x3D;，&#x3D;&#x3D;不需要写入到用户信箱&#x3D;&#x3D;。</p>
<p>为了&#x3D;&#x3D;<strong>聚合</strong>的时候<strong>效率</strong>更高&#x3D;&#x3D;。我们还可以把&#x3D;&#x3D;热点群聊直接缓存在redis的zset里&#x3D;&#x3D;。这样聚合的时候，速度更快。</p>
<h3 id="精确时间聚合"><a href="#精确时间聚合" class="headerlink" title="精确时间聚合"></a>精确时间聚合</h3><p>在现实的场景里，&#x3D;&#x3D;跨服务分页一直是一个难题&#x3D;&#x3D;。最佳的方案&#x3D;&#x3D;就是写一张聚合表&#x3D;&#x3D;，将&#x3D;&#x3D;跨库的数据聚合成一张表&#x3D;&#x3D;，然后进行&#x3D;&#x3D;条件分页&#x3D;&#x3D;。然而我们的&#x3D;&#x3D;热点群聊就是为了避免写扩散，所以才需要聚合&#x3D;&#x3D;。这个方案行不通了。</p>
<p>那我们怎么去聚合呢。可以选一张&#x3D;&#x3D;主表用来分页，副表用来聚合&#x3D;&#x3D;。</p>
<p><img src="/.io//1694942089281-94e4bb4e-0c03-4f85-b604-faa88aadf6e5.webp" alt="image.png"></p>
<ol>
<li>以收信箱为主表，&#x3D;&#x3D;查询第一页,假设一页3条&#x3D;&#x3D;。&#x3D;&#x3D;查到3，5，7&#x3D;&#x3D;，&#x3D;&#x3D;通过3和7作为条件&#x3D;&#x3D;，&#x3D;&#x3D;筛选热点群聊里面的房间，只能筛选到4。2&#x3D;&#x3D;怎么办？？？需要兼容第一页的场景，&#x3D;&#x3D;start不应该限制。只限制end&lt;7&#x3D;&#x3D;，筛选出2和4。&#x3D;&#x3D;聚合返回2，3，4，5，7&#x3D;&#x3D;。</li>
</ol>
<p><img src="/.io//1694942346761-98c8132b-b529-498d-a62a-dda06784d0fe.webp" alt="image.png"></p>
<pre><code>2.第二页==只有两条，筛选出9和10==，通过9和10作为条件，筛选热点群聊房间，==筛选不到。那18怎么办？？==需要==兼容最后一页==的场景，==end不应该限制，只限制start&gt;9.筛选出18.==聚合返回9，10，18.
</code></pre>
<p>这种方案性能非常的高，&#x3D;&#x3D;但是需要业务能够接受本来一页三条数据&#x3D;&#x3D;，&#x3D;&#x3D;有可能一页5条，或者一页4条的情况&#x3D;&#x3D;。在极端场景这个人加入了很多热点群聊，一页可能会加载出100多条数据</p>
<h3 id="精确条数聚合"><a href="#精确条数聚合" class="headerlink" title="精确条数聚合"></a>精确条数聚合</h3><p>如果业务有强烈的诉求，期望一页得到的条数是固定的3条，我们也需要提供相应的方案来满足诉求。</p>
<p><img src="/.io//1694943058398-885e6af8-0946-40c0-ae28-eb1487b34152.png" alt="img"></p>
<ol>
<li><p>查询&#x3D;&#x3D;第一页的三条&#x3D;&#x3D;，&#x3D;&#x3D;个人收信箱和热点信箱都是主表&#x3D;&#x3D;。&#x3D;&#x3D;双方各查出一页的数据<strong>候选</strong>&#x3D;&#x3D;（&#x3D;&#x3D;避免极端情况一页都是热点，或一页都是普通&#x3D;&#x3D;）。通过&#x3D;&#x3D;归并排序的方式，每次都pk普通和热点的房间&#x3D;&#x3D;，&#x3D;&#x3D;取出较小的那个放到结果集合&#x3D;&#x3D;。&#x3D;&#x3D;第一轮比较取出2，第二轮比较取出3&#x3D;&#x3D;，&#x3D;&#x3D;第三轮比较取出4&#x3D;&#x3D;，填满即可。</p>
<blockquote>
<p>这个很像一个面试题，大文件排序怎么做？</p>
</blockquote>
<p>大文件的难点，在于内存放不下所有的数据。因此只能拆分成一个个局部排序的小文件。然后再对多个小文件，进行<strong>多路归并排序</strong></p>
<p><img src="/.io//1694943718419-8c2e2296-b2b1-4efe-89ba-6e1cd4201772.webp" alt="img"></p>
<pre><code>将多个文件的头结点，一起构造==一颗小顶堆的树==。==每次从顶堆取值==，==就汇总最终的排序==。顶堆支持==每次弹出一个值就从候选队列再压入一个值==。类似的是，我们的抹茶只有两路归并，简单了不少。
</code></pre>
<p><img src="/.io//1694944213805-5d1c5c07-2f45-4a11-a7ad-58248d91508d.webp" alt="image.png"></p>
</li>
</ol>
<p>2.查询第二页。&#x3D;&#x3D;根据上一页的最后一条的游标&#x3D;&#x3D;，&#x3D;&#x3D;确定下一页开始的位置&#x3D;&#x3D;，&#x3D;&#x3D;这就是<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/mallchat/kf0dtv51houe86nh">游标翻页</a>&#x3D;&#x3D;。这个场景用普通翻页无法实现。&#x3D;&#x3D;根据上一页的最后一条消息是4，往下双方各查一页。&#x3D;&#x3D;最终通过归并排序，返回结果5，7，9。</p>
<p>这样就是做到精确分页了，他的核心是，&#x3D;&#x3D;id必须全局单调递增&#x3D;&#x3D;。因为&#x3D;&#x3D;每个会话记录的都是最后一条消息的id&#x3D;&#x3D;。这个id是用来排序的，&#x3D;&#x3D;如果id只能做到会话内递增&#x3D;&#x3D;，那不同会话间压根没法比较。（&#x3D;&#x3D;要答现在自己的聊天室做的是全局id自增，所以才能实现这样的操作&#x3D;&#x3D;）</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>我们会发现，所有的方案有有好有坏，没有最佳方案，只有最适合业务的方案。而这种方案一般都是扬长避短的去组合每个方案的优点来共同实现。&#x3D;&#x3D;推拉结合是这样。热点群聊的读写扩散混合也是这样&#x3D;&#x3D;。</p>
<p>为了&#x3D;&#x3D;避免热点群聊的写扩散&#x3D;&#x3D;，我们&#x3D;&#x3D;设计了会话聚合模块&#x3D;&#x3D;。为&#x3D;&#x3D;了满足会话的排序，我们设计了精确时间聚合&#x3D;&#x3D;，或者精确条数聚合的方案。其中精确条数要求id全局单调递增。</p>
<p>抹茶采用的方案是比较简单的&#x3D;&#x3D;精确时间聚合&#x3D;&#x3D;。由于抹茶是id全局单调递增的，想要改成精确条数聚合也特别的简单，大家可自行选择。</p>
<h2 id="消息表支持多类型消息"><a href="#消息表支持多类型消息" class="headerlink" title="消息表支持多类型消息"></a>消息表支持多类型消息</h2><p>支持多类型的消息表，是怎么设计的？</p>
<p><img src="/.io//1695138190521-256e0017-5473-4dbb-9127-ec884512eb60.webp" alt="复杂图片.jpg"></p>
<p>我们能够支持文件，视频，pdf，图片，语音，文本。这么多类型的消息，这个表结构该如何设计呢？</p>
<p>首先来思考下，文件，视频，图片，他们都是啥。&#x3D;&#x3D;真抽象起来，不全部都是一个文件吗&#x3D;&#x3D;，&#x3D;&#x3D;一个存在oss里面的<strong>url</strong>&#x3D;&#x3D;。有了这个思路就简单了。</p>
<p>我们只需要&#x3D;&#x3D;添加一个上传的接口，这些类型的消息，前端只需要上传后记录url&#x3D;&#x3D;，提交给我们即可。</p>
<p>参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/269/2720">腾讯sdk</a>。我们的<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/mallchat/rkb2uz5k1qqdmcmd">多类型消息文档</a>。</p>
<p><a target="_blank" rel="noopener" href="https://drawsql.app/teams/-328/diagrams/-8">https://drawsql.app/teams/-328/diagrams/-8</a></p>
<p><img src="/.io//1694946409060-202f0226-5002-40e2-aace-83fe76b57c1a.webp" alt="image.png"></p>
<p>消息最重要的其实就是两个字段。</p>
<p><code>type</code>：指定消息是什么类型。</p>
<p><code>extra</code>：放置不同类型消息的详情，如果是特别重要的消息，还可以通过设置关联表的方式，扩展出去，比如红包类型消息。</p>
<p>这里的&#x3D;&#x3D;<code>content</code>，<code>reply_msg_id</code>,<code>gap_count</code>其实都是文本类型的消息才有的字段&#x3D;&#x3D;，&#x3D;&#x3D;也可以扔extra里面去。&#x3D;&#x3D;由于一开始的历史兼容问题，没有删除字段，后续可以移除，让消息表更简洁。</p>
<p>消息表最重要的&#x3D;&#x3D;就是<strong>谁</strong>，在哪个<strong>房间</strong>&#x3D;&#x3D;，&#x3D;&#x3D;发送了什么<strong>类型</strong>的消息&#x3D;&#x3D;。&#x3D;&#x3D;<strong>详情</strong>都可以在<strong>extra</strong>&#x3D;&#x3D;里面。</p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>以上聊的这么多方案都是市面上的IM这十几年，遇到的一个又一个经典问题。你会发现没有最优的方案，只有最适合业务的方案。不管抹茶是怎么实现的，我们都讨论了不同的场景下，可能的设计方案是怎样的。</p>
<p>这篇文章，我愿称之为抹茶文档的核心中的核心。深刻了解其中的每个方案，可以助你在面试中被问到任何刁难的问题都可以迎刃而解。</p>
<p>写该文章大概花了两周的时间。其中一次次心潮澎湃，停不下来，写到深夜两三点。</p>
<p><img src="/.io//1694947486805-85c3db30-a485-481a-b892-fd2c78c75f67.png" alt="img"></p>
<p><img src="/.io//1694947519712-d0b9de3a-6c1a-49d6-8ede-e2a4eae4ebf9.png" alt="img"></p>
<p>如果你看了该文章有那么一瞬间，让你<strong>豁然开悟</strong>，能让<strong>你拍手叫绝</strong>。希望能在该<strong>文章下方的评论</strong>，看到你的反馈。希望能找到同频的你，一起徜徉在IM的海洋，peace &amp; love。</p>
<h1 id="随机临时相关问题"><a href="#随机临时相关问题" class="headerlink" title="随机临时相关问题"></a>随机临时相关问题</h1><h2 id="1-什么是CompletableFuture？"><a href="#1-什么是CompletableFuture？" class="headerlink" title="1.什么是CompletableFuture？"></a>1.什么是CompletableFuture？</h2><blockquote>
<p>completableFuture是java8引入的一个类，可以解决异步执行任务，处理异步任务的结果，可以系统的性能和响应速度</p>
<p>completableFuture是java8引入的一个组件，提供了一个简单且强大的方式去处理异步的任务，和处理异步任务的结果，在completableFuture出来以前我们只能使用Callable&#x2F;Future的机制来去获取异步线程的执行结果，但是Future是通过阻塞等待的方式来实现的，对性能不是很友好，而使用completableFuture可以让我们将一个耗时的任务提交给线程池中进行异步处理，然后继续执行其他任务，等到异步任务执行结束之后，会触发一个回调方法，我们可以在回调方法里面去处理异步任务的执行结果，相当于优化了Future的阻塞等待问题，类似于一种响应式的编程方式，提供了一些便捷的方法，比如说thenApply、thenAccept、thenRun等，可以让我们以异步的方式来处理异步任务的执行结果</p>
<p>项目中使用了CompletableFuture.supplyAsync方法**<code>Supplier&lt;U&gt; supplier</code>**: 这是一个函数接口，它不接受任何参数并返回一个结果（类型为<code>U</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并行请求</span></span><br><span class="line">List&lt;CompletableFuture&lt;Pair&lt;String, UrlInfo&gt;&gt;&gt; futures = matchList.stream().map(match -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="comment">//Supplier&lt;U&gt; supplier: 这是一个函数接口，它不接受任何参数并返回一个结果（类型为U）</span></span><br><span class="line"><span class="type">UrlInfo</span> <span class="variable">urlInfo</span> <span class="operator">=</span> getContent(match);</span><br><span class="line"><span class="keyword">return</span> Objects.isNull(urlInfo) ? <span class="literal">null</span> : Pair.of(match, urlInfo);</span><br><span class="line">&#125;)).collect(Collectors.toList());</span><br><span class="line">CompletableFuture&lt;List&lt;Pair&lt;String, UrlInfo&gt;&gt;&gt; future = FutureUtils.sequenceNonNull(futures);</span><br><span class="line"><span class="comment">//这句是利用了工具方法实现将多个completableFuture对象转换成为一个</span></span><br></pre></td></tr></table></figure>

</blockquote>
<h2 id="2-接口和抽象类的区别"><a href="#2-接口和抽象类的区别" class="headerlink" title="2.接口和抽象类的区别"></a>2.接口和抽象类的区别</h2><blockquote>
<p>1.接口是行为的抽象，是一种行为的规范，抽象是对类的抽象，是一种模板设计</p>
<p>2.接口没有构造方法，而抽象类有构造方法，其方法一般给子类使用</p>
<p>3.&#x3D;&#x3D;接口只有定义&#x3D;&#x3D;，&#x3D;&#x3D;没有方法的实现&#x3D;&#x3D;，java1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现、</p>
<p>4.抽象体现出了继承关系，继承只能单继承。接口体现出现了实现的关系，实现可以多实现。接口强调特定功能的实现，而抽象类强调所属关系。</p>
</blockquote>
<h1 id="项目值得问题（简历外）"><a href="#项目值得问题（简历外）" class="headerlink" title="项目值得问题（简历外）"></a>项目值得问题（简历外）</h1><h2 id="1-注解实现，简介实现频率控制-没看懂"><a href="#1-注解实现，简介实现频率控制-没看懂" class="headerlink" title="1.注解实现，简介实现频率控制(没看懂)"></a>1.注解实现，简介实现频率控制(没看懂)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/msg&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;发送消息&quot;)</span></span><br><span class="line"><span class="meta">@FrequencyControl(time = 5, count = 3, target = FrequencyControl.Target.UID)</span></span><br><span class="line"><span class="meta">@FrequencyControl(time = 30, count = 5, target = FrequencyControl.Target.UID)</span></span><br><span class="line"><span class="meta">@FrequencyControl(time = 60, count = 10, target = FrequencyControl.Target.UID)</span></span><br><span class="line"><span class="keyword">public</span> ApiResult&lt;ChatMessageResp&gt; <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> ChatMessageReq request)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">msgId</span> <span class="operator">=</span> chatService.sendMsg(request, RequestHolder.get().getUid());</span><br><span class="line">    <span class="comment">//返回完整消息格式，方便前端展示</span></span><br><span class="line">    <span class="keyword">return</span> ApiResult.success(chatService.getMsgResp(msgId, RequestHolder.get().getUid()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接看效果，通过频控注解，很轻松的就实现接口的请求频率控制，防止有人瞎点。</p>
<p>有些接口还需要配置&#x3D;&#x3D;多种频控策略&#x3D;&#x3D;，这种我们&#x3D;&#x3D;可以再加个注解，将多个策略包起来&#x3D;&#x3D;。甚至通过一些配置，还能更简洁。</p>
<p><img src="/.io//1683730199674-c637177d-5e89-46a2-ae0a-f44872a9e44b.webp" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.abin.mallchat.common.common.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 频控注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repeatable(FrequencyControlContainer.class)</span><span class="comment">//可重复</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//运行时生效</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//作用在方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FrequencyControl &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key的前缀,默认取方法全限定名，除非我们在不同方法上对同一个资源做频控，就自己指定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">prefixKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 频控对象，默认el表达指定具体的频控对象</span></span><br><span class="line"><span class="comment">     * 对于ip 和uid模式，需要是http入口的对象，保证RequestHolder里有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Target <span class="title function_">target</span><span class="params">()</span> <span class="keyword">default</span> Target.EL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * springEl 表达式，target=EL必填</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">spEl</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 频控时间范围，默认单位秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">time</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 频控时间单位，默认秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TimeUnit <span class="title function_">unit</span><span class="params">()</span> <span class="keyword">default</span> TimeUnit.SECONDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单位时间内最大访问次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">        UID, IP, EL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>@Repeatable(FrequencyControlContainer.class)&#x2F;&#x2F;可重复</strong></li>
</ul>
<p>代表的&#x3D;&#x3D;该注解可以重复使用在同一声明上&#x3D;&#x3D;。意味着一个方法上可以有&#x3D;&#x3D;多个FrequencyControl注解&#x3D;&#x3D;，它们会被收集到一个&#x3D;&#x3D;FrequencyControlContainer容器中&#x3D;&#x3D;，方便统一管理。</p>
<ul>
<li><strong>@Retention(RetentionPolicy.RUNTIME)</strong>: &#x3D;&#x3D;指定该注解在运行时仍然有效&#x3D;&#x3D;。这意味着&#x3D;&#x3D;可以通过反射机制在程序运行过程中读取到这个注解信息&#x3D;&#x3D;，这对于需要在运行时动态检查或应用注解信息的场景至关重要。</li>
<li><strong>@Target(ElementType.METHOD)&#x2F;&#x2F;作用在方法上</strong></li>
<li><strong>prefixKey()</strong>: 定义了频控key的前缀，默认为空字符串。</li>
<li><strong>target()</strong>: 定义了频控的目标对象，可以是<code>UID</code>(用户ID)、<code>IP</code>(客户端IP地址)或<code>EL</code>(基于Spring Expression Language的自定义表达式)，默认为<code>EL</code></li>
<li><strong>spEl()</strong>: 当<code>target</code>设置为<code>EL</code>时，需要通过这个属性指定Spring EL表达式来动态确定频控的对象，例如从请求上下文中提取用户ID等信息。</li>
<li><strong>time()</strong>: 指定了频控的时间范围，默认单位是秒。</li>
<li><strong>unit()</strong>: 允许自定义时间单位，默认为<code>TimeUnit.SECONDS</code>（秒）。</li>
<li><strong>count()</strong>: 设定在上述时间范围内允许的最大调用次数。</li>
<li><strong>enum Target</strong>: 内嵌枚举类型，定义了频控目标的三种模式：基于用户ID (<code>UID</code>)、基于IP地址 (<code>IP</code>) 以及基于自定义Spring EL表达式的模式 (<code>EL</code>)。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.abin.mallchat.common.common.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//运行时生效</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//作用在方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FrequencyControlContainer &#123;</span><br><span class="line">    FrequencyControl[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注解内部定义了一个方法value，返回一个FrequencyControl [] 数组。这个方法是注解容器的核心，因为它存储了所有收集到的FrequencyControl注解。当一个类或方法（如果按照@Target(ElementType.METHOD)）上应用了多个FrequencyControl注解时，这些注解实例就会通过<code>value</code>方法自动聚合到FrequencyControlContainer中</p>
</blockquote>
<pre><code>总结来说，==FrequencyControlContainer注解作为一个容器==，使得可以在==一个类或接口上应用多个FrequencyControl注解==，==并通过value方法以数组的方式收集这些注解==，便于==程序在运行时通过反射机制一次性获取并处理所有关联的频率====控制配置==。
</code></pre>
<blockquote>
<p>关键就在于&#x3D;&#x3D;<code>@Repeatable</code>可重复的配置&#x3D;&#x3D;，这样就可以把相同注解加在一个方法上，这猜测是一个语法糖。</p>
<p>其中&#x3D;&#x3D;频控对象对应的就是redis中的一个key&#x3D;&#x3D;，&#x3D;&#x3D;所以也需要<code>prefixKey</code>参数和el表达式<code>spEl</code>参数&#x3D;&#x3D;。</p>
<p><code>time</code>和<code>unit</code>控制统计的时间范围，<code>count</code>是次数。</p>
<p>为啥还有个<code>target</code>呢？</p>
<p>&#x3D;&#x3D;我们的频控大多是用在接口上的&#x3D;&#x3D;，&#x3D;&#x3D;并&#x3D;&#x3D;&#x3D;&#x3D;且接口拦截器会解析出用户的ip和uid&#x3D;&#x3D;。而很多的场景是直接对uid或者ip做频率控制的。针对这种情况，我们指定了uid后，连el表达式都可以不用写了，切面会自动从上下文中获取uid，让注解的实现更加简洁。</p>
</blockquote>
<p><strong>切面</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.abin.mallchat.common.common.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.abin.mallchat.common.common.annotation.FrequencyControl;</span><br><span class="line"><span class="keyword">import</span> com.abin.mallchat.common.common.domain.dto.FrequencyControlDTO;</span><br><span class="line"><span class="keyword">import</span> com.abin.mallchat.common.common.service.frequencycontrol.FrequencyControlUtil;</span><br><span class="line"><span class="keyword">import</span> com.abin.mallchat.common.common.utils.RequestHolder;</span><br><span class="line"><span class="keyword">import</span> com.abin.mallchat.common.common.utils.SpElUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.abin.mallchat.common.common.service.frequencycontrol.FrequencyControlStrategyFactory.TOTAL_COUNT_WITH_IN_FIX_TIME_FREQUENCY_CONTROLLER;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 频控实现</span></span><br><span class="line"><span class="comment"> * Author: tfy</span></span><br><span class="line"><span class="comment"> * Date: 2023-04-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrequencyControlAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.abin.mallchat.common.common.annotation.FrequencyControl)||@annotation(com.abin.mallchat.common.common.annotation.FrequencyControlContainer)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ((MethodSignature) joinPoint.getSignature()).getMethod();</span><br><span class="line">        <span class="comment">//获取当前method对象</span></span><br><span class="line">        FrequencyControl[] annotationsByType = method.getAnnotationsByType(FrequencyControl.class);</span><br><span class="line">        <span class="comment">//获取FrequencyControl注解</span></span><br><span class="line">        Map&lt;String, FrequencyControl&gt; keyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; annotationsByType.length; i++) &#123;</span><br><span class="line">            <span class="type">FrequencyControl</span> <span class="variable">frequencyControl</span> <span class="operator">=</span> annotationsByType[i];</span><br><span class="line">            <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> StrUtil.isBlank(frequencyControl.prefixKey()) ? SpElUtils.getMethodKey(method) + <span class="string">&quot;:index:&quot;</span> + i : frequencyControl.prefixKey();<span class="comment">//默认方法限定名+注解排名（可能多个）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">switch</span> (frequencyControl.target()) &#123;</span><br><span class="line">                <span class="keyword">case</span> EL:</span><br><span class="line">                    key = SpElUtils.parseSpEl(method, joinPoint.getArgs(), frequencyControl.spEl());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> IP:</span><br><span class="line">                    key = RequestHolder.get().getIp();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UID:</span><br><span class="line">                    key = RequestHolder.get().getUid().toString();</span><br><span class="line">            &#125;</span><br><span class="line">            keyMap.put(prefix + <span class="string">&quot;:&quot;</span> + key, frequencyControl);</span><br><span class="line">            <span class="comment">//默认方法限定名+注解排名（可能多个）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将注解的参数转换为编程式调用需要的参数</span></span><br><span class="line">        List&lt;FrequencyControlDTO&gt; frequencyControlDTOS = keyMap.entrySet().stream().map(entrySet -&gt; buildFrequencyControlDTO(entrySet.getKey(), entrySet.getValue())).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//将注解中的频率数、时间、单位、key提取出来做成链表</span></span><br><span class="line">        <span class="comment">// 调用编程式注解</span></span><br><span class="line">        <span class="keyword">return</span> FrequencyControlUtil.executeWithFrequencyControlList(TOTAL_COUNT_WITH_IN_FIX_TIME_FREQUENCY_CONTROLLER, frequencyControlDTOS, joinPoint::proceed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将注解参数转换为编程式调用所需要的参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key              频率控制Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frequencyControl 注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编程式调用所需要的参数-FrequencyControlDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FrequencyControlDTO <span class="title function_">buildFrequencyControlDTO</span><span class="params">(String key, FrequencyControl frequencyControl)</span> &#123;</span><br><span class="line">        <span class="type">FrequencyControlDTO</span> <span class="variable">frequencyControlDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FrequencyControlDTO</span>();</span><br><span class="line">        frequencyControlDTO.setCount(frequencyControl.count());</span><br><span class="line">        frequencyControlDTO.setTime(frequencyControl.time());</span><br><span class="line">        frequencyControlDTO.setUnit(frequencyControl.unit());</span><br><span class="line">        frequencyControlDTO.setKey(key);</span><br><span class="line">        <span class="keyword">return</span> frequencyControlDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 限流策略定义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linzhihan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/07/03</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrequencyControlDTO</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表频控的Key 如果target为Key的话 这里要传值用于构建redis的Key target为Ip或者UID的话会从上下文取值 Key字段无需传值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 频控时间范围，默认单位秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 频控时间单位，默认秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit unit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单位时间内最大访问次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	做了一个限流策略定义</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限流策略工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linzhihan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/07/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrequencyControlStrategyFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定时间内总次数限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOTAL_COUNT_WITH_IN_FIX_TIME_FREQUENCY_CONTROLLER</span> <span class="operator">=</span> <span class="string">&quot;TotalCountWithInFixTime&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流策略集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, AbstractFrequencyControlService&lt;?&gt;&gt; frequencyControlServiceStrategyMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将策略类放入工厂</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategyName                    策略名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> abstractFrequencyControlService 策略类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K <span class="keyword">extends</span> <span class="title class_">FrequencyControlDTO</span>&gt; <span class="keyword">void</span> <span class="title function_">registerFrequencyController</span><span class="params">(String strategyName, AbstractFrequencyControlService&lt;K&gt; abstractFrequencyControlService)</span> &#123;</span><br><span class="line">        frequencyControlServiceStrategyMap.put(strategyName, abstractFrequencyControlService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称获取策略类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategyName 策略名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的限流策略类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K <span class="keyword">extends</span> <span class="title class_">FrequencyControlDTO</span>&gt; AbstractFrequencyControlService&lt;K&gt; <span class="title function_">getFrequencyControllerByName</span><span class="params">(String strategyName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (AbstractFrequencyControlService&lt;K&gt;) frequencyControlServiceStrategyMap.get(strategyName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">FrequencyControlStrategyFactory</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>只需要记住redis实现频控有三种选择，固定时间、滑动窗口、令牌桶</p>
</blockquote>
<blockquote>
<p>Redis可以用来实现流量控制（频控）的三种常见方法分别是固定时间窗口、滑动窗口和令牌桶算法。每种方法各有特点，适用于不同的场景。下面是对这三种方法的简要讲解：</p>
<h3 id="1-固定时间窗口（Fixed-Time-Window）"><a href="#1-固定时间窗口（Fixed-Time-Window）" class="headerlink" title="1. 固定时间窗口（Fixed Time Window）"></a>1. 固定时间窗口（Fixed Time Window）</h3><p><strong>原理</strong>：<br>&#x3D;&#x3D;固定时间窗口将时间划分为一系列固定长度的时间段，比如每分钟、每小时等。在每个时间窗口内，限制请求的数量&#x3D;&#x3D;。&#x3D;&#x3D;一旦窗口过期，计数器重置，开始新的窗口&#x3D;&#x3D;。这种方法简单易实现，&#x3D;&#x3D;但存在“突刺”问题，即在窗口即将重置时，如果请求集中到达，可能会瞬间超出限制，而在窗口初期则可能浪费了未使用的配额&#x3D;&#x3D;。</p>
<p><strong>实现</strong>：<br>可以使用&#x3D;&#x3D;Redis的字符串（String）类型或哈希（Hash）类型来存储每个窗口的计数&#x3D;&#x3D;。例如，&#x3D;&#x3D;键&#x3D;&#x3D;可以是&#x3D;&#x3D;<code>freq_control:&lt;window_start_time&gt;</code>，值是请求计数&#x3D;&#x3D;。</p>
<h3 id="2-滑动窗口（Sliding-Window）"><a href="#2-滑动窗口（Sliding-Window）" class="headerlink" title="2. 滑动窗口（Sliding Window）"></a>2. 滑动窗口（Sliding Window）</h3><p><strong>原理</strong>：<br>&#x3D;&#x3D;滑动窗口也是一种时间窗口策略&#x3D;&#x3D;，但它不是固定的，而是随着时间滑动的。窗口大小固定，但随着时间推移不断向前滑动，始终包含最近一段时间内的请求。这种方法更平滑，能更好地应对请求分布不均的问题，避免了“突刺”。</p>
<p><strong>实现</strong>：<br>&#x3D;&#x3D;常用Redis的有序集合（Sorted Set，ZSet）来实现&#x3D;&#x3D;。成员是&#x3D;&#x3D;请求的时间戳（Unix时间戳），分值也是时间戳&#x3D;&#x3D;，这样可以利用&#x3D;&#x3D;ZSet的排序特性来快速判断哪些请求超出了窗口范围&#x3D;&#x3D;。当有新请求时，&#x3D;&#x3D;首先移除窗口外的旧请求&#x3D;&#x3D;，然后加入新请求并检查是否超过了限制。</p>
<h3 id="3-令牌桶算法（Token-Bucket）"><a href="#3-令牌桶算法（Token-Bucket）" class="headerlink" title="3. 令牌桶算法（Token Bucket）"></a>3. 令牌桶算法（Token Bucket）</h3><p><strong>原理</strong>：<br>&#x3D;&#x3D;令牌桶算法预先填充一定数量的令牌，按照固定速率持续向桶中添加令牌。每次请求需要消耗一个令牌。&#x3D;&#x3D;如果桶中&#x3D;&#x3D;有足够的令牌，则请求被允许；否则，请求被拒绝或延迟。&#x3D;&#x3D;令牌桶可以平滑突发请求，&#x3D;&#x3D;允许短时间内的突发流量&#x3D;&#x3D;，同时保证了整体的请求速率不超过设定的上限。</p>
<p><strong>实现</strong>：<br>在Redis中，&#x3D;&#x3D;可以使用列表（List）或者字符串（String）来模拟令牌桶&#x3D;&#x3D;。例如，&#x3D;&#x3D;使用一个列表作为令牌池，每次请求时从列表左侧弹出一个令牌（使用<code>LPOP</code>命令），并定期向列表右侧添加令牌（使用<code>RPUSH</code>命令）。&#x3D;&#x3D;另一种方法是使用字符串的自增和自减操作来模拟令牌数量的变化。</p>
<p>每种方法都有其适用场景：</p>
<ul>
<li><strong>固定时间窗口</strong>适合于&#x3D;&#x3D;对请求均匀性要求不高的简单限流场景&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;<strong>滑动窗口</strong>适用于需要更精确控制请求频率&#x3D;&#x3D;，尤其是&#x3D;&#x3D;应对请求分布不均匀&#x3D;&#x3D;的场景。</li>
<li>&#x3D;&#x3D;<strong>令牌桶算法</strong>适用于需要允许一定程度突发流量&#x3D;&#x3D;，同时长期保持平均速率稳定的场景。</li>
</ul>
</blockquote>
<h2 id="2-线程池问题"><a href="#2-线程池问题" class="headerlink" title="2.线程池问题"></a>2.线程池问题</h2><h3 id="1-如何根据业务的需求去设置线程池的大小"><a href="#1-如何根据业务的需求去设置线程池的大小" class="headerlink" title="1.如何根据业务的需求去设置线程池的大小"></a>1.如何根据业务的需求去设置线程池的大小</h3><blockquote>
<p> 1.判断任务是CPU密集型还是IO密集型，cpu密集型的话是不建议超过cpu的核心数的，否则会造成大量的上下文切换</p>
<p> IO密集型，由于存在等待操作，cpu利用率比较低 ，可以设置更多的限速数量，</p>
<p> 2.从系统资源角度来评估，一般来说线程池的核心线程数量可以设置为cpu核心数+1（+1是因为可能存在页缺失，就是可能存在有些数据在硬盘中需要多一个线程来将数据读入内存），或者核心数乘以2，具体的根据任务类型来确定</p>
<p> 3.对于混合型任务可以使用这样一个公式</p>
<p> <img src="/.io//image-20240715221123379.png" alt="image-20240715221123379"></p>
<p> 来进行计算</p>
<p> 4.由于实际业务场景，涉及到计算任务比较复杂，一般会通过压力测试来观察系统的吞吐量、响应时间、资源使用情况来逐步调整显现实的大小，直到找到最优的配置</p>
</blockquote>
<h3 id="2-当提交的任务抛出未捕获的异常的时候，线程池是如何处理这些异常的呢"><a href="#2-当提交的任务抛出未捕获的异常的时候，线程池是如何处理这些异常的呢" class="headerlink" title="2.当提交的任务抛出未捕获的异常的时候，线程池是如何处理这些异常的呢"></a>2.当提交的任务抛出未捕获的异常的时候，线程池是如何处理这些异常的呢</h3><blockquote>
<p>如果没有特别的配置呢，线程池会把这个异常，直接往外抛，调用者线程可以收到这个异常信息，不过线程池里面提供了两个提交任务的方法，分别是submit和execute，其中submit方法需要调用get方法，才能获取线程池中抛出的异常信息，而在实际开发控制中推荐使用线程池里面提供的Thread.setDefaultUncaughtExceptionHandler ，这两个方法的添加全面的异常处理逻辑，确保即使任务失败，也能够优雅地处理异常，比如说记录详细的错误日志，方便后续做问题的跟踪和监控</p>
</blockquote>
<h3 id="3-假设有一个需要极高吞吐量的并且任务处理时间差异较大的系统，你会选择哪种类型的队列并解释可能的优化措施"><a href="#3-假设有一个需要极高吞吐量的并且任务处理时间差异较大的系统，你会选择哪种类型的队列并解释可能的优化措施" class="headerlink" title="3.假设有一个需要极高吞吐量的并且任务处理时间差异较大的系统，你会选择哪种类型的队列并解释可能的优化措施"></a>3.假设有一个需要极高吞吐量的并且任务处理时间差异较大的系统，你会选择哪种类型的队列并解释可能的优化措施</h3><blockquote>
<p>这种情况下，建议使用有界并发队列，比如说：LinkedBlockingQueue，并且设置一个相对合理的容量上限</p>
<p>第一：有界队列可以限制系统中等待任务的数量避免无限制消耗内存，导致内存溢出</p>
<p>第二：对于处理时间差异比较大的任务，有界队列可以帮助线程池平衡负载，当队列满的时候可以根据拒绝策略做后续的处理，比如说采用CallerRunsPolicy，这样一个策略就可以临时增加处理能力，而对于这个场景的优化措施，大概有三个方向可以切入：</p>
<ol>
<li>通过监控线程池的容量来动态调整工程线程的数量</li>
<li>可以采用多级队列策略，比如说优先级队列确保关键任务的优先处理能力</li>
<li>对于短小和相似的任务，可以考虑对任务合并，减少上下文切换和队列交互的成本</li>
</ol>
</blockquote>
<h3 id="4-在一个长生命周期的应用中如何确保线程池能够有效管理和关闭从而避免资源泄漏"><a href="#4-在一个长生命周期的应用中如何确保线程池能够有效管理和关闭从而避免资源泄漏" class="headerlink" title="4.在一个长生命周期的应用中如何确保线程池能够有效管理和关闭从而避免资源泄漏"></a>4.在一个长生命周期的应用中如何确保线程池能够有效管理和关闭从而避免资源泄漏</h3><blockquote>
<p>1.尽量不要去创建静态线程池，因为这样会导致线程池一直活着，资源无法释放，如果确实需要全局访问，可以考虑使用SpringIOC来去管理线程池的声明周期</p>
<p>2.对于一些短声明周期的任务处理可以在任务结束以后调用shutdown方法或者shutdownNow（）方法来主动关闭线程池</p>
<p>3.通过实现Spring框架中的DisableBean接口或者@PreDestroy注解实现自动清理操作</p>
</blockquote>
<h2 id="3-线程"><a href="#3-线程" class="headerlink" title="3.线程"></a>3.线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:tfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>:2024/07/16/10:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadTest.<span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>.MyThread();</span><br><span class="line">        RunnableTest.<span class="type">Runtest</span> <span class="variable">runtest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTest</span>.Runtest();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runtest).start();</span><br><span class="line">        myThread.start();</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CallerTest</span>.CallerTask());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> task.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:tfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>:2024/07/16/10:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;callable&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:tfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>:2024/07/16/10:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Runtest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Runable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:tfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>:2024/07/16/10:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;!!!!!!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-wait和notify以及notifyAll"><a href="#1-wait和notify以及notifyAll" class="headerlink" title="1.wait和notify以及notifyAll"></a>1.wait和notify以及notifyAll</h3><blockquote>
<p><strong>1.&#x3D;&#x3D;wait、notify以及notifyAll都是Object对象的方法&#x3D;&#x3D;，他们必须在&#x3D;&#x3D;被 synchronized 同步的方法或代码块中调用&#x3D;&#x3D;，否则会报错。</strong></p>
<p><strong>2.调用wait方法会使该线程&#x3D;&#x3D;进入等待状态&#x3D;&#x3D;，&#x3D;&#x3D;并且会释放被同步对象的锁。（立即）&#x3D;&#x3D;</strong></p>
<p><strong>3.&#x3D;&#x3D;notify操作&#x3D;&#x3D;可以&#x3D;&#x3D;唤醒一个因执行wait而处于阻塞状态的线程&#x3D;&#x3D;，&#x3D;&#x3D;使其进入就绪状态&#x3D;&#x3D;，&#x3D;&#x3D;被唤醒的线程会去尝试着获取对象锁，然后执行wait之后的代码&#x3D;&#x3D;。如果&#x3D;&#x3D;发出notify操作时，没有线程处于阻塞状态，那么该命令会忽略&#x3D;&#x3D;。注意&#x3D;&#x3D;执行notify并不会马上释放对象锁&#x3D;&#x3D;，会等到&#x3D;&#x3D;执行完该同步方法或同步代码块后才释放&#x3D;&#x3D;，下面会有例子来证明</strong></p>
<p>notify方法可以随机唤醒等待队列中等待同一共享资源的“一个”线程，使其退出等待队列进入可运行状态。</p>
<p><strong>4&#x3D;&#x3D;.notifyAll方法可以唤醒等待队列&#x3D;&#x3D;中&#x3D;&#x3D;等待同一共享资源的“全部”线程从等待状态退出&#x3D;&#x3D;，进入可运行状态。此时，&#x3D;&#x3D;优先级最高的那个线程优先执行，但也有可能是随机执行&#x3D;&#x3D;，这取决于JVM虚拟机的实现</strong></p>
<p>测试在调用notify方法之后并不会马上释放对象锁，而是在执行完同步方法或同步方法块的时候才会释放。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;sth&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main方法以及两个线程类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">ThreadA</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(lock);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ta);</span><br><span class="line">        </span><br><span class="line">        tta.start();</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ThreadB</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>(lock);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">ttb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tb);</span><br><span class="line">        ttb.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Object mLock;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(Object lock)</span>&#123;</span><br><span class="line">        mLock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span>(MyList.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;before wait&quot;</span>);</span><br><span class="line">                    mLock.wait();</span><br><span class="line">                    System.out.println(<span class="string">&quot;after wait&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Object mLock;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(Object lock)</span>&#123;</span><br><span class="line">        mLock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                MyList.add();</span><br><span class="line">                <span class="keyword">if</span>(MyList.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                    mLock.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;已发出notify通知&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;增加&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;同步方法之外的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">before wait</span><br><span class="line">增加<span class="number">1</span>条数据</span><br><span class="line">增加<span class="number">2</span>条数据</span><br><span class="line">增加<span class="number">3</span>条数据</span><br><span class="line">增加<span class="number">4</span>条数据</span><br><span class="line">已发出notify通知</span><br><span class="line">增加<span class="number">5</span>条数据</span><br><span class="line">增加<span class="number">6</span>条数据</span><br><span class="line">增加<span class="number">7</span>条数据</span><br><span class="line">增加<span class="number">8</span>条数据</span><br><span class="line">增加<span class="number">9</span>条数据</span><br><span class="line">增加<span class="number">10</span>条数据</span><br><span class="line">after wait</span><br><span class="line">同步方法之外的方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出两点</p>
<p>1.执行&#x3D;&#x3D;wait方法后会立马释放对象锁&#x3D;&#x3D;</p>
<p>2.执行&#x3D;&#x3D;notify不会立马释放对象锁&#x3D;&#x3D;，需等&#x3D;&#x3D;该同步方法或同步块执行完&#x3D;&#x3D;。注意是同步的内容执行完，而&#x3D;&#x3D;不是该线程的run方法执行完&#x3D;&#x3D;，从结果最后2句可以看出来</p>
<p>最后说下 wait和sleep的区别，这也是面试经常面到的问题。</p>
<p><strong>1.sleep是Thread类的方法而wait是Object类的方法。</strong></p>
<p><strong>2.sleep不会立马释放对象锁，而wait会释放。</strong></p>
<p>写个小栗子来证明结论2：<br>在MyList类中增加一个方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Thrad name : &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; , begain doSth time : &quot;</span>+System.currentTimeMillis());</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;Thrad name : &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; , end doSth time : &quot;</span>+System.currentTimeMillis());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyList</span> <span class="variable">myList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyList</span>();</span><br><span class="line"><span class="type">ThreadC</span> <span class="variable">tc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadC</span>(myList);</span><br><span class="line">tc.setName(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="type">ThreadD</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadD</span>(myList);</span><br><span class="line">td.setName(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">tc.start();</span><br><span class="line">td.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ThreadC和ThreadD类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadC</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyList myList;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadC</span><span class="params">(MyList mlist)</span>&#123;</span><br><span class="line">        myList = mlist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        myList.doSth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadD</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyList myList;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadD</span><span class="params">(MyList mlist)</span>&#123;</span><br><span class="line">        myList = mlist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        myList.doSth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thrad name : C , begain doSth time : <span class="number">1487647524673</span></span><br><span class="line">Thrad name : C , end doSth time : <span class="number">1487647527674</span></span><br><span class="line">Thrad name : D , begain doSth time : <span class="number">1487647527674</span></span><br><span class="line">Thrad name : D , end doSth time : <span class="number">1487647530674</span></span><br></pre></td></tr></table></figure>

<p>可以看出线程C在调用sleep方法后并不会释放。</p>
<p>最后作点说明：<br>每个锁对象都有两个队列，&#x3D;&#x3D;就绪队列以及阻塞队列&#x3D;&#x3D;。&#x3D;&#x3D;就绪队列存储了将要获得锁的线程&#x3D;&#x3D;，&#x3D;&#x3D;阻塞队列存储了被阻塞的线程&#x3D;&#x3D;。&#x3D;&#x3D;一个线程被唤醒后，才会进入就绪队列，以等待CPU调度&#x3D;&#x3D;。&#x3D;&#x3D;反之一个线程被wait后就会进入阻塞队列，等待下一次唤醒&#x3D;&#x3D;。 也就是说一个线程被wait后会进入阻塞队列，&#x3D;&#x3D;待调用了 notify或notifyAll之后，该线程就会进入就绪队列&#x3D;&#x3D;。</p>
<p><img src="/.io//image-20240716152725842.png" alt="image-20240716152725842"></p>
<p><img src="/.io//image-20240716152741562.png" alt="image-20240716152741562"></p>
<p><img src="/.io//image-20240716152751761.png" alt="image-20240716152751761"></p>
<p><img src="/.io//image-20240716153832398.png" alt="image-20240716153832398"></p>
<p><img src="/.io//image-20240716153848340.png" alt="image-20240716153848340"></p>
<h2 id="4-二级缓存的实现还有缓存同步问题"><a href="#4-二级缓存的实现还有缓存同步问题" class="headerlink" title="4.二级缓存的实现还有缓存同步问题"></a>4.二级缓存的实现还有缓存同步问题</h2><h2 id="5-什么是延迟双删"><a href="#5-什么是延迟双删" class="headerlink" title="5.什么是延迟双删"></a>5.什么是延迟双删</h2><h2 id="6-JUC"><a href="#6-JUC" class="headerlink" title="6.JUC"></a>6.JUC</h2><h3 id="1-什么是进程线程"><a href="#1-什么是进程线程" class="headerlink" title="1.什么是进程线程"></a>1.什么是进程线程</h3><p><img src="/.io//image-20240806203851001.png" alt="image-20240806203851001"></p>
<p><img src="/.io//image-20240806204120286.png" alt="image-20240806204120286"></p>
<p><img src="/.io//image-20240806204302897.png" alt="image-20240806204302897"></p>
<p><img src="/.io//image-20240806204434144.png" alt="image-20240806204434144"></p>
<h3 id="2-线程与进程的关系，区别及优缺点？"><a href="#2-线程与进程的关系，区别及优缺点？" class="headerlink" title="2.线程与进程的关系，区别及优缺点？"></a>2.线程与进程的关系，区别及优缺点？</h3><img src="/.io//image-20240806204555514.png" alt="image-20240806204555514" style="zoom:67%;">

<p><img src="/.io//image-20240806204654995.png" alt="image-20240806204654995"></p>
<p><img src="/.io//image-20240806204954441.png" alt="image-20240806204954441"></p>
<p><img src="/.io//image-20240806205047238.png" alt="image-20240806205047238"></p>
<h3 id="3-创建线程？"><a href="#3-创建线程？" class="headerlink" title="3.创建线程？"></a>3.创建线程？</h3><p><img src="/.io//image-20240806205129956.png" alt="image-20240806205129956"></p>
<p><img src="/.io//image-20240806205213200.png" alt="image-20240806205213200"></p>
<p><img src="/.io//image-20240806205308061.png" alt="image-20240806205308061"></p>
<p><img src="/.io//image-20240806205515822.png" alt="image-20240806205515822"></p>
<p><img src="/.io//image-20240806205555410.png" alt="image-20240806205555410"></p>
<h3 id="4-什么是线程上下文切换？"><a href="#4-什么是线程上下文切换？" class="headerlink" title="4.什么是线程上下文切换？"></a>4.什么是线程上下文切换？</h3><p><img src="/.io//image-20240806205744667.png" alt="image-20240806205744667"></p>
<h3 id="5-Thread-sleep-方法和-Object-wait-方法对比"><a href="#5-Thread-sleep-方法和-Object-wait-方法对比" class="headerlink" title="5.Thread#sleep() 方法和 Object#wait() 方法对比"></a>5.<a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#thread-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-object-wait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94">Thread#sleep() 方法和 Object#wait() 方法对比</a></h3><p><img src="/.io//image-20240806205915922.png" alt="image-20240806205915922"></p>
<p><img src="/.io//image-20240806205955550.png" alt="image-20240806205955550"></p>
<p><img src="/.io//image-20240806210042625.png" alt="image-20240806210042625"></p>
<blockquote>
<p>在Java中，<code>Thread</code> 类提供了一种创建和管理线程的方式。当你创建一个 <code>Thread</code> 对象并调用其 <code>run</code> 方法时，与直接调用 <code>start</code> 方法相比，行为有所不同。下面是这两种方法之间的主要区别：</p>
<h3 id="1-直接调用-run-方法"><a href="#1-直接调用-run-方法" class="headerlink" title="1. 直接调用 run 方法"></a>1. 直接调用 run 方法</h3><p>当你直接调用 <code>run</code> 方法时，它就像调用任何其他普通方法一样，在当前线程中执行。这意味着 <code>run</code> 方法会在调用它的线程中运行，而不是在新的线程中运行。这不会创建一个新的线程，因此不算是多线程编程。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>().<span class="keyword">new</span> <span class="title class_">MyRunnableThread</span>();</span><br><span class="line">     thread.run(); <span class="comment">// 直接调用run方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Running in &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出将会显示 <code>main</code> 线程的名字，因为 <code>run</code> 方法是在 <code>main</code> 线程中执行的。</p>
<h3 id="2-使用-start-方法"><a href="#2-使用-start-方法" class="headerlink" title="2. 使用 start 方法"></a>2. 使用 start 方法</h3><p>当你调用 <code>start</code> 方法时，它会启动一个新的线程，并在这个新线程中调用 <code>run</code> 方法。这使得 <code>run</code> 方法能够在独立的线程中执行，从而实现了真正的多线程编程。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>().<span class="keyword">new</span> <span class="title class_">MyRunnableThread</span>();</span><br><span class="line">     thread.start(); <span class="comment">// 使用start方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Running in &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出将会显示新线程的名字，因为 <code>run</code> 方法是在新线程中执行的。</p>
<h3 id="为什么-start-方法能够启动新线程"><a href="#为什么-start-方法能够启动新线程" class="headerlink" title="为什么 start 方法能够启动新线程"></a>为什么 start 方法能够启动新线程</h3><p><code>start</code> 方法内部做了以下几件事情：</p>
<ol>
<li>它检查是否已经有一个线程与当前 <code>Thread</code> 对象关联。</li>
<li>如果没有关联的线程，它会创建一个新的线程，并将当前 <code>Thread</code> 对象与这个新线程关联起来。</li>
<li>它调用新线程的 <code>start0</code> 方法，这是一个本地方法，负责启动线程并在新线程中调用 <code>run</code> 方法。</li>
<li><code>start0</code> 方法是 <code>Thread</code> 类中的一个本地方法，它是由 JVM 实现的，并且负责实际的线程启动。</li>
</ol>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>直接调用 <code>run</code> 方法</strong>：这不会启动新的线程，而是在当前线程中执行 <code>run</code> 方法。</li>
<li><strong>调用 <code>start</code> 方法</strong>：这会启动一个新的线程，并在新线程中调用 <code>run</code> 方法，实现了多线程编程。</li>
</ul>
<p>因此，如果你想创建一个新的线程并使其并发执行，你应该调用 <code>start</code> 方法而不是直接调用 <code>run</code> 方法。</p>
</blockquote>
<h3 id="6-多线程"><a href="#6-多线程" class="headerlink" title="6.多线程"></a>6.多线程</h3><p><img src="/.io//image-20240806210512145.png" alt="image-20240806210512145"></p>
<p><img src="/.io//image-20240806210644870.png" alt="image-20240806210644870"></p>
<p><img src="/.io//image-20240806210801733.png" alt="image-20240806210801733"></p>
<p><img src="/.io//image-20240806210942447.png" alt="image-20240806210942447"></p>
<p><img src="/.io//image-20240806211045429.png" alt="image-20240806211045429"></p>
<h3 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁"></a>7.死锁</h3><p><img src="/.io//image-20240806211248378.png" alt="image-20240806211248378"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Output</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240806211548016.png" alt="image-20240806211548016"></p>
<p><img src="/.io//image-20240806211658103.png" alt="image-20240806211658103"></p>
<p><img src="/.io//image-20240806211745911.png" alt="image-20240806211745911"></p>
<p><img src="/.io//image-20240806211944277.png" alt="image-20240806211944277"></p>
<p><img src="/.io//image-20240806211959816.png" alt="image-20240806211959816"></p>
<h3 id="8-volatile"><a href="#8-volatile" class="headerlink" title="8.volatile"></a>8.volatile</h3><p><img src="/.io//image-20240806212858743.png" alt="image-20240806212858743"></p>
<p><img src="/.io//jmm.png" alt="JMM(Java 内存模型)"></p>
<p><img src="/.io//jmm2.png" alt="JMM(Java 内存模型)强制在主存中进行读取"></p>
<p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>
<p><img src="/.io//image-20240806213136995.png" alt="image-20240806213136995"></p>
<p><img src="/.io//image-20240806213319525.png" alt="image-20240806213319525"></p>
<p><img src="/.io//image-20240806213436274.png" alt="image-20240806213436274"></p>
<p><img src="/.io//image-20240806213531245.png" alt="image-20240806213531245"></p>
<p><img src="/.io//image-20240806213612798.png" alt="image-20240806213612798"></p>
<h3 id="9-乐观锁和悲观锁"><a href="#9-乐观锁和悲观锁" class="headerlink" title="9.乐观锁和悲观锁"></a>9.乐观锁和悲观锁</h3><p><img src="/.io//image-20240806213756431.png" alt="image-20240806213756431"></p>
<p>之所以大量阻塞线程会导致系统的上下文切换，是因为可用的线程变少了，增加了调度的难度</p>
<p><img src="/.io//image-20240806214128670.png" alt="image-20240806214128670"></p>
<p><img src="/.io//image-20240806214204698.png" alt="image-20240806214204698"></p>
<p><img src="/.io//image-20240806214315797.png" alt="image-20240806214315797"></p>
<p><img src="/.io//image-20240806214350681.png" alt="image-20240806214350681"></p>
<p><img src="/.io//image-20240806214432764.png" alt="image-20240806214432764"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  CAS</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o         包含要修改field的对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> offset    对象中某field的偏移量</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> expected  期望值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> update    更新值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>          true | false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,  Object expected, Object update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected,<span class="type">int</span> update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240806214535891.png" alt="image-20240806214535891"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式更新对象字段的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o        要操作的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset   对象字段的内存偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected 期望的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x        要设置的新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果值被成功更新，则返回 true；否则返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object expected, Object x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式更新 int 类型的对象字段的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式更新 long 类型的对象字段的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> x)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240806214625864.png" alt="image-20240806214625864"></p>
<p><img src="/.io//image-20240806214649864.png" alt="image-20240806214649864"></p>
<p><img src="/.io//image-20240806214741836.png" alt="image-20240806214741836"></p>
<p><img src="/.io//image-20240806214815645.png" alt="image-20240806214815645"></p>
<p><img src="/.io//image-20240806214831024.png" alt="image-20240806214831024"></p>
<p><img src="/.io//image-20240806215121986.png" alt="image-20240806215121986"></p>
<h3 id="10-synchronized"><a href="#10-synchronized" class="headerlink" title="10.synchronized"></a>10.synchronized</h3><p><img src="/.io//image-20240806215317518.png" alt="image-20240806215317518"></p>
<p><img src="/.io//image-20240806215431769.png" alt="image-20240806215431769"></p>
<p><img src="/.io//image-20240806215501665.png" alt="image-20240806215501665"></p>
<blockquote>
<p>为什么构造方法不能使用synchronized关键字来修饰，因为这个时候的对象尚未完全构建，这个时候使用并没有实际的意义</p>
</blockquote>
<p><img src="/.io//image-20240806215734191.png" alt="image-20240806215734191"></p>
<p><img src="/.io//synchronized-principle.png" alt="synchronized关键字原理"></p>
<p><img src="/.io//image-20240806215927498.png" alt="image-20240806215927498"></p>
<img src="/.io//synchronized-get-lock-code-block.png" alt="执行 monitorenter 获取锁" style="zoom: 67%;">



<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<img src="/.io//synchronized-release-lock-block.png" alt="执行 monitorexit 释放锁" style="zoom: 80%;">

<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%9A%84%E6%83%85%E5%86%B5">synchronized 修饰方法的的情况</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png" alt="synchronized关键字原理"></p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁</p>
<h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a><a href="#%E6%80%BB%E7%BB%93">总结</a></h4><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p>&#x3D;&#x3D;<code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。&#x3D;&#x3D;</p>
<p><img src="/.io//image-20240806220440891.png" alt="image-20240806220440891"></p>
<h3 id="11-ReentrantLock"><a href="#11-ReentrantLock" class="headerlink" title="11.ReentrantLock"></a>11.ReentrantLock</h3><p><img src="/.io//image-20240806220614528.png" alt="image-20240806220614528"></p>
<p><img src="/.io//image-20240806220635584.png" alt="image-20240806220635584"></p>
<h3 id="12-synchronized和ReentrantLock有什么区别？"><a href="#12-synchronized和ReentrantLock有什么区别？" class="headerlink" title="12.synchronized和ReentrantLock有什么区别？"></a>12.synchronized和ReentrantLock有什么区别？</h3><p><img src="/.io//image-20240806220816992.png" alt="image-20240806220816992"></p>
<p><img src="/.io//image-20240806220840400.png" alt="image-20240806220840400"></p>
<p><img src="/.io//image-20240806221028266.png" alt="image-20240806221028266"></p>
<p><img src="/.io//image-20240806221052027.png" alt="image-20240806221052027"></p>
<h3 id="13-ReentrantReadWriteLock"><a href="#13-ReentrantReadWriteLock" class="headerlink" title="13.ReentrantReadWriteLock"></a>13.ReentrantReadWriteLock</h3><p><img src="/.io//image-20240806222216266.png" alt="image-20240806222216266"></p>
<h3 id="14-StampedLock"><a href="#14-StampedLock" class="headerlink" title="14.StampedLock"></a>14.StampedLock</h3><p><img src="/.io//image-20240806222509430.png" alt="image-20240806222509430"></p>
<p><img src="/.io//image-20240806222554130.png" alt="image-20240806222554130"></p>
<h3 id="15-ThreadLocal"><a href="#15-ThreadLocal" class="headerlink" title="15.ThreadLocal"></a>15.ThreadLocal</h3><p><img src="/.io//image-20240807104704712.png" alt="image-20240807104704712"></p>
<blockquote>
<p>如何使用ThreadLocal？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>));</span><br><span class="line"><span class="comment">//ThreadLocal 的构造函数的一个替代形式，它接受一个 Supplier 函数作为参数，该函数返回一个初始值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadLocalExample</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalExample</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(obj, <span class="string">&quot;&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; default Formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Thread Name= <span class="number">0</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">0</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">1</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">2</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">1</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">3</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">2</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">4</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">3</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">4</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">5</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">5</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">6</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">6</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">7</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">7</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">8</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">9</span> <span class="type">default</span> <span class="variable">Formatter</span> <span class="operator">=</span> yyyyMMdd HHmm</span><br><span class="line">Thread Name= <span class="number">8</span> formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= <span class="number">9</span> formatter = yy-M-d ah:mm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807150919760.png" alt="image-20240807150919760"></p>
<p><img src="/.io//image-20240807150954676.png" alt="image-20240807150954676"></p>
<p><img src="/.io//image-20240807151706615.png" alt="image-20240807151706615"></p>
<p><img src="/.io//image-20240807151738135.png" alt="image-20240807151738135"></p>
<p><img src="/.io//image-20240807151820525.png" alt="image-20240807151820525"></p>
<p><img src="/.io//image-20240807151942068.png" alt="image-20240807151942068"></p>
<h3 id="16-线程池"><a href="#16-线程池" class="headerlink" title="16.线程池"></a>16.线程池</h3><p><img src="/.io//image-20240807152127592.png" alt="image-20240807152127592"></p>
<p><img src="/.io//image-20240807152202413.png" alt="image-20240807152202413"></p>
<p><img src="/.io//image-20240807152327825.png" alt="image-20240807152327825"></p>
<p><img src="/.io//image-20240807152545875.png" alt="image-20240807152545875"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有界队列 LinkedBlockingQueue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无界队列 LinkedBlockingQueue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span> (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DelayedWorkQueue（延迟阻塞队列）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A">线程池常见参数有哪些？如何解释？</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                           )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807152931380.png" alt="image-20240807152931380"></p>
<p><img src="/.io//relationship-between-thread-pool-parameters.png" alt="线程池各个参数的关系"></p>
<p><img src="/.io//image-20240807153026353.png" alt="image-20240807153026353"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;());</span><br><span class="line">       threadPoolExecutor.allowCoreThreadTimeOut(<span class="literal">true</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807153216032.png" alt="image-20240807153216032"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CallerRunsPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                <span class="comment">// 直接主线程执行，而不是线程池中的线程执行</span></span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807153243032.png" alt="image-20240807153243032"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CallerRunsPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="comment">//只要当前程序没有关闭，就用执行execute方法的线程执行该任务</span></span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807153356441.png" alt="image-20240807153356441"></p>
<p><img src="/.io//image-20240807153425419.png" alt="image-20240807153425419"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ThreadPoolTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池，核心线程数为1，最大线程数为2</span></span><br><span class="line">        <span class="comment">// 当线程数大于核心线程数时，多余的空闲线程存活的最长时间为60秒，</span></span><br><span class="line">        <span class="comment">// 任务队列为容量为1的ArrayBlockingQueue，饱和策略为CallerRunsPolicy。</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">60</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交第一个任务，由核心线程执行</span></span><br><span class="line">        threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;核心线程执行第一个任务&quot;</span>);</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交第二个任务，由于核心线程被占用，任务将进入队列等待</span></span><br><span class="line">        threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;非核心线程处理入队的第二个任务&quot;</span>);</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交第三个任务，由于核心线程被占用且队列已满，创建非核心线程处理</span></span><br><span class="line">        threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;非核心线程处理第三个任务&quot;</span>);</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交第四个任务，由于核心线程和非核心线程都被占用，队列也满了，根据CallerRunsPolicy策略，任务将由提交任务的线程（即主线程）来执行</span></span><br><span class="line">        threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;主线程处理第四个任务&quot;</span>);</span><br><span class="line">            ThreadUtil.sleep(<span class="number">2</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交第五个任务，主线程被第四个任务卡住，该任务必须等到主线程执行完才能提交</span></span><br><span class="line">        threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;核心线程执行第五个任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">19</span>:<span class="number">48.203</span> INFO  [pool-<span class="number">1</span>-thread-<span class="number">1</span>] c.j.concurrent.ThreadPoolTest - 核心线程执行第一个任务</span><br><span class="line"><span class="number">18</span>:<span class="number">19</span>:<span class="number">48.203</span> INFO  [pool-<span class="number">1</span>-thread-<span class="number">2</span>] c.j.concurrent.ThreadPoolTest - 非核心线程处理第三个任务</span><br><span class="line"><span class="number">18</span>:<span class="number">19</span>:<span class="number">48.203</span> INFO  [main] c.j.concurrent.ThreadPoolTest - 主线程处理第四个任务</span><br><span class="line"><span class="number">18</span>:<span class="number">20</span>:<span class="number">48.212</span> INFO  [pool-<span class="number">1</span>-thread-<span class="number">2</span>] c.j.concurrent.ThreadPoolTest - 非核心线程处理入队的第二个任务</span><br><span class="line"><span class="number">18</span>:<span class="number">21</span>:<span class="number">48.219</span> INFO  [pool-<span class="number">1</span>-thread-<span class="number">2</span>] c.j.concurrent.ThreadPoolTest - 核心线程执行第五个任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807153724024.png" alt="image-20240807153724024"></p>
<p><img src="/.io//threadpool-reject-2-threadpool-reject-01.png" alt="调整阻塞队列大小和最大线程数"></p>
<p><img src="/.io//image-20240807153928206.png" alt="image-20240807153928206"></p>
<p><img src="/.io//image-20240807154023052.png" alt="image-20240807154023052"></p>
<p><img src="/.io//threadpool-reject-2-threadpool-reject-02.png" alt="将一部分任务保存到MySQL中"></p>
<p><img src="/.io//image-20240807154138797.png" alt="image-20240807154138797"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NewThreadRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    NewThreadRunsPolicy() &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个临时线程处理任务</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;Temporary task executor&quot;</span>);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(</span><br><span class="line">                    <span class="string">&quot;Failed to start a new thread&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ActiveMQ 则是尝试在指定的时效内尽可能的争取将任务入队，以保证最大交付：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(<span class="keyword">final</span> Runnable r, <span class="keyword">final</span> ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//限时阻塞等待，实现尽可能交付</span></span><br><span class="line">                        executor.getQueue().offer(r, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Interrupted waiting for BrokerService.worker&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Timed Out while attempting to enqueue Task.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807154724914.png" alt="image-20240807154724914"></p>
<p><img src="/.io//image-20240807154906742.png" alt="image-20240807154906742"></p>
<p><img src="/.io//image-20240807155004085.png" alt="image-20240807155004085"></p>
<p><img src="/.io//image-20240807155222181.png" alt="image-20240807155222181"></p>
<p><img src="/.io//image-20240807155541527.png" alt="image-20240807155541527"></p>
<p><img src="/.io//image-20240807155836708.png" alt="image-20240807155836708"></p>
<p><img src="/.io//image-20240807160247918.png" alt="image-20240807160247918"></p>
<p><img src="/.io//image-20240807160309445.png" alt="image-20240807160309445"></p>
<p><img src="/.io//image-20240807161555643.png" alt="image-20240807161555643"></p>
<p><img src="/.io//image-20240807161848763.png" alt="image-20240807161848763"></p>
<h3 id="17-Future"><a href="#17-Future" class="headerlink" title="17.Future"></a>17.Future</h3><p><img src="/.io//image-20240807162326121.png" alt="image-20240807162326121"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V 代表了Future执行的任务返回值的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消任务执行</span></span><br><span class="line">    <span class="comment">// 成功取消返回 true，否则返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否已经执行完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807162404164.png" alt="image-20240807162404164"></p>
<p><img src="/.io//image-20240807162552793.png" alt="image-20240807162552793"></p>
<p><img src="/.io//image-20240807162754733.png" alt="image-20240807162754733"></p>
<p><img src="/.io//image-20240807162822073.png" alt="image-20240807162822073"></p>
<blockquote>
<p><code>Future</code> 和 <code>CompletableFuture</code> 在Java中都是用于处理异步任务的结果，但它们之间有一些重要的区别：</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><ul>
<li><code>Future</code> 是一个接口，它是在Java 5中引入的，主要用于表示异步计算的结果。</li>
<li>当你需要从一个异步任务获取结果时，&#x3D;&#x3D;你需要调用 <code>get()</code> 方法，这个方法会阻塞当前线程直到结果可用。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<code>Future</code> 不提供任何机制来在任务完成后自动触发回调函数，也不支持链式任务处理&#x3D;&#x3D;。</li>
</ul>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><ul>
<li><code>CompletableFuture</code> 是一个类，它在Java 8中引入，&#x3D;&#x3D;实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口&#x3D;&#x3D;。</li>
<li>它&#x3D;&#x3D;不仅包含了 <code>Future</code> 的所有功能，还提供了更多高级特性来简化异步编程&#x3D;&#x3D;。</li>
<li><code>CompletableFuture</code> 支持非阻塞的方法来处理结果，&#x3D;&#x3D;比如 <code>thenApply()</code>, <code>thenAccept()</code>, <code>thenRun()</code>, <code>whenComplete()</code>, <code>handle()</code> 等方法&#x3D;&#x3D;，这些方法允许你在任务完成时执行其他操作，而无需阻塞当前线程。</li>
<li>它支持任务链式调用，可以方便地组织一系列依赖的异步操作。</li>
<li>提供了更强大的组合操作，&#x3D;&#x3D;如 <code>thenCombine()</code>, <code>thenCompose()</code>, <code>allOf()</code>, <code>anyOf()</code> 等，使得异步任务的组合变得更加简单。&#x3D;&#x3D;</li>
</ul>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>阻塞性</strong>：&#x3D;&#x3D;<code>Future</code> 的 <code>get()</code> 方法会阻塞，而 <code>CompletableFuture</code> 提供了多种非阻塞的方法来处理结果&#x3D;&#x3D;。</li>
<li><strong>回调支持</strong>：<code>Future</code> 没有内置的支持来注册回调函数，&#x3D;&#x3D;而 <code>CompletableFuture</code> 提供了多种方法来在任务完成后自动触发回调&#x3D;&#x3D;。</li>
<li><strong>任务组合</strong>：&#x3D;&#x3D;<code>CompletableFuture</code> 提供了丰富的API来组合多个异步任务，使得复杂的异步流程变得更容易管理&#x3D;&#x3D;。</li>
</ul>
<p>总的来说，<code>CompletableFuture</code> 是对 <code>Future</code> 的重大改进，它提供了更多的灵活性和便利性，特别是在构建复杂的异步工作流时。如果你的应用程序使用的是Java 8或更高版本，强烈建议使用 <code>CompletableFuture</code> 而不是传统的 <code>Future</code>。</p>
</blockquote>
<h3 id="18-AQS"><a href="#18-AQS" class="headerlink" title="18.AQS"></a>18.AQS</h3><p><img src="/.io//image-20240807220520603.png" alt="image-20240807220520603"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p>
<hr>
<p><img src="/.io//image-20240807220837054.png" alt="image-20240807220837054"></p>
<p><img src="/.io//image-20240807220847409.png" alt="image-20240807220847409"></p>
<p><img src="/.io//image-20240807221204693.png" alt="image-20240807221204693"></p>
<p><img src="/.io//image-20240807221225144.png" alt="image-20240807221225144"></p>
<p><img src="/.io//image-20240807221408318-17230400500777.png" alt="image-20240807221408318"></p>
<h3 id="19-semaphore"><a href="#19-semaphore" class="headerlink" title="19.semaphore"></a>19.semaphore</h3><p><img src="/.io//image-20240807221721323.png" alt="image-20240807221721323"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807221756634.png" alt="image-20240807221756634"></p>
<p><img src="/.io//image-20240807221904724.png" alt="image-20240807221904724"></p>
<p><img src="/.io//image-20240807221937926.png" alt="image-20240807221937926"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取1个许可证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享模式下获取许可证，获取成功则返回，失败则加入阻塞队列，挂起线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 尝试获取许可证，arg为获取许可证个数，当可用许可证数减当前获取的许可证数结果小于0,则创建一个节点加入阻塞队列，挂起当前线程。</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807222130794.png" alt="image-20240807222130794"></p>
<h3 id="20-CountDownLatch"><a href="#20-CountDownLatch" class="headerlink" title="20.CountDownLatch"></a>20.CountDownLatch</h3><p><img src="/.io//image-20240807222315219.png" alt="image-20240807222315219"></p>
<blockquote>
<p>CountDownLatch的值只能被设置为一次性的，允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
</blockquote>
<p><img src="/.io//image-20240807222505929.png" alt="image-20240807222505929"></p>
<p><img src="/.io//image-20240807222554927.png" alt="image-20240807222554927"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">  它使得主线程（也就是调用 await() 方法的线程）阻塞，直到 CountDownLatch 的计数器值减到零为止。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240807222705800.png" alt="image-20240807222705800"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码还可以继续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件夹位置</span></span><br><span class="line">List&lt;String&gt; filePaths = Arrays.asList(...)</span><br><span class="line"><span class="comment">// 异步处理所有文件</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; fileFutures = filePaths.stream()</span><br><span class="line">    .map(filePath -&gt; doSomeThing(filePath))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 将他们合并起来</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(</span><br><span class="line">    fileFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[fileFutures.size()])</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="21-CyclicBarrier"><a href="#21-CyclicBarrier" class="headerlink" title="21.CyclicBarrier"></a>21.CyclicBarrier</h3><p><img src="/.io//image-20240807223037090.png" alt="image-20240807223037090"></p>
<p><img src="/.io//image-20240807223111846.png" alt="image-20240807223111846"></p>
<p><img src="/.io//image-20240807223220173.png" alt="image-20240807223220173"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 锁住</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程中断了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout减1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="comment">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class="line">                <span class="comment">// 唤醒之前等待的线程</span></span><br><span class="line">                <span class="comment">// 下一波执行开始</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="7-过滤器和拦截器的区别"><a href="#7-过滤器和拦截器的区别" class="headerlink" title="7.过滤器和拦截器的区别"></a>7.过滤器和拦截器的区别</h2><blockquote>
<p>一、运行的顺序不同</p>
</blockquote>
<p><img src="/.io//image-20240801145041283.png" alt="image-20240801145041283"></p>
<p>是在接收请求之后，servlet调用之前，拦截器是在servlet调用之后，但是在响应被发送到客户端之前来运行的</p>
<blockquote>
<p>二、配置方式不同</p>
</blockquote>
<p>过滤器是在web.xml</p>
<p>拦截器是在spring的配置文件中去进行配置。或者使用注解的方式进行配置</p>
<p><img src="/.io//image-20240801145504002.png" alt="image-20240801145504002"></p>
<blockquote>
<p>三、Filter依赖于Servlet容器，而Interceptor不依赖于Servlet容器</p>
</blockquote>
<blockquote>
<p>四、Filter在过滤器中只能对request和response进行操作，而interceptor可以对request、response、handler、modelAndView、exception进行操作</p>
</blockquote>
<p><img src="/.io//image-20240801145809123.png" alt="image-20240801145809123"></p>
<p>相当于interceptor多了对于springMVC生态下的组件的一个操作能力</p>
<h2 id="8-spring"><a href="#8-spring" class="headerlink" title="8.spring"></a>8.spring</h2><h3 id="1-什么是spring框架？"><a href="#1-什么是spring框架？" class="headerlink" title="1.什么是spring框架？"></a>1.什么是spring框架？</h3><p><img src="/.io//image-20240801193135085.png" alt="image-20240801193135085"></p>
<p><img src="/.io//image-20240801193147363.png" alt="image-20240801193147363"></p>
<p><img src="/.io//image-20240801193215137.png" alt="image-20240801193215137"></p>
<p><img src="/.io//image-20240801193239847.png" alt="image-20240801193239847"></p>
<p><img src="/.io//image-20240801193310365.png" alt="image-20240801193310365"></p>
<p><img src="/.io//image-20240801193432490.png" alt="image-20240801193432490"></p>
<p><img src="/.io//image-20240801193441648.png" alt="image-20240801193441648"></p>
<p><img src="/.io//image-20240801193504123.png" alt="image-20240801193504123"></p>
<p><img src="/.io//image-20240801193631618.png" alt="image-20240801193631618"></p>
<h3 id="2-Spring，Spring-MVC，SpringBoot之间有什么关系？"><a href="#2-Spring，Spring-MVC，SpringBoot之间有什么关系？" class="headerlink" title="2.Spring，Spring MVC，SpringBoot之间有什么关系？"></a>2.Spring，Spring MVC，SpringBoot之间有什么关系？</h3><p><img src="/.io//image-20240801193852495.png" alt="image-20240801193852495"></p>
<p><img src="/.io//image-20240801193947954.png" alt="image-20240801193947954"></p>
<p><img src="/.io//image-20240801194045314.png" alt="image-20240801194045314"></p>
<h3 id="3-spring-IOC的工作流程"><a href="#3-spring-IOC的工作流程" class="headerlink" title="3.spring IOC的工作流程"></a>3.spring IOC的工作流程</h3><p><img src="/.io//image-20240801180314164.png" alt="image-20240801180314164"></p>
<p><img src="/.io//image-20240801180322963.png" alt="image-20240801180322963"></p>
<blockquote>
<p>IOC是什么？</p>
</blockquote>
<pre><code>全程叫Inversion Of Control,也就是控制反转，核心思想就是把对象的管理权限交给了容器，应用程序如果需要使用某个对象的实例，那么直接从IOC容器里去获取就可以了，那么这种设计的好处在于降低了程序与程序之间的耦合性，使得整个程序的整个体系结构变得更加灵活
</code></pre>
<p><img src="/.io//image-20240801180432423.png" alt="image-20240801180432423"></p>
<p><img src="/.io//image-20240801180447203.png" alt="image-20240801180447203"></p>
<blockquote>
<p>Bean的声明方式？</p>
</blockquote>
<p>Spring里面提供了很多方式去声明了一个Bean，比如说在XML文件配置里面通过Bean的标签或是@Service标签或者通过@Configuration配置类里面通过@Bean注解去声明等等，spring会在启动时会去解析这些Bean保存到IOC容器中</p>
<p><img src="/.io//image-20240801180838154.png" alt="image-20240801180838154"></p>
<blockquote>
<p>IOC的工作流程是？</p>
</blockquote>
<p>大致分为两个阶段：</p>
<p>第一个阶段是IOC容器的初始化阶段，这个阶段主要是根据程序里面定义的或者注解等Bean的声明方式通过解析和加载后生成BeanDefinition，然后把BeanDefinition注册到IOC容器里面，通过注解或者xml声明的Bean，都会解析得到一个BeanDefinition实体，这个实体里面会包含一些Bean的定义和基本的一些属性，最后把BeanDefinition保存到一个Map集合从而去完成一个IOC的初始化，IOC容易的作用就是对这些注册Bean的定义信息进行处理或维护，是IOC容器控制反转的一个核心</p>
<p>第二个阶段是完成Bean的初始化和依赖注入，这个阶段会做两个事情，第一个是通过反射去针对没有设置Lazy-init属性的单例Bean进行初始化，第二个是完成Bean的依赖注入，</p>
<p>最后一个阶段就是Bean的使用，通常会通过@Autowired这样一个注解或者通过Beanfactory.getBean（）从IOC容器里面去获取指定Bean的实例，另外针对设置Lazy-init，以及非单例化bean的实例化，是在每一次获取bean对象的时候，调用Bean的初始化方法来完成实例化的，并且spring容器不会去管理这些bean</p>
<p><img src="/.io//image-20240801181250699.png" alt="image-20240801181250699"></p>
<p><img src="/.io//image-20240801181628971.png" alt="image-20240801181628971"></p>
<p><img src="/.io//image-20240801181808804.png" alt="image-20240801181808804"></p>
<h3 id="4-谈谈对于springIOC的了解"><a href="#4-谈谈对于springIOC的了解" class="headerlink" title="4.谈谈对于springIOC的了解"></a>4.谈谈对于springIOC的了解</h3><p><img src="/.io//image-20240801194255237.png" alt="image-20240801194255237"></p>
<p><img src="/.io//frc-365faceb5697f04f31399937c059c162.png" alt="IoC 图解"></p>
<p><img src="/.io//image-20240801194457670.png" alt="image-20240801194457670"></p>
<h3 id="5-什么是Spring-Bean？"><a href="#5-什么是Spring-Bean？" class="headerlink" title="5.什么是Spring Bean？"></a>5.什么是Spring Bean？</h3><p><img src="/.io//image-20240801194700626.png" alt="image-20240801194700626"></p>
<p><img src="/.io//image-20240801194717305.png" alt="image-20240801194717305"></p>
<h3 id="6-将一个类声明为Bean的注解有哪些？"><a href="#6-将一个类声明为Bean的注解有哪些？" class="headerlink" title="6.将一个类声明为Bean的注解有哪些？"></a>6.将一个类声明为Bean的注解有哪些？</h3><p><img src="/.io//image-20240801194829110.png" alt="image-20240801194829110"></p>
<h3 id="7-Component和-Bean的区别是什么？"><a href="#7-Component和-Bean的区别是什么？" class="headerlink" title="7.@Component和@Bean的区别是什么？"></a>7.@Component和@Bean的区别是什么？</h3><p><img src="/.io//image-20240801195916501.png" alt="image-20240801195916501"></p>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;transferService&quot;</span> class=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OneService <span class="title function_">getService</span><span class="params">(status)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl1</span>();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl2</span>();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-注入Bean的注解有哪些？"><a href="#8-注入Bean的注解有哪些？" class="headerlink" title="8.注入Bean的注解有哪些？"></a>8.注入Bean的注解有哪些？</h3><p><img src="/.io//image-20240801203559020.png" alt="image-20240801203559020"></p>
<h3 id="9-Autowired和-Resource的区别是什么？"><a href="#9-Autowired和-Resource的区别是什么？" class="headerlink" title="9.@Autowired和@Resource的区别是什么？"></a>9.@Autowired和@Resource的区别是什么？</h3><p><img src="/.io//image-20240801203959068.png" alt="image-20240801203959068"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="comment">// smsServiceImpl1 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240801204033974.png" alt="image-20240801204033974"></p>
<p><img src="/.io//image-20240801204101401.png" alt="image-20240801204101401"></p>
<p><img src="/.io//image-20240801204140187.png" alt="image-20240801204140187"></p>
<h3 id="10-Bean的作用域有哪些？"><a href="#10-Bean的作用域有哪些？" class="headerlink" title="10.Bean的作用域有哪些？"></a>10.Bean的作用域有哪些？</h3><p><img src="/.io//image-20240801204403955.png" alt="image-20240801204403955"></p>
<p><img src="/.io//image-20240801204422888.png" alt="image-20240801204422888"></p>
<h3 id="11-Bean是线程安全的嘛"><a href="#11-Bean是线程安全的嘛" class="headerlink" title="11.Bean是线程安全的嘛"></a>11.Bean是线程安全的嘛</h3><p><img src="/.io//image-20240801204543807.png" alt="image-20240801204543807"></p>
<h3 id="12-Bean的声明周期"><a href="#12-Bean的声明周期" class="headerlink" title="12.Bean的声明周期"></a>12.Bean的声明周期</h3><p><img src="/.io//image-20240801204851930.png" alt="image-20240801204851930"></p>
<p><img src="/.io//image-20240801205500987.png" alt="image-20240801205500987"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建 Bean 的实例</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. Bean 属性赋值/填充</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 3. Bean 初始化</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 销毁 Bean-注册回调接口</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240801205937535.png" alt="image-20240801205937535"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化前置处理</span></span><br><span class="line">	<span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化后置处理</span></span><br><span class="line">	<span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240801210157156.png" alt="image-20240801210157156"></p>
<p><img src="/.io//image-20240801210211874.png" alt="image-20240801210211874"></p>
<p><img src="/.io//image-20240801210227076.png" alt="image-20240801210227076"></p>
<p><img src="/.io//image-20240801210341521.png" alt="image-20240801210341521"></p>
<h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><h4 id="1-AOP的了解"><a href="#1-AOP的了解" class="headerlink" title="1.AOP的了解"></a>1.AOP的了解</h4><p><img src="/.io//image-20240801223222651.png" alt="image-20240801223222651"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Spring AOP（面向切面编程）确实使用了两种不同的代理技术来支持不同类型的被代理对象：JDK动态代理和CGLIB（Code Generation Library）。</span><br><span class="line"></span><br><span class="line">### JDK动态代理</span><br><span class="line"></span><br><span class="line">JDK动态代理主要依赖于`java.lang.reflect.Proxy`类和`java.lang.reflect.InvocationHandler`接口。当我们想要代理一个对象，并且这个对象已经实现了至少一个接口时，我们可以使用JDK动态代理来创建一个代理对象。这个代理对象将实现同样的接口，并且在运行时通过`InvocationHandler`来处理方法调用。</span><br><span class="line"></span><br><span class="line">JDK动态代理的一个关键要求是被代理的对象必须实现一个或多个接口。这是因为动态代理对象实际上是通过继承`java.lang.reflect.Proxy`类并实现这些接口来创建的。因此，如果没有接口可以实现，就不能使用JDK动态代理。</span><br><span class="line"></span><br><span class="line">### CGLIB</span><br><span class="line"></span><br><span class="line">当目标对象没有实现任何接口时，Spring AOP不能使用JDK动态代理，因为JDK动态代理需要一个接口来创建代理类。此时，Spring AOP会使用CGLIB来生成一个目标对象的子类。CGLIB是一个强大的代码生成库，它可以动态地创建一个新的子类，这个子类继承了原始的目标类，并重写了方法来实现AOP行为。</span><br><span class="line"></span><br><span class="line">### 为什么有区别？</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> **接口限制**：</span><br><span class="line">   - **JDK动态代理**：要求目标对象实现接口。</span><br><span class="line">   - **CGLIB**：不需要目标对象实现接口。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> **代理类型**：</span><br><span class="line">   - **JDK动态代理**：创建的是接口的实现，而不是类的子类。</span><br><span class="line">   - **CGLIB**：创建的是原始类的子类。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> **方法调用处理**：</span><br><span class="line">   - **JDK动态代理**：通过`InvocationHandler`接口处理方法调用。</span><br><span class="line">   - **CGLIB**：通过拦截器（Interceptor）处理方法调用。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> **性能影响**：</span><br><span class="line">   - **JDK动态代理**：通常比CGLIB更快，因为它不涉及类的继承，只是简单的接口实现。</span><br><span class="line">   - **CGLIB**：可能比JDK动态代理慢一些，因为它涉及到类的继承以及方法的重写。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> **方法覆盖问题**：</span><br><span class="line">   - **JDK动态代理**：不存在方法覆盖问题，因为它只实现接口。</span><br><span class="line">   - **CGLIB**：如果目标类的方法声明为<span class="keyword">final</span>，则不能被子类重写，因此不能使用CGLIB来代理。</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">Spring AOP选择使用哪种代理方式取决于被代理对象是否实现了接口。如果实现了接口，则使用JDK动态代理；如果没有实现接口，则使用CGLIB。这样可以确保所有类型的对象都可以被适当地代理，并且能够支持AOP的功能。</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240801223459938.png" alt="image-20240801223459938"></p>
<p><img src="/.io//image-20240801223524845.png" alt="image-20240801223524845"></p>
<p><img src="/.io//image-20240801223601639.png" alt="image-20240801223601639"></p>
<h4 id="2-SpringAOP和AspectJ-AOP有什么区别？"><a href="#2-SpringAOP和AspectJ-AOP有什么区别？" class="headerlink" title="2.SpringAOP和AspectJ AOP有什么区别？"></a>2.SpringAOP和AspectJ AOP有什么区别？</h4><p><img src="/.io//image-20240801223817818.png" alt="image-20240801223817818"></p>
<p><img src="/.io//image-20240801223848151.png" alt="image-20240801223848151"></p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="1-对SpringMVC的了解"><a href="#1-对SpringMVC的了解" class="headerlink" title="1.对SpringMVC的了解"></a>1.对SpringMVC的了解</h4><p><img src="/.io//image-20240801223938543.png" alt="image-20240801223938543"></p>
<p><img src="/.io//image-20240801224000095.png" alt="image-20240801224000095"></p>
<p><img src="/.io//image-20240801224032892.png" alt="image-20240801224032892"></p>
<p><img src="/.io//image-20240801224041585.png" alt="image-20240801224041585"></p>
<p><img src="/.io//image-20240801224151279.png" alt="image-20240801224151279"></p>
<p><img src="/.io//image-20240801224204975.png" alt="image-20240801224204975"></p>
<p><img src="/.io//image-20240801224312967.png" alt="image-20240801224312967"></p>
<p><img src="/.io//image-20240801224436509.png" alt="image-20240801224436509"></p>
<p><img src="/.io//image-20240801224542167.png" alt="image-20240801224542167"></p>
<h4 id="2-统一异常处理"><a href="#2-统一异常处理" class="headerlink" title="2.统一异常处理"></a>2.统一异常处理</h4><p><img src="/.io//image-20240801224651990.png" alt="image-20240801224651990"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240801224810253.png" alt="image-20240801224810253"></p>
<p><img src="/.io//image-20240801224837668.png" alt="image-20240801224837668"></p>
<h4 id="3-用到了哪些设计模式？"><a href="#3-用到了哪些设计模式？" class="headerlink" title="3.用到了哪些设计模式？"></a>3.用到了哪些设计模式？</h4><p>  <img src="/.io//image-20240801225914493.png" alt="image-20240801225914493"></p>
<h4 id="4-spring的循环依赖"><a href="#4-spring的循环依赖" class="headerlink" title="4.spring的循环依赖"></a>4.spring的循环依赖</h4><p><img src="/.io//image-20240801225956488.png" alt="image-20240801225956488"></p>
<p><img src="/.io//image-20240801230009538.png" alt="image-20240801230009538"></p>
<p><img src="/.io//image-20240801230021141.png" alt="image-20240801230021141"></p>
<p><img src="/.io//image-20240801230034456.png" alt="image-20240801230034456"></p>
<p><img src="/.io//image-20240801230121433.png" alt="image-20240801230121433"></p>
<p><img src="/.io//image-20240801230150766.png" alt="image-20240801230150766"></p>
<p><img src="/.io//image-20240801230158879.png" alt="image-20240801230158879"></p>
<p><img src="/.io//image-20240801230221563.png" alt="image-20240801230221563"></p>
<p><img src="/.io//image-20240801230229943.png" alt="image-20240801230229943"></p>
<p><img src="/.io//image-20240801230323551.png" alt="image-20240801230323551"></p>
<p><img src="/.io//image-20240801230359503.png" alt="image-20240801230359503"></p>
<p><img src="/.io//image-20240801230454533.png" alt="image-20240801230454533"></p>
<p>如果是原型模式下（prototype scope）下每次请求都会创建一个新的Bean实例，B调用A，A调用B无线循环下去，就导致了无线递归的问题最终会导致<code>StackOverflowError</code> 或者 <code>BeanCurrentlyInCreationException</code> 异常。</p>
<blockquote>
<p>为什么不能在代理的情况下？</p>
</blockquote>
<p><strong>示例场景</strong></p>
<p>假设我们有两个Bean：<code>ServiceA</code> 和 <code>ServiceB</code>。这两个Bean之间存在相互依赖的关系，即<code>ServiceA</code>依赖于<code>ServiceB</code>，而<code>ServiceB</code>也依赖于<code>ServiceA</code>。此外，我们假设<code>ServiceA</code>上配置了Spring AOP的切面。</p>
<h4 id="没有代理对象的情况"><a href="#没有代理对象的情况" class="headerlink" title="没有代理对象的情况"></a>没有代理对象的情况</h4><ol>
<li><strong>初始化过程</strong>：<ul>
<li>当Spring容器开始初始化<code>ServiceA</code>时，由于它依赖于<code>ServiceB</code>，而<code>ServiceB</code>尚未初始化完成，此时Spring会将<code>ServiceA</code>的部分初始化状态存储在<code>earlySingletonObjects</code>缓存中。</li>
<li>同样地，当初始化<code>ServiceB</code>时，由于它依赖于<code>ServiceA</code>，也会将<code>ServiceB</code>的部分初始化状态存储在<code>earlySingletonObjects</code>缓存中。</li>
<li>在<code>ServiceA</code>和<code>ServiceB</code>都部分初始化后，Spring会继续完成它们的初始化过程，并将完全初始化后的Bean实例放入<code>singletonObjects</code>缓存中。</li>
</ul>
</li>
<li><strong>解决循环依赖</strong>：<ul>
<li>当<code>ServiceA</code>需要<code>ServiceB</code>时，可以从<code>earlySingletonObjects</code>缓存中获取部分初始化的<code>ServiceB</code>实例。</li>
<li>同样地，当<code>ServiceB</code>需要<code>ServiceA</code>时，也可以从<code>earlySingletonObjects</code>缓存中获取部分初始化的<code>ServiceA</code>实例。</li>
</ul>
</li>
</ol>
<h4 id="存在代理对象的情况"><a href="#存在代理对象的情况" class="headerlink" title="存在代理对象的情况"></a>存在代理对象的情况</h4><ol>
<li><strong>初始化过程</strong>：<ul>
<li>当Spring容器开始初始化<code>ServiceA</code>时，由于它依赖于<code>ServiceB</code>，而<code>ServiceB</code>尚未初始化完成，此时Spring会将<code>ServiceA</code>的部分初始化状态存储在<code>earlySingletonObjects</code>缓存中。</li>
<li>同样地，当初始化<code>ServiceB</code>时，由于它依赖于<code>ServiceA</code>，也会将<code>ServiceB</code>的部分初始化状态存储在<code>earlySingletonObjects</code>缓存中。</li>
<li>完成初始化后，<code>ServiceA</code>由于配置了AOP切面，Spring容器会通过BeanPostProcessor来创建<code>ServiceA</code>的代理对象。</li>
</ul>
</li>
<li><strong>问题出现</strong>：<ul>
<li>如果仅使用二级缓存<code>singletonObjects</code>，那么在<code>ServiceA</code>初始化完成前，其部分初始化的状态会被存储在<code>singletonObjects</code>缓存中。</li>
<li>当<code>ServiceA</code>完全初始化并由BeanPostProcessor生成代理对象后，这个代理对象会覆盖<code>singletonObjects</code>缓存中的非代理版本。</li>
<li>这意味着在<code>ServiceA</code>的代理对象生成之前，如果有其他地方尝试获取<code>ServiceA</code>，那么获取到的将是非代理版本的对象。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li>为了解决上述问题，Spring容器使用三级缓存机制。</li>
<li>在初始化过程中，部分初始化的<code>ServiceA</code>和<code>ServiceB</code>实例会存储在<code>earlySingletonObjects</code>缓存中。</li>
<li>完全初始化后的<code>ServiceA</code>实例会存储在<code>singletonFactories</code>缓存中。</li>
<li>当需要<code>ServiceA</code>时，Spring会从<code>singletonFactories</code>中获取工厂对象来创建最终的代理对象。</li>
<li>这样一来，无论何时获取<code>ServiceA</code>，都会得到最新的代理对象，从而避免了缓存不一致的问题。</li>
</ul>
</li>
</ol>
<p><img src="/.io//image-20240801230539147.png" alt="image-20240801230539147"></p>
<p><img src="/.io//image-20240801230649386.png" alt="image-20240801230649386"></p>
<p><img src="/.io//image-20240801230728110.png" alt="image-20240801230728110"></p>
<h4 id="5-Spring事务"><a href="#5-Spring事务" class="headerlink" title="5.Spring事务"></a>5.Spring事务</h4><p><img src="/.io//image-20240802101005513.png" alt="image-20240802101005513"></p>
<p><img src="/.io//image-20240802101346870.png" alt="image-20240802101346870"></p>
<p><img src="/.io//image-20240802101418220.png" alt="image-20240802101418220"></p>
<blockquote>
<p>Spring事务的传播行为有什么用？</p>
</blockquote>
<p>Spring框架中的事务传播行为是用于控制方法调用时如何与现有事务交互或是否应该创建一个新的事务，更好的管理应用程序中的事务边界和隔离级别</p>
<blockquote>
<p>Spring定义了以下几种不同的传播行为：</p>
<ol>
<li><strong>PROPAGATION_REQUIRED</strong>：<ul>
<li>这是最常用的传播行为类型。</li>
<li>如果当前存在一个事务，则加入该事务。</li>
<li>如果当前没有事务，则创建一个新的事务。</li>
</ul>
</li>
<li><strong>PROPAGATION_SUPPORTS</strong>：<ul>
<li>如果当前存在一个事务，则加入该事务。</li>
<li>如果当前没有事务，则以非事务的方式继续执行。</li>
</ul>
</li>
<li><strong>PROPAGATION_MANDATORY</strong>：<ul>
<li>如果当前存在一个事务，则加入该事务。</li>
<li>如果当前没有事务，则抛出异常（<code>TransactionRequiredException</code>）。</li>
</ul>
</li>
<li><strong>PROPAGATION_REQUIRES_NEW</strong>：<ul>
<li>创建一个新的事务，并且挂起当前事务（如果存在的话）。</li>
<li>新事务独立于任何上级事务。</li>
</ul>
</li>
<li><strong>PROPAGATION_NOT_SUPPORTED</strong>：<ul>
<li>以非事务方式执行操作，并挂起当前事务（如果存在的话）。</li>
</ul>
</li>
<li><strong>PROPAGATION_NEVER</strong>：<ul>
<li>以非事务方式执行，如果当前存在事务，则抛出异常（<code>IllegalTransactionStateException</code>）。</li>
</ul>
</li>
<li><strong>PROPAGATION_NESTED</strong>（自Spring 2.0起）：<ul>
<li>如果当前存在一个事务，则执行一个嵌套的事务。</li>
<li>如果当前没有事务，则行为类似于<code>PROPAGATION_REQUIRED</code>。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>假设我们有一个简单的银行转账系统，其中包含两个主要的操作：从一个账户转出资金和向另一个账户转入资金。</p>
<h3 id="示例背景"><a href="#示例背景" class="headerlink" title="示例背景"></a>示例背景</h3><ul>
<li><p>我们有两个账户，<code>Account A</code> 和 <code>Account B</code>。</p>
</li>
<li><p>转账操作涉及到从 <code>Account A</code> 减少金额，并向 <code>Account B</code> 增加相同的金额。</p>
</li>
<li><pre><code class="java">@Service
public class AccountService &#123;
        
    @Autowired
    private AccountRepository accountRepository;
        
    // 使用默认的 PROPAGATION_REQUIRED
    @Transactional
    public void transferFunds(String fromAccount, String toAccount, double amount) &#123;
        Account from = accountRepository.findByAccountNumber(fromAccount);
        Account to = accountRepository.findByAccountNumber(toAccount);
        
        // 减少fromAccount的金额
        from.setBalance(from.getBalance() - amount);
        accountRepository.save(from);
        
        // 增加toAccount的金额
        to.setBalance(to.getBalance() + amount);
        accountRepository.save(to);
    &#125;
        
    // 使用 PROPAGATION_REQUIRES_NEW
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateAccountDetails(String accountNumber) &#123;
        Account account = accountRepository.findByAccountNumber(accountNumber);
        account.setDetails(&quot;Updated details&quot;);
        accountRepository.save(account);
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 场景描述</span><br><span class="line"></span><br><span class="line">在这个例子中，我们有两个方法：</span><br><span class="line"></span><br><span class="line">1. `transferFunds` 方法用于从一个账户转账到另一个账户。</span><br><span class="line">2. `updateAccountDetails` 方法用于更新账户的详细信息。</span><br><span class="line"></span><br><span class="line">假设我们想要在一个事务中调用这两个方法。让我们考虑两种情况：</span><br><span class="line"></span><br><span class="line">#### 情况 1: 不使用嵌套事务</span><br><span class="line"></span><br><span class="line">如果我们直接调用 `transferFunds` 和 `updateAccountDetails`，而没有显式地设置传播行为，会发生什么？</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 假设我们正在一个事务中调用这些方法</span><br><span class="line">@Transactional</span><br><span class="line">public void performTransactions() &#123;</span><br><span class="line">    String fromAccount = &quot;A123&quot;;</span><br><span class="line">    String toAccount = &quot;B456&quot;;</span><br><span class="line">    double amount = 100.0;</span><br><span class="line">        </span><br><span class="line">    accountService.transferFunds(fromAccount, toAccount, amount);</span><br><span class="line">    accountService.updateAccountDetails(fromAccount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在这种情况下，因为 `transferFunds` 默认使用的是 `PROPAGATION_REQUIRED`，它会加入当前事务。但是 `updateAccountDetails` 使用了 `PROPAGATION_REQUIRES_NEW`，这意味着它会创建一个新的事务，并且挂起当前的事务。因此，`updateAccountDetails` 完成后，它的事务会被提交或回滚，然后恢复原来的事务并继续执行。

#### 情况 2: 使用嵌套事务

如果我们希望 `updateAccountDetails` 在 `transferFunds` 的事务中作为嵌套事务执行，我们可以修改调用方式如下：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们正在一个事务中调用这些方法</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTransactionsWithNested</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fromAccount</span> <span class="operator">=</span> <span class="string">&quot;A123&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">toAccount</span> <span class="operator">=</span> <span class="string">&quot;B456&quot;</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">100.0</span>;</span><br><span class="line">        </span><br><span class="line">    accountService.transferFunds(fromAccount, toAccount, amount);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 尝试在当前事务中作为嵌套事务执行</span></span><br><span class="line">    <span class="type">PlatformTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> ...; <span class="comment">// 获取事务管理器实例</span></span><br><span class="line">    <span class="type">TransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(def);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        accountService.updateAccountDetails(fromAccount);</span><br><span class="line">        transactionManager.commit(status);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        transactionManager.rollback(status);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        在这个例子中，`updateAccountDetails` 作为嵌套事务执行。如果它成功完成，那么它的更改会成为外层事务的一部分。如果它失败并且被回滚，那么它的更改不会影响外层事务的状态。

- `PROPAGATION_REQUIRED` 保证了转账操作作为一个整体完成或回滚。
- `PROPAGATION_REQUIRES_NEW` 使得更新账户详情的操作独立于转账操作，即使转账操作失败也不会影响账户详情的更新。
- 使用嵌套事务 `PROPAGATION_NESTED` 可以让 `updateAccountDetails` 成为 `transferFunds` 事务的一部分，确保一致性。



        在Spring中，当使用`PROPAGATION_NESTED`时，如果内层事务失败并回滚，这通常意味着它所做的更改不会对外层事务产生持久影响。这是因为Spring通过一种称为“保存点”（savepoint）的机制来实现嵌套事务。

### 示例解释

让我们回到之前的例子，解释一下嵌套事务失败时的行为：

1. **开始外层事务**：

   - 外层事务开始。
   - 执行转账操作。

2. **开始内层事务**：

   - 使用`PROPAGATION_NESTED`开始内层事务。
   - 设置保存点。
   - 更新账户详情。

3. **内层事务失败**：

   - 如果内层事务（更新账户详情）遇到问题并回滚，它将回滚到之前设置的保存点。
   - 内层事务的更改被撤销，但外层事务的状态不受影响。

4. **外层事务完成**：

   - 如果外层事务成功完成，它将正常提交。
   - 即使内层事务失败并回滚，外层事务仍然可以成功提交。

      在这个例子中，如果`updateAccountDetails`方法中的内层事务遇到问题并回滚，它只会回滚到保存点，而不会影响外层事务的其他部分。这意味着转账操作仍然可以成功提交，而账户详情更新则被回滚，不会对转账操作产生影响。
</code></pre>
</li>
</ul>
</blockquote>
<img src="/.io//image-20240802103503879.png" alt="image-20240802103503879" style="zoom: 80%;">

<p><img src="/.io//image-20240802103605136.png" alt="image-20240802103605136"></p>
<p><img src="/.io//spring-transactional-rollbackfor.png" alt="img"></p>
<p><img src="/.io//image-20240802103636688.png" alt="image-20240802103636688"></p>
<h3 id="Spring-JPA"><a href="#Spring-JPA" class="headerlink" title="Spring JPA"></a>Spring JPA</h3><p><img src="/.io//image-20240802103857893.png" alt="image-20240802103857893"></p>
<p><img src="/.io//image-20240802103916706.png" alt="image-20240802103916706"></p>
<p><img src="/.io//image-20240802103954852.png" alt="image-20240802103954852"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(value = AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAuditBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String createdBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String updatedBy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240802104017664.png" alt="image-20240802104017664"></p>
<p><img src="/.io//image-20240802104026168.png" alt="image-20240802104026168"></p>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p><img src="/.io//image-20240802104102699.png" alt="image-20240802104102699"></p>
<p><img src="/.io//image-20240802104126650.png" alt="image-20240802104126650"></p>
<p><img src="/.io//image-20240802104153457.png" alt="image-20240802104153457"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PasswordEncoder</span> &#123;</span><br><span class="line">    <span class="comment">// 加密也就是对原始密码进行编码</span></span><br><span class="line">    String <span class="title function_">encode</span><span class="params">(CharSequence var1)</span>;</span><br><span class="line">    <span class="comment">// 比对原始密码和数据库中保存的密码</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence var1, String var2)</span>;</span><br><span class="line">    <span class="comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">upgradeEncoding</span><span class="params">(String encodedPassword)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20220728183540954.png" alt="img"></p>
<h2 id="9-Netty"><a href="#9-Netty" class="headerlink" title="9.Netty"></a>9.Netty</h2><h3 id="1-Netty这个框架的理解"><a href="#1-Netty这个框架的理解" class="headerlink" title="1.Netty这个框架的理解"></a>1.Netty这个框架的理解</h3><blockquote>
<p> 1.Netty是一个基于NIO模型的高性能网络通信框架，可以认为他是一个对NIO网络模型的封装，提供了简单易用的一个api，我们可以利用这样一些封装好的Api去快速开发自己的一个网络程序</p>
<p> 2.Netty在NIO的基础上做了很多的优化，如：零拷贝机制、高性能无锁队列、内存池等这样一些，因此性能会比NIO更高</p>
<p> 3.Netty可以支持多种通信协议，比如http、websocket，并且针对数据通信拆包粘包的问题，Netty内置了很多的拆包策略，所以在整个使用过程中会非常方便</p>
</blockquote>
<h3 id="2-为什么要使用Netty？"><a href="#2-为什么要使用Netty？" class="headerlink" title="2.为什么要使用Netty？"></a>2.为什么要使用Netty？</h3><blockquote>
<p> Netty相比直接去使用JDK自带的NIO相关的API来说呢会更加简单，因为它具有：</p>
<p> 1.统一的API，支持多种传输类型，比如说阻塞、非阻塞，以及epoll、poll等模型</p>
<p> 2.可以使用非常少的代码来实现多线程reactor模型，以及主从多线程Reactor模型</p>
<p> 3.自带编解码器，去解决TCP粘包&#x2F;拆包的一个问题</p>
<p> 4.自带的各种通信协议</p>
<p> 5.第五个是Netty相比于直接使用java库里面的NIO的话，他提供了更高的一个吞吐量以及更低的延迟以及更低的资源小号和更少的内存复制</p>
<p> 6.安全性很好，他有完整的SSL&#x2F;TLS的这样一个支持</p>
<p> 7.社区的活跃度很好，而且版本迭代很稳定，经历了各种大的项目的一个考验，比如Dubbo、Zookeeper、RocketMQ，他们都有用到Netty</p>
</blockquote>
<h3 id="3-Netty可以做什么事？"><a href="#3-Netty可以做什么事？" class="headerlink" title="3.Netty可以做什么事？"></a>3.Netty可以做什么事？</h3><blockquote>
<p>核心的点在于如何去承载更多的用户同时访问的问题，传统的BIO模型呢，由于阻塞的一个特性，使得我们在高并发场景中很难去支持一个更高的吞吐量，后来我们去基于NIO多路复用模型虽然可以在阻塞方面进行优化，但是它的API使用比较复杂，对于初学者来说不是特别友好，而Netty是基于NIO的一个封装，提供了成熟简单易用的API，降低了使用成本和学习成本，本质上来说Netty和NIO所扮演的角色是相同的，都是为了去提升服务端的吞吐量，让用户获得更好的一个产品体验，另外Netty中间件经过了很多年的考证，本质上来说Netty和NIO所扮演的角色是相同的，都是为了去提升服务端的吞吐量，去让用户获得更好的产品体验</p>
</blockquote>
<h3 id="4-Netty里面有哪些核心组件？分别有什么用？"><a href="#4-Netty里面有哪些核心组件？分别有什么用？" class="headerlink" title="4.Netty里面有哪些核心组件？分别有什么用？"></a>4.Netty里面有哪些核心组件？分别有什么用？</h3><blockquote>
<p>Netty由三层结构构成：</p>
<p>1.网络通信层</p>
<p>2.事件调度层</p>
<p>3.服务编排层</p>
<p>一：在网络通信层有三个核心组件：</p>
<p>Bootstrap、ServerBootStrap、Channel</p>
<p>Bootstrap负责客户端启动，并且去连接远程的NettyServer</p>
<p>ServerBootStrap是负责服务端的监听，用来健通指定的一个端口</p>
<p>channel是负责网络通信的一个载体</p>
<p>二：事件调度器：事件调度器有两个核心角色，EventLoopGroup与EventLoop；EventLoopGroup本质上是一个线程池，只要是负责接收IO请求，并分配线程去执行处理请求</p>
<p>EventLoop是相对于线程池里面的一个具体线程</p>
<p>三：在服务编排有三个核心组件：</p>
<p>ChannelPipeLine、ChannelHandler、以及ChannelHandlerContext</p>
<p>channelPipeline它是负责多个channelHandler，它会把多个Channelhandler构成一个链，去形成要给pipeline</p>
<p>channelHandler主要是针对IO数据的一个处理器，数据处理接收后通过指定一个Handler进行处理、</p>
<p>ChannelHandlerContext使用来保存ChannelHandler的一个上下文信息</p>
</blockquote>
<h3 id="5-Netty有几种线程模型？"><a href="#5-Netty有几种线程模型？" class="headerlink" title="5.Netty有几种线程模型？"></a>5.Netty有几种线程模型？</h3><blockquote>
<p>Netty提供了三种Reactor模型的一个支持</p>
<p>第一种是单线程单Reactor模型</p>
<p>第二种是多线程单Reactor模型</p>
<p>第三种是多线程多Reactor模型（主从多线程Reactor模型）</p>
</blockquote>
<blockquote>
<p>Reactor模型有三个重要的组件 </p>
<p>第一个是&#x3D;&#x3D;Reactor模型是负责将IO事件，分派给对应的Handler&#x3D;&#x3D;</p>
<p>第二个是&#x3D;&#x3D;Acceptor，处理客户端的连接请求&#x3D;&#x3D;</p>
<p>第三个是&#x3D;&#x3D;Handlers，去执行我们的业务逻辑的读写操作&#x3D;&#x3D;</p>
</blockquote>
<p>  <img src="/.io//image-20240808224148883.png" alt="image-20240808224148883"></p>
<blockquote>
<p>我们的连接进来到IO事件处理全部是由一个线程来处理的，缺点如果其中一个Handler出现了阻塞，就会导致后续的客户端无法被处理，无法接收新的请求，有人提出多线程处理，加入线程池去异步处理，这样我们就可以解决handler阻塞的一个问题，把reactor和handler放在不同的线程里面去处理</p>
</blockquote>
<p><img src="/.io//image-20240808224605447.png" alt="image-20240808224605447"></p>
<blockquote>
<p>多线程单Reactor模型，&#x3D;&#x3D;所有的io操作都是由一个Reactor来完成的，就会导致单个Reactor会存在一个性能瓶颈&#x3D;&#x3D;，对于小容量的场景影响不是很大，但是对于高并发的一些场景来说很容易会因为单个Reactor的一个阻塞，或者单个Reactor的性能瓶颈导致整个的吞吐量会收到影响，所以当线程超过负载之后，处理的速度就会变慢，就会导致大量的客户端连接超时，超时之后会进行重发，这反而加重了线程的负载，最终会导致大量的消息积压和处理的超时，成为整个系统的一个性能瓶颈，所以可以进行要给进一步的优化，引入多线程多Reactor模型</p>
</blockquote>
<p><img src="/.io//image-20240808225105678.png" alt="image-20240808225105678"></p>
<blockquote>
<p> 所谓的多线程多Reactor模型也叫主从Reactor模型，MainReactor是负责接收客户的连接请求，然后把接受的请求传递给subReactor，其中subReactor可以配置多个，可以进行灵活的扩容和缩容，具体的业务IO处理由SubReactor来去完成去最终的去绑定给对应的handler，那么acceptor还是扮演一个请求接收者没有任何变化，他会把接收的请求转发到MainReactor，然后再交给subReactor进行真正意义上的分发</p>
</blockquote>
<h2 id="10-IM面经"><a href="#10-IM面经" class="headerlink" title="10.IM面经"></a>10.IM面经</h2><h3 id="1-模块之间是如何通信的"><a href="#1-模块之间是如何通信的" class="headerlink" title="1.模块之间是如何通信的"></a>1.模块之间是如何通信的</h3><h4 id="1-是基于spring框架的事务"><a href="#1-是基于spring框架的事务" class="headerlink" title="1.是基于spring框架的事务"></a>1.是基于spring框架的事务</h4><p>&#x3D;&#x3D;事务是可以延申出来单例模式的&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupMemberAddEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;GroupMember&gt; memberList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoomGroup roomGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long inviteUid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupMemberAddEvent</span><span class="params">(Object source, RoomGroup roomGroup, List&lt;GroupMember&gt; memberList, Long inviteUid)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.memberList = memberList;</span><br><span class="line">        <span class="built_in">this</span>.roomGroup = roomGroup;</span><br><span class="line">        <span class="built_in">this</span>.inviteUid = inviteUid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@RedissonLock(key = &quot;#request.roomId&quot;)</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMember</span><span class="params">(Long uid, MemberAddReq request)</span> &#123;</span><br><span class="line">    <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomCache.get(request.getRoomId());</span><br><span class="line">    AssertUtil.isNotEmpty(room, <span class="string">&quot;房间号有误&quot;</span>);</span><br><span class="line">    AssertUtil.isFalse(isHotGroup(room), <span class="string">&quot;全员群无需邀请好友&quot;</span>);</span><br><span class="line">    <span class="type">RoomGroup</span> <span class="variable">roomGroup</span> <span class="operator">=</span> roomGroupCache.get(request.getRoomId());</span><br><span class="line">    AssertUtil.isNotEmpty(roomGroup, <span class="string">&quot;房间号有误&quot;</span>);</span><br><span class="line">    <span class="type">GroupMember</span> <span class="variable">self</span> <span class="operator">=</span> groupMemberDao.getMember(roomGroup.getId(), uid);</span><br><span class="line">    AssertUtil.isNotEmpty(self, <span class="string">&quot;您不是群成员&quot;</span>);</span><br><span class="line">    List&lt;Long&gt; memberBatch = groupMemberDao.getMemberBatch(roomGroup.getId(), request.getUidList());</span><br><span class="line">    Set&lt;Long&gt; existUid = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(memberBatch);</span><br><span class="line">    List&lt;Long&gt; waitAddUidList = request.getUidList().stream().filter(a -&gt; !existUid.contains(a)).distinct().collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(waitAddUidList)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;GroupMember&gt; groupMembers = MemberAdapter.buildMemberAdd(roomGroup.getId(), waitAddUidList);</span><br><span class="line">    groupMemberDao.saveBatch(groupMembers);</span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">GroupMemberAddEvent</span>(<span class="built_in">this</span>, roomGroup, groupMembers, uid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240901145040443.png" alt="image-20240901145040443"></p>
<blockquote>
<p>发布事件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="meta">@TransactionalEventListener(classes = GroupMemberAddEvent.class, fallbackExecution = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAddMsg</span><span class="params">(GroupMemberAddEvent event)</span> &#123;</span><br><span class="line">    List&lt;GroupMember&gt; memberList = event.getMemberList();</span><br><span class="line">    <span class="type">RoomGroup</span> <span class="variable">roomGroup</span> <span class="operator">=</span> event.getRoomGroup();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">inviteUid</span> <span class="operator">=</span> event.getInviteUid();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userInfoCache.get(inviteUid);</span><br><span class="line">    List&lt;Long&gt; uidList = memberList.stream().map(GroupMember::getUid).collect(Collectors.toList());</span><br><span class="line">    <span class="type">ChatMessageReq</span> <span class="variable">chatMessageReq</span> <span class="operator">=</span> RoomAdapter.buildGroupAddMessage(roomGroup, user, userInfoCache.getBatch(uidList));</span><br><span class="line">    chatService.sendMsg(chatMessageReq, User.UID_SYSTEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240901145142353.png" alt="image-20240901145142353"></p>
<h4 id="2-基于rocketmq的"><a href="#2-基于rocketmq的" class="headerlink" title="2.基于rocketmq的"></a>2.基于rocketmq的</h4><p><img src="/.io//image-20240901145355868.png" alt="image-20240901145355868"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RocketMQMessageListener(consumerGroup = MQConstant.SEND_MSG_GROUP, topic = MQConstant.SEND_MSG_TOPIC)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgSendConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MsgSendMessageDTO&gt; &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebSocketService webSocketService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChatService chatService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageDao messageDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IChatAIService openAIService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WeChatMsgOperationService weChatMsgOperationService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoomCache roomCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoomDao roomDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GroupMemberCache groupMemberCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserCache userCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoomFriendDao roomFriendDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContactDao contactDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HotRoomCache hotRoomCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PushService pushService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MsgSendMessageDTO dto)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageDao.getById(dto.getMsgId());</span><br><span class="line">        <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomCache.get(message.getRoomId());</span><br><span class="line">        <span class="type">ChatMessageResp</span> <span class="variable">msgResp</span> <span class="operator">=</span> chatService.getMsgResp(message, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//所有房间更新房间最新消息</span></span><br><span class="line">        roomDao.refreshActiveTime(room.getId(), message.getId(), message.getCreateTime());</span><br><span class="line">        roomCache.delete(room.getId());</span><br><span class="line">        <span class="keyword">if</span> (room.isHotRoom()) &#123;<span class="comment">//热门群聊推送所有在线的人</span></span><br><span class="line">            <span class="comment">//更新热门群聊时间-redis</span></span><br><span class="line">            hotRoomCache.refreshActiveTime(room.getId(), message.getCreateTime());</span><br><span class="line">            <span class="comment">//推送所有人</span></span><br><span class="line">            pushService.sendPushMsg(WSAdapter.buildMsgSend(msgResp));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Long&gt; memberUidList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(room.getType(), RoomTypeEnum.GROUP.getType())) &#123;<span class="comment">//普通群聊推送所有群成员</span></span><br><span class="line">                memberUidList = groupMemberCache.getMemberUidList(room.getId());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(room.getType(), RoomTypeEnum.FRIEND.getType())) &#123;<span class="comment">//单聊对象</span></span><br><span class="line">                <span class="comment">//对单人推送</span></span><br><span class="line">                <span class="type">RoomFriend</span> <span class="variable">roomFriend</span> <span class="operator">=</span> roomFriendDao.getByRoomId(room.getId());</span><br><span class="line">                memberUidList = Arrays.asList(roomFriend.getUid1(), roomFriend.getUid2());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新所有群成员的会话时间</span></span><br><span class="line">            contactDao.refreshOrCreateActiveTime(room.getId(), memberUidList, message.getId(), message.getCreateTime());</span><br><span class="line">            <span class="comment">//推送房间成员</span></span><br><span class="line">            pushService.sendPushMsg(WSAdapter.buildMsgSend(msgResp), memberUidList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20240901145456501.png" alt="image-20240901145456501"></p>
<p><img src="/.io//image-20240901145600795.png" alt="image-20240901145600795"></p>
<p><img src="/.io//image-20240901145718162.png" alt="image-20240901145718162"></p>
<p><img src="/.io//image-20240901150009165.png" alt="image-20240901150009165"></p>
<h3 id="2-基于redis实现滑动窗口"><a href="#2-基于redis实现滑动窗口" class="headerlink" title="2.基于redis实现滑动窗口"></a>2.基于redis实现滑动窗口</h3><p><img src="/.io//image-20240901150343365.png" alt="image-20240901150343365"></p>
<p><img src="/.io//image-20240901150351809.png" alt="image-20240901150351809"></p>
<p><img src="/.io//image-20240901150413652.png" alt="image-20240901150413652"></p>
<p><img src="/.io//image-20240901150427614.png" alt="image-20240901150427614"></p>
<p><img src="/.io//image-20240901150520618.png" alt="image-20240901150520618"></p>
<p><img src="/.io//image-20240901150532288.png" alt="image-20240901150532288"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitWindows</span> &#123;</span><br><span class="line">   <span class="comment">//计数器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">allowRequest</span><span class="params">(Jedis jedis,String key)</span>&#123;</span><br><span class="line">      <span class="comment">//当前时间</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="comment">//窗口开始时间：当前时间-60s</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">windowStart</span> <span class="operator">=</span> System.currentTimeMillis() - <span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">      <span class="comment">//删除窗口开始时间之前的所有数据</span></span><br><span class="line">      jedis.zremrangeByScore(key,<span class="string">&quot;-inf&quot;</span>,String.valueOf(windowStart));</span><br><span class="line">      <span class="comment">//计算总请求数</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> jedis.zcard(key);</span><br><span class="line">      <span class="comment">//判断</span></span><br><span class="line">      <span class="keyword">if</span>(current&lt;limit)&#123;</span><br><span class="line">         <span class="comment">//窗口足够则把当前请求加入</span></span><br><span class="line">         jedis.zadd(key,currentTime,String.valueOf(currentTime));</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上高并发下可能会出现原子性问题，那么我们可以考虑用LUA脚本实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitWindows</span> &#123;</span><br><span class="line">   <span class="comment">//计数器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">allowRequest</span><span class="params">(Jedis jedis,String key)</span>&#123;</span><br><span class="line">      <span class="comment">//获取当前时间戳</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">String</span> <span class="variable">luaScript</span> <span class="operator">=</span> <span class="string">&quot;local window_start_time = ARGV[1] -ARGV[3]*1000 &quot;</span> +</span><br><span class="line">              <span class="string">&quot; redis.call(&#x27;ZREMRANGEBYSCORE&#x27;,KEYS[1],&#x27;-inf&#x27;,window_start_time) &quot;</span> +</span><br><span class="line">              <span class="string">&quot; local now_request = redis.call(&#x27;ZCARD&#x27;,KEYS[1]) &quot;</span> +</span><br><span class="line">              <span class="string">&quot; if now_request &lt; tonumber(ARGV[2]) then &quot;</span> +</span><br><span class="line">              <span class="string">&quot; redis.call(&#x27;ZADD&#x27;,KEYS[1],ARGV[1],ARGV[1]) &quot;</span> +</span><br><span class="line">              <span class="string">&quot;     return 1 &quot;</span> +</span><br><span class="line">              <span class="string">&quot;else &quot;</span> +</span><br><span class="line">              <span class="string">&quot;      return 0 &quot;</span> +</span><br><span class="line">              <span class="string">&quot; end &quot;</span>;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(luaScript, <span class="number">1</span>, key, String.valueOf(currentTime), String.valueOf(limit), String.valueOf(<span class="number">60</span>));</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">long</span>) result == <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis实现限流的方法</p>
<p>1.固定窗口限流，为&#x3D;&#x3D;每个用户分配一个计数器，并设置一个时间窗口&#x3D;&#x3D;，&#x3D;&#x3D;在这个时间窗口内，用户可以发送一定数量的请求&#x3D;&#x3D;</p>
<p>2.滑动窗口限流，&#x3D;&#x3D;将时间窗口分成更小的时间片&#x3D;&#x3D;，对于&#x3D;&#x3D;每个时间片使用一个单独redis键来记录这段时间内的请求数量&#x3D;&#x3D;，当新的请求到来时，检查当前时间片及其之前一段时间片的总请求数量是否超过限制</p>
<p>3.令牌桶&#x3D;&#x3D;允许突发流量的存在&#x3D;&#x3D;，并且&#x3D;&#x3D;可以平滑地处理持续的正常流量&#x3D;&#x3D;，在这个模型中,系统按照恒定的速度向桶中添加令牌，而请求则需要从桶中取出令牌才能通过</p>
<p><img src="/.io//image-20240904153033974.png" alt="image-20240904153033974"></p>
<p>4.漏桶限流</p>
<p>漏桶算法的工作原理是水（请求）进入一个有孔的桶（限速机制），如果水流入速度超过桶的流出速度，桶就会溢出（丢弃多余的请求）。</p>
<p><img src="/.io//image-20240904155636755.png" alt="image-20240904155636755"></p>
</blockquote>
<h3 id="3-用户的会话信息是怎么管理的"><a href="#3-用户的会话信息是怎么管理的" class="headerlink" title="3.用户的会话信息是怎么管理的"></a>3.用户的会话信息是怎么管理的</h3><h3 id="4-ip归属地如果遇到了虚拟IP怎么办？"><a href="#4-ip归属地如果遇到了虚拟IP怎么办？" class="headerlink" title="4.ip归属地如果遇到了虚拟IP怎么办？"></a>4.ip归属地如果遇到了虚拟IP怎么办？</h3><blockquote>
<h3 id="1-IP验证"><a href="#1-IP验证" class="headerlink" title="1. IP验证"></a>1. IP验证</h3><p>首先尝试验证IP地址的有效性和真实性。可以使用第三方服务或开源工具来检查IP地址是否属于已知的代理服务器、数据中心或可疑网络</p>
<h3 id="2-行为分析"><a href="#2-行为分析" class="headerlink" title="2. 行为分析"></a>2. 行为分析</h3><p>分析用户的行为模式，如果用户的行为与他们声称的位置不符，可能需要进一步调查。例如，如果一个声称来自美国的用户却在深夜频繁访问中国网站，这可能是虚假IP的一个迹象。</p>
<h3 id="3-添加额外的限制访问"><a href="#3-添加额外的限制访问" class="headerlink" title="3. 添加额外的限制访问"></a>3. 添加额外的限制访问</h3><p>对于疑似虚假IP地址的请求，可以暂时限制其访问权限或增加额外的身份验证步骤。例如，可以限制登录尝试次数或要求用户提供更多信息来验证身份。</p>
</blockquote>
<h3 id="5-项目里为什么使用RocketMQ，而不用RabbitMQ和Kafka？"><a href="#5-项目里为什么使用RocketMQ，而不用RabbitMQ和Kafka？" class="headerlink" title="5.项目里为什么使用RocketMQ，而不用RabbitMQ和Kafka？"></a>5.项目里为什么使用RocketMQ，而不用RabbitMQ和Kafka？</h3><p><img src="/.io//image-20240901152810001.png" alt="image-20240901152810001"></p>
<blockquote>
<p>总结一下</p>
<ul>
<li><p>&#x3D;&#x3D;RabbitMQ：&#x3D;&#x3D;</p>
</li>
<li><p>优点：轻量、迅捷、容易部署和使用、拥有灵活的路由配置</p>
</li>
<li><p>缺点：性能和吞吐量不理想、不易进行二次开发</p>
</li>
<li><p>&#x3D;&#x3D;RocketMQ&#x3D;&#x3D;：</p>
</li>
<li><p>优点：性能好、高吞吐量、稳定可靠、有活跃的中文社区</p>
</li>
<li><p>缺点：兼容性上不是太好</p>
</li>
<li><p>&#x3D;&#x3D;Kafka：&#x3D;&#x3D;</p>
</li>
<li><p>优点：拥有强大的性能及吞吐量，兼容性很好</p>
</li>
<li><p>缺点：由于“攒一波再处理”导致延迟比较高</p>
</li>
</ul>
</blockquote>
<p>我们的系统是面向用户的C端系统，具有一定的并发量，对性能也有比较高的要求，所以选择了低延迟、吞吐量比较高，可用性比较好的RocketMQ</p>
<blockquote>
<p>&#x3D;&#x3D;RocketMQ&#x3D;&#x3D;的优点：</p>
<ul>
<li><p>单机吞吐量：十万级</p>
</li>
<li><p>可用性：非常高，分布式架构</p>
</li>
<li><p>消息可靠性：经过参数优化配置，消息可以作到0丢失</p>
</li>
<li><p>功能支持：MQ功能较为完善，还是分布式的，扩展性好</p>
</li>
<li><p>支持10亿级别的消息堆积，不会因为堆积导致性能下降</p>
</li>
<li><p>源码是java，方便结合公司自己的业务二次开发</p>
</li>
<li><p>天生为金童互联网领域而生，对于可靠性要求很高的场景，尤其是电商里的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</p>
</li>
<li><p>RocketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果业务上有并发场景，建议可以选择RocketMQ</p>
</li>
</ul>
<p>&#x3D;&#x3D;RocketMQ的缺点：&#x3D;&#x3D;</p>
<ul>
<li>支持的客户端语言不多：目前是java以及c++，c++不成熟、</li>
<li>没有在MQ核心中去实现JMS接口，有些系统要迁移需要修改大量代码</li>
</ul>
</blockquote>
<h3 id="6-RocketMQ的高可用体现在哪？"><a href="#6-RocketMQ的高可用体现在哪？" class="headerlink" title="6.RocketMQ的高可用体现在哪？"></a>6.RocketMQ的高可用体现在哪？</h3><blockquote>
<ul>
<li>NameServer</li>
</ul>
<p>核心组件之一，负责维护群元数据，如Broker的地址信息。名称服务自身是一个&#x3D;&#x3D;无状态的&#x3D;&#x3D;集群，具备高可用性。即使部分NameServer节点宕机，也不会影响生产和消费者，&#x3D;&#x3D;因为客户端会自动切换到其他可用的NameServer节点&#x3D;&#x3D;。</p>
<ul>
<li>主从复制</li>
</ul>
<p>RocketMQ的Broker组件可以配置为主从复制模式.在这种模式下,消息首先写入Master Broker,然后同步或异步复制到Slave Broker.如果Master Broker发生故障,Slave Broker可以迅速接管服务,保证消息服务的连续性</p>
<ul>
<li>自动故障转移</li>
</ul>
<p>在主从复制的基础上，&#x3D;&#x3D;RocketMQ 支持自动故障转移机制&#x3D;&#x3D;。&#x3D;&#x3D;当 Master Broker 故障时，系统可以自动将 Slave Broker 提升为新的 Master Broker&#x3D;&#x3D;，这一过程可以是手动的也可以是自动化的。</p>
<ul>
<li>集群模式</li>
</ul>
<p>Broker 可以组成集群，每个 Broker 实例都可以接收消息。&#x3D;&#x3D;RocketMQ 的集群模式支持消息的分区（Partitioning）&#x3D;&#x3D;，&#x3D;&#x3D;可以将消息均匀地分布到集群中的各个 Broker 上&#x3D;&#x3D;，从而提高了系统的整体可用性和吞吐量。</p>
<ul>
<li>多副本存储</li>
</ul>
<p>RocketMQ &#x3D;&#x3D;支持多副本存储机制&#x3D;&#x3D;，可以在&#x3D;&#x3D;不同的机器上保存消息的多个副本&#x3D;&#x3D;。这种方式可以提高数据的可靠性和系统的容错能力，即使部分机器出现故障，仍然可以从其他副本中恢复数据。</p>
<ul>
<li>平衡负载</li>
</ul>
<p>RocketMQ 的客户端可以自动发现和负载均衡到不同的 Broker 实例，从而平衡系统负载，提高系统的处理能力和稳定性。</p>
<ul>
<li>消息重试机制</li>
</ul>
<p>RocketMQ 支持消息的重试机制，当消息消费失败时，可以根据配置自动重试。这种方式可以确保消息不会因为临时性的故障而丢失</p>
<ul>
<li>事务消息</li>
</ul>
<p>事务消息是 RocketMQ 的一个高级特性，它可以确保消息的发送和业务操作的一致性。即使在发送过程中发生故障，也可以通过回查机制来保证最终一致性。</p>
</blockquote>
<img src="/.io//image-20240901162828781.png" alt="image-20240901162828781" style="zoom:80%;">

<h3 id="8-微信登录涉及到的CAS单点登录问题"><a href="#8-微信登录涉及到的CAS单点登录问题" class="headerlink" title="8.微信登录涉及到的CAS单点登录问题"></a>8.微信登录涉及到的CAS单点登录问题</h3><p><img src="/.io//image-20240901220722551.png" alt="image-20240901220722551"></p>
<h3 id="11-二级缓存框架"><a href="#11-二级缓存框架" class="headerlink" title="11.二级缓存框架"></a>11.二级缓存框架</h3><p>使用两级缓存相比单纯使用远程缓存,具有什么优势呢?</p>
<ul>
<li>本地缓存&#x3D;&#x3D;基于本地环境的内存&#x3D;&#x3D;,&#x3D;&#x3D;访问速度非常快&#x3D;&#x3D;,对于一些&#x3D;&#x3D;变更速率低,实时性要求低&#x3D;&#x3D;的数据,&#x3D;&#x3D;可以放在本地缓存中&#x3D;&#x3D;,提升访问速度</li>
<li>使用&#x3D;&#x3D;本地缓存能够减少和Redis类的远程缓存间的数据交互&#x3D;&#x3D;,减少网络I&#x2F;O开销,降低这一过程中在网络通信上的耗时</li>
</ul>
<blockquote>
<p>问题</p>
<p>如果是在分布式环境下,&#x3D;&#x3D;一级缓存之间也会存在一致性问题&#x3D;&#x3D;,当一个节点下的本地缓存修改后,需要通知其他节点也刷新本地缓存中的数据,否则会出现读取到过期数据的情况,这一问题可以通过类似Redis中的发布订阅功能解决</p>
<p>此外缓存的过期时间,过期策略以及多线程访问的问题也都需要考虑进去</p>
</blockquote>
<h2 id="11-IM系统设计"><a href="#11-IM系统设计" class="headerlink" title="11.IM系统设计"></a>11.IM系统设计</h2><blockquote>
<p>IM系统首先要关注的问题</p>
<p>1.集群消息的路由：</p>
<ul>
<li>a，b不在同一websocket服务上，怎么进行通信</li>
<li>点对点&#x2F;广播</li>
</ul>
<p>2.消息的时序性：</p>
<ul>
<li>根据时间&#x2F;根据id</li>
<li>全局时序</li>
<li>会话的时序</li>
<li>收信箱时序</li>
</ul>
<p>3.消息id生成：</p>
<ul>
<li>唯一保证</li>
<li>顺序保证：1.单调递增2.趋势递增</li>
</ul>
<p>4.消息可靠ACK：</p>
<ul>
<li>发送可靠&#x2F;推送可靠</li>
<li>在线推送可靠&#x2F;离线推送可靠</li>
</ul>
<p>5.消息重复：</p>
<ul>
<li>分布式特性：可靠就会重试、重试就会重复、重复就要进行幂等</li>
<li>前端重复发</li>
<li>后端重复推</li>
</ul>
<p>6.推拉结合</p>
<ul>
<li>推拉结合，平衡时效性和可靠性</li>
</ul>
<p>7.多端同步</p>
<p>8.单聊群聊：怎么兼容单聊和群聊的消息存储与推送</p>
<p>9.消息已读与未读：已读未读，同时关联到用户读取消息的设计，如果是全员群，每一条消息又是指数级上升</p>
<p>10.热点群扩散风暴：全员群人很多，一条消息写入所有成员的心想，就是成倍的扩散系数增长</p>
<p>11.表结构设计：</p>
<ul>
<li>多类型消息表结构设计</li>
<li>用户收信箱表结构设计</li>
<li>已读未读表结构设计</li>
<li>单聊群聊表结构设计</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;首先IM项目是web项目，不会存储消息，和客户端IM不同，因此，mallchat的实现方案并不是最好的，但是会提及怎样设计能达到更好的效果&#x3D;&#x3D;</p>
<p><img src="/.io//1692717057362-3de0b048-1963-4a27-9d6e-bf599ea8beff.webp" alt="集群推送 (1).jpg"></p>
<p><code>WebSocket</code>：维护和用户的连接通道，可以接收消息，也可以推送消息，为<strong>有状态服务</strong></p>
<p><code>IM服务</code>：负责消息的发送逻辑，处理单聊群聊的消息</p>
<p><code>Auth服务</code>：处理用户认证，权限等需求</p>
<p><code>Router</code>：推送消息时，不同用户在不同<code>WebSocket</code>服务上，确保正确推送，与可靠推送。</p>
<blockquote>
<p>交互的流程：</p>
</blockquote>
<p>1.用户和<code>websocket</code>服务建立连接之后。之后都通过该连接发送消息，接收消息。</p>
<p>2.用户A发送了一条信息“在吗”，WebSocket服务通过dubbo转发给&#x3D;&#x3D;IM服务&#x3D;&#x3D;，由于&#x3D;&#x3D;IM服务是无状态的&#x3D;&#x3D;，所以可以通过负载均衡随机发到某一台上</p>
<p>3.&#x3D;&#x3D;IM服务将消息持久化&#x3D;&#x3D;，然后将消息发送到&#x3D;&#x3D;消息队列MQ&#x3D;&#x3D;，这样能快速响应前端，&#x3D;&#x3D;并且mq的消费者&#x3D;&#x3D;根据负载慢慢的进行后续的推送，写扩散等操作。</p>
<p>4.&#x3D;&#x3D;消费者会判断&#x3D;&#x3D;，根据是否是热点群聊的消息做不同逻辑（查看consumer如何做逻辑）。&#x3D;&#x3D;如果是热点群聊，只写热点信箱&#x3D;&#x3D;。如果是单聊或普通群聊，会写扩散到&#x3D;&#x3D;每个群成员信箱&#x3D;&#x3D;，这里&#x3D;&#x3D;假设是小群，会写入B和C的信箱&#x3D;&#x3D;。</p>
<p>5.将消息投递信箱后，需要将消息推送给用户。这里可以根据是否在线，&#x3D;&#x3D;在线的进行WebSocket推送，离线的进行push通知&#x3D;&#x3D;。用于用户连接在不同的Websocket，&#x3D;&#x3D;需要Router服务推送到B和C所在的不同WebSocket方案有两种&#x3D;&#x3D;，后续介绍。</p>
<p>6.推送的时候需要确保消息的可靠性，&#x3D;&#x3D;如何保证一定推送成功？可能要做应用层的ack，类似tcp的滑动窗口确认&#x3D;&#x3D;。</p>
<p>7.用户&#x3D;&#x3D;在查询自己的会话列表的时候&#x3D;&#x3D;，需要有一个&#x3D;&#x3D;聚合层聚合用户信箱&#x3D;&#x3D;，&#x3D;&#x3D;以及热点信箱&#x3D;&#x3D;。再&#x3D;&#x3D;严格排序后返回给用户&#x3D;&#x3D;。所谓之推拉结合</p>
<h3 id="1-集群推送"><a href="#1-集群推送" class="headerlink" title="1.集群推送"></a>1.集群推送</h3><p>http和websocket的底层其实都是依赖tcp建立连接进行通信的。他们的差别就是：</p>
<p>1.http是无状态的。每次请求都会重新握手建立tcp链接再发送消息，并获取响应。因此http请求可以随意的进行负载均衡。第一次请求发给了机器A，第二次请求就发给了机器B。</p>
<p>2.websocket是有状态的，当他建立tcp连接后，就会一直复用那个连接进行通信。假设一开始连上了机器A，收发信息就一直在机器A。直到连接断开，重连后才会更换连接</p>
<p><img src="/.io//1692879184758-c8e488ec-80a6-408a-96bf-1dfe1c0f4b5c.webp" alt="img"></p>
<p>我们项目用的<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/mallchat/skb0r8tesr7yitvf">netty</a>来实现websocket，和用户的连接就是一个channel。需要给用户推送消息的时候，直接往<code>channel</code>里面<code>write</code>消息就好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给本地channel发送消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wsBaseResp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(Channel channel, WSBaseResp&lt;?&gt; wsBaseResp)</span> &#123;</span><br><span class="line">    channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(JSONUtil.toJsonStr(wsBaseResp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/mallchat/bsld797perd3xb85">微信登录技术方案</a>，我们已经描述了如何在用户登录的时候，将uid和channel关联起来缓存在jvm的map里，这样要推送的时候只需要通过uid取出channel进行推送。</p>
<p><img src="/.io//1692880369836-f4bc0cfd-2855-4435-b846-be1ec7b115ed.webp" alt="image.png"></p>
<p>但是在集群的场景，这样的方案就失效了。</p>
<p><img src="/.io//1692880732535-9ae1c5f8-395b-4afc-80c7-bb6036f980f2.webp" alt="image.png"></p>
<p>你要推送的用户，&#x3D;&#x3D;在别的机器上，你怎么找到对应的机器&#x3D;&#x3D;？&#x3D;&#x3D;根本的原因是因为连接的管理在jvm层面&#x3D;&#x3D;，假设A要发消息给C，我们不知道C在哪一台<code>WebSocket</code>。&#x3D;&#x3D;所以这时候可以借助一个中心化的中间件，比如redis，来存储他们的关系&#x3D;&#x3D;。</p>
<h4 id="1-redis存储Channel"><a href="#1-redis存储Channel" class="headerlink" title="1.redis存储Channel"></a>1.redis存储Channel</h4><p>这个方案是最不可行的方案。由于channel和uid的关系是存在了本地，导致我们想推送消息给C的时候拿不到channel。</p>
<p><img src="/.io//1692887667160-3fcbe508-9da1-451e-8f55-476d2e95ee00.webp" alt="image.png"></p>
<p>有个小伙伴想着既然websocket的部署了，想使用中心化的redis来存uid和channel映射关系。通过redis.get(uid)拿到字符串来，并反序列化成channel，然后发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">( WSBaseResp&lt;?&gt; wsBaseResp,Long uid)</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RedisUtils.get(uid.toString(), Channel.class);</span><br><span class="line">    channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(JSONUtil.toJsonStr(wsBaseResp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这样会报错的，&#x3D;&#x3D;channel是本地的socket连接&#x3D;&#x3D;，&#x3D;&#x3D;没法进行存储与反序列化&#x3D;&#x3D;。（我理解的是其实他也是&#x3D;&#x3D;包含状态的&#x3D;&#x3D;，&#x3D;&#x3D;包含状态的信息是没办法存储在redis中的&#x3D;&#x3D;）。</p>
<h4 id="2-精准投递消息"><a href="#2-精准投递消息" class="headerlink" title="2.精准投递消息"></a>2.精准投递消息</h4><p>可以对上面的方案优化下，本地依然要维护uid和channel的关系（&#x3D;&#x3D;这是整个业务的根基&#x3D;&#x3D;），redis再维护一个用户的连接状态，&#x3D;&#x3D;比如用户在哪台机器上连接。这样通过router发送消息的时候，就知道用户的信息应该发送到哪台机器上&#x3D;&#x3D;。</p>
<p><img src="/.io//1692890899542-df7b7384-41db-4a7b-8a8a-c0730153e632.webp" alt="image.png"></p>
<p>大概的流程如下：</p>
<p>1.&#x3D;&#x3D;A发送了一条给C的消息&#x3D;&#x3D;。&#x3D;&#x3D;通过channel发送给了10.102.1.1这台websocket&#x3D;&#x3D;，它通过dubbo将消息随意转发给了一台IM服务器。</p>
<p>2&#x3D;&#x3D;.IM服务将消息持久化后，调用Router&#x3D;&#x3D;，推送消息给C</p>
<p>3.&#x3D;&#x3D;Router查redis的中心化管理&#x3D;&#x3D;，查到C目前连接在10.102.1.2上，&#x3D;&#x3D;并通过tcp连接将C的消息推送给10.102.1.2&#x3D;&#x3D;。&#x3D;&#x3D;Router会和所有websocket都维护一条tcp连接&#x3D;&#x3D;。查到具体的ip后，对指定websocket服务器进行推送。</p>
<p>4.websocket服务收到的&#x3D;&#x3D;请求格式为给uid发送xx消息&#x3D;&#x3D;，所以它&#x3D;&#x3D;会通过uid在本地的连接管理&#x3D;&#x3D;中，&#x3D;&#x3D;查出用户具体的channel&#x3D;&#x3D;、然后调用&#x3D;&#x3D;channel.write（消息）&#x3D;&#x3D;方法，给用户推送消息。</p>
<blockquote>
<p>方案存在的问题</p>
</blockquote>
<p>1.需要频繁的更新redis去维护&#x3D;&#x3D;用户和websocket服务的映射&#x3D;&#x3D;。（这个是小问题，因为我们正好需要做用户的上下线，也复用这个功能）</p>
<p>2.连接数爆炸：&#x3D;&#x3D;websocket的瓶颈就在连接数，如果连接满了，就要水平扩容websocket&#x3D;&#x3D;，这样才能，这样才能支撑更多人同时在线，如果用户体量非常大，甚至需要上千个websocket和上千个router。</p>
<p><img src="/.io//1692889700004-bff5fd35-06d2-40f3-9251-f54034a261a6.webp" alt="image.png"></p>
<pre><code>这其实是一种很可怕的事，==单纯的路由连接就达到上千，占用了websocket的连接资源==，导致一台`websocket`能连接的用户数变少。

==这种问题其实也会出现在dubbo服务中，dubbo单实例集群达到1000以上，他们是怎么做的呢？==

由于==传统的service服务都是**无状态**的==，==我们的连接可以**分组管理**==。==每台service只需要和少数的下游实例维护tcp连接即可==，不需要连接所有。

但是==websocket是有状态的，一台`router`必须连接所有的`websocket`==，他的消息有可能需要路由到任意一台`websocket`上。
</code></pre>
<p><img src="/.io//1692890136311-be25b8bb-9951-4524-af6b-485c61c30b8e.webp" alt="image.png"></p>
<pre><code>我们可以用==分层路由==的思想，中间加一层路由，设定路由规则。==这样可以**有效减少连接数**==，但是==会**增加消息的推送链路**==，适用于真的很大型的集群场景。

当然还有很多方案，甚至我们可以思考，==为啥去保证tcp连接？如果每次发消息都建立tcp连接，那就是三次握手3倍的RTT==。如果我们不在乎这些连接耗时，==也可以直接采用**http推送**，或者**临时建立连接**的方式==。
</code></pre>
<p><img src="/.io//1694837770260-94c263b1-4042-48c7-be8f-4baf95cca63e.webp" alt="image.png"></p>
<p>这种订阅表，&#x3D;&#x3D;路由节点，就也有点像分布式集群的mq&#x3D;&#x3D;，感兴趣可以看看<a target="_blank" rel="noopener" href="https://www.emqx.io/docs/zh/v5.2/deploy/cluster/introduction.html">文档</a></p>
<ol>
<li>实现复杂，&#x3D;&#x3D;需要指定ip推送，维护tcp连接。如果用dubbo会稍微简单些&#x3D;&#x3D;。</li>
<li><code>**消息发送开销**</code>：对于群聊，&#x3D;&#x3D;多个接收者需要发送多份消息的副本&#x3D;&#x3D;，增加了消息发送的开销（这个对比后面的方案就能理解）</li>
<li><code>**延迟叠加**</code><strong>：</strong> &#x3D;&#x3D;哪怕开启了多线程，也依然会有一台机器的单点&#x3D;&#x3D;，&#x3D;&#x3D;需要对所有的群成员进行消息的<strong>扇出</strong>（写扩散）&#x3D;&#x3D;。这里会导致接收者接到的消息延迟叠加。（当然，&#x3D;&#x3D;用线程池异步扇出可以提高速度，但是会回到问题4，总体开销依然是不变的&#x3D;&#x3D;）</li>
<li><code>**雪崩问题**</code>：&#x3D;&#x3D;如果系统负载提高，比如需要推送的消息量突然变大，导致瓶颈从<code>websocket</code>一直传导到<code>router</code>再传到<code>im服务</code>&#x3D;&#x3D;，整个集群会出现雪崩，&#x3D;&#x3D;需要有一个消息队列来进行削峰填谷&#x3D;&#x3D;。</li>
</ol>
<h4 id="3-Router是什么？"><a href="#3-Router是什么？" class="headerlink" title="3.Router是什么？"></a>3.Router是什么？</h4><p>router是为了&#x3D;&#x3D;让你能够精准投递的重要功能&#x3D;&#x3D;。</p>
<p><strong>他可以是一个服务</strong>，&#x3D;&#x3D;这样你的消息只需要发送到任意一个router上&#x3D;&#x3D;，&#x3D;&#x3D;他就能帮你转发到对应的websocket&#x3D;&#x3D;。</p>
<p>他也可以**&#x3D;&#x3D;是一个SDK&#x3D;&#x3D;**，这样&#x3D;&#x3D;减少一次服务与Router服务的交互&#x3D;&#x3D;，&#x3D;&#x3D;简短链路&#x3D;&#x3D;(发送完直接断开)。&#x3D;&#x3D;SDK提供的能力就是根据接收人UID，去redis查到UID所在位置，直接精准请求到Websocket服务&#x3D;&#x3D;。</p>
<blockquote>
<p>Router作为服务</p>
<p>功能描述</p>
<ul>
<li>消息接收：接收来自客户端或其他服务的消息。</li>
<li>消息路由：根据消息的目的地（通常是用户的唯一标识符，如UID），将消息转发到正确的websocket连接。</li>
<li>状态维护：维护一个映射表。记录每个用户的uid与websocket连接的对应关系</li>
</ul>
<p>技术选型：</p>
<ul>
<li>后端语言：可以选择使用Node.js、Go、Python等语言来实现服务端逻辑</li>
<li>数据库&#x2F;缓存：使用Redis或其他内存数据库来存储用户的UID与WebSocket连接信息。</li>
<li>WebSocket框架：使用成熟的WebSocket库、如Socket.IO、ws等</li>
</ul>
<p>实现步骤：</p>
<p>1.建立用户映射：</p>
<ul>
<li><p>服务启动时，&#x3D;&#x3D;所有服务器的websocket服务&#x3D;&#x3D;还会&#x3D;&#x3D;跟router之间&#x3D;&#x3D;建立一个连接</p>
</li>
<li><p>当&#x3D;&#x3D;IM服务启动登录时&#x3D;&#x3D;，要在&#x3D;&#x3D;中心管理redis中存储一份用户和服务器之间的对应关系&#x3D;&#x3D;（由于&#x3D;&#x3D;每一次刷新时都会进行重新建立连接&#x3D;&#x3D;，所以&#x3D;&#x3D;刷新之后就会重新更新到redis中&#x3D;&#x3D;）</p>
</li>
</ul>
<p>2.消息转发：</p>
<ul>
<li>当IM服务调用时，&#x3D;&#x3D;Router会向Redis中发送查询&#x3D;&#x3D;查看&#x3D;&#x3D;目标uid所在的服务器&#x3D;&#x3D;，然后&#x3D;&#x3D;根据这个服务器所建立的websocket连接&#x3D;&#x3D;发送自己的消息</li>
</ul>
<p>3.心跳与超时处理：</p>
<ul>
<li>为了保证连接的有效性，可以&#x3D;&#x3D;设置心跳机制来检测连接状态&#x3D;&#x3D;。</li>
<li>如果&#x3D;&#x3D;发现某个连接长时间未响应心跳&#x3D;&#x3D;，则从Redis中移除该用户的映射关系</li>
</ul>
<p>Router作为SDK（&#x3D;&#x3D;SDK就是一组工具、文档、样本代码和其他资源的集合&#x3D;&#x3D;）</p>
<p>功能描述：</p>
<ul>
<li><strong>客户端集成</strong>：将 Router 功能集成到客户端 SDK 中。</li>
<li><strong>直接转发</strong>：客户端 SDK 负责根据接收人的 UID 直接找到对应的 WebSocket 连接并发送消息。</li>
<li><strong>减少交互</strong>：通过在客户端实现 Router 功能，减少一次客户端与 Router 服务之间的交互。</li>
</ul>
<h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h4><ul>
<li><strong>前端语言</strong>：可以使用 JavaScript、TypeScript 等语言来实现客户端 SDK。</li>
<li><strong>WebSocket 库</strong>：使用 WebSocket API 或成熟的前端 WebSocket 库（如 socket.io-client）。</li>
</ul>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li><strong>初始化 SDK</strong>：<ul>
<li>&#x3D;&#x3D;在客户端初始化 SDK 时，连接到 WebSocket 服务器&#x3D;&#x3D;，并注册用户的 UID。</li>
<li>将用户的 &#x3D;&#x3D;UID 与 WebSocket 连接信息保存在本地（如浏览器的 localStorage 或 sessionStorage）&#x3D;&#x3D;。</li>
</ul>
</li>
<li><strong>消息发送</strong>：<ul>
<li>当需要发送消息时，&#x3D;&#x3D;SDK 根据接收人的 UID 查询本地存储，获取其 WebSocket 连接信息&#x3D;&#x3D;。</li>
<li>如果本地找不到接收人的连接信息，&#x3D;&#x3D;则向后端的 Router 服务查询&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;将消息直接发送到目标用户的 WebSocket 连接&#x3D;&#x3D;。</li>
</ul>
</li>
<li><strong>状态同步</strong>：<ul>
<li>客户端 &#x3D;&#x3D;SDK 应该定期与后端同步用户的连接状态，以确保本地缓存是最新的&#x3D;&#x3D;。</li>
<li>&#x3D;&#x3D;当用户断开连接时，客户端 SDK 应该清除本地存储中的连接信息&#x3D;&#x3D;，并通知后端更新状态。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="4-集群广播消息"><a href="#4-集群广播消息" class="headerlink" title="4.集群广播消息"></a>4.集群广播消息</h4><p>针对于以上精准推送的问题有一种方案，能够无需维护连接，消息的发送只需要一个消息副本，并且没有消息删除的压力，只需要写一次。这个就是集群广播。</p>
<p><img src="/.io//1692892642246-a075665f-3fa5-4ca3-8051-be63c751b222.webp" alt="image.png"></p>
<p>对于万人群聊来说，一般系统的压力就在于消息的&#x3D;&#x3D;扇出（写扩散）&#x3D;&#x3D;。如果按照精准投递的话，消息需要查询redis中心路由，然后将消息投递1w次（&#x3D;&#x3D;这个之所以是扇出的压力，主要是因为IM要查询1w次然后分别去推，也就是投递，如果是让各个服务去拉就可以将压力转移&#x3D;&#x3D;），&#x3D;&#x3D;而如果用消息广播的形式，消息只需要投递一次。由WebSocket自己进行广播消息的拉取和过滤。&#x3D;&#x3D;</p>
<h5 id="过滤流程"><a href="#过滤流程" class="headerlink" title="过滤流程"></a>过滤流程</h5><p><img src="/.io//1692893036052-76bbecc3-741f-43ba-a6f1-c0d15c7cebb8.webp" alt="image.png"></p>
<p>1.mq的消费模式为&#x3D;&#x3D;广播消费模式&#x3D;&#x3D;（同一消费组所有消费实例能够消费到），确保&#x3D;&#x3D;每台websocket都能消费到所有需要投递的消息&#x3D;&#x3D;。</p>
<p>2.对比推送的uid在不在&#x3D;&#x3D;本地连接管理的列表&#x3D;&#x3D;，如果不在，直接丢弃消息，也叫过滤消息。</p>
<p>3.如果在本地连接管理，根据uid取出channel，就可以进行消息推送了</p>
<h5 id="优化1：消息副本优化"><a href="#优化1：消息副本优化" class="headerlink" title="优化1：消息副本优化"></a>优化1：消息副本优化</h5><p>集群广播和精准投递比起来，消息副本少了很多。但是如果用刚刚的图展示，可能暂时看不出效果。</p>
<p><img src="/.io//1692893821809-f1f05bb6-a1e7-44e3-b2c8-56e3518f7a67.webp" alt="image.png"></p>
<p>这样比较起来，反而是集群广播的消息副本整体多了。假设B发送消息给<strong>A</strong>和<strong>C</strong>。</p>
<p>精准投递总共传输了2*3&#x3D;6份消息，集群广播传输了2 * 4&#x3D;8份消息。</p>
<p>&#x3D;&#x3D;既然是集群广播，就需要利用好集群的特点&#x3D;&#x3D;</p>
<p>一份消息&#x3D;&#x3D;由uid和消息体组成&#x3D;&#x3D;，uid对应的就是紫色方块，消息体就是对应的黑色信封，一&#x3D;&#x3D;般消息体远大于uid&#x3D;&#x3D;</p>
<p><img src="/.io//1692894214945-2b25da5e-e51f-499f-89eb-0f0088efb6e6.webp" alt="image.png"></p>
<p>在万人群聊下，其实大家收到的消息都一样的，可以共用一个消息副本，我们在投递消息进mq的时候，可以设置投递的消息为<code>list&lt;long&gt;</code>的<code>uids</code>。而不是拆成多次的消息投递.（&#x3D;&#x3D;如果是群聊的情况下，发送的消息是一样的，但是uid是一串很多的，所以作为一个整体，不拆成多次消息的投递&#x3D;&#x3D;）</p>
<p>改造后的效果如下：</p>
<p><img src="/.io//1692894313076-bf5de3ae-6a1d-484a-bc23-4f6f86584618.webp" alt="image.png"></p>
<p>假设在&#x3D;&#x3D;万人群聊的情形下，差别显著&#x3D;&#x3D;</p>
<p>最后的链路发送给用户时都是1w                                                                 集群投递    最后的链路发送给用户时都是1w        </p>
<p>websocket链路发送了1w                     															               websocket发送了1份</p>
<p>写入的时候1w																													IM服务发送到mq中了1份</p>
<p>精准投递消息体一共就是1w份，uid也是1w份                                                              所以消息体是1w+3,uid是1w+2W+1W</p>
<blockquote>
<p>&#x3D;&#x3D;因为终端投递是省不了的&#x3D;&#x3D;，但是&#x3D;&#x3D;可见消息副本数大大下降&#x3D;&#x3D;。大家可能会觉得有些赖皮，1w个连接涉及到的websocket其实会有更多个。消息大小远大于uid，我们以消息为准</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">精准投递：u*3份消息，u=群聊在线人数，3=消息传输的链路，固定值</span><br><span class="line">集群广播：u+n份消息，u=群聊在线人数，n=websocket的集群数，不固定，但是极小。</span><br></pre></td></tr></table></figure>

<p>可见&#x3D;&#x3D;该优化在大群聊下的效果有多强&#x3D;&#x3D;，&#x3D;&#x3D;当然其实集群广播方案也有缺点，就是在im中，<strong>小群聊甚至单聊的占比</strong>很大&#x3D;&#x3D;，在&#x3D;&#x3D;u很小，且n很大的情况下，集群广播就失去了他的优势&#x3D;&#x3D;。</p>
<h5 id="优化2：消息过滤优化"><a href="#优化2：消息过滤优化" class="headerlink" title="优化2：消息过滤优化"></a>优化2：消息过滤优化</h5><p>我们可知道&#x3D;&#x3D;消息内的uid过滤，都是在本地消费者逻辑去过滤的&#x3D;&#x3D;，不存在就直接丢弃消息。&#x3D;&#x3D;这时候大量与本<code>websocket</code>无关的消息都被拉取过来了&#x3D;&#x3D;，&#x3D;&#x3D;中间的网络io都浪费了&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;集群广播最大的毛病&#x3D;&#x3D;就在于，&#x3D;&#x3D;很多&#x3D;&#x3D;&#x3D;&#x3D;不属于我们websocket的消息推送，也会被我们读取&#x3D;&#x3D;，然后&#x3D;&#x3D;在本地过滤扔掉&#x3D;&#x3D;。这里&#x3D;&#x3D;浪费了<strong>网络IO</strong>，浪费了本地<strong>反序列化的cpu</strong>&#x3D;&#x3D;。</p>
<blockquote>
<p>解决1：可以通过设置header的方式。将uids存储在header里。这样拉取消息到消费端的时候，就可以在序列化前，先在mq的过滤器里过滤消息，节省不必要的反序列化</p>
<p>这里需要注意一点&#x3D;&#x3D;，header有长度限制。我们需要注意大群聊uid过多分批发送。或者群聊压根不过滤，就考虑单聊场景&#x3D;&#x3D;。有效</p>
</blockquote>
<hr>
<blockquote>
<p>RocketMQ 支持消息过滤功能，&#x3D;&#x3D;可以利用<code>SQL92</code>语法来定义过滤表达式。&#x3D;&#x3D;例如，可以定义如下过滤表达式：</p>
<p>java深色版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1consumer.subscribe(&quot;TopicTest&quot;, &quot;UserID=&#x27;uid123&#x27;&quot;);</span><br></pre></td></tr></table></figure>

<p>这样，RocketMQ 会在消息到达消费端之前进行过滤，只有符合条件的消息才会被传递给消费者</p>
</blockquote>
<hr>
<blockquote>
<p>解决2：上面的方案是在消费端（&#x3D;&#x3D;Rocketmq中的消费端&#x3D;&#x3D;）才过滤，只节省了反序列化。可以更进一步的在broker端进行过滤消息，直接节省IO的传输成本</p>
</blockquote>
<p><strong>这个方案有啥问题？</strong></p>
<p>其实问题也比较明显。&#x3D;&#x3D;每个websocket都需要接收<strong>全站所有消息</strong>的广播消息，然后内部进行过滤&#x3D;&#x3D;。&#x3D;&#x3D;如果全站的消息都是单聊消息，结果每个websocket都拉取消息，并且内部过滤，是带宽的浪费，以及cpu的浪费&#x3D;&#x3D;。</p>
<h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><p>根据前面的计算公式对比，我们很容易的得出一个简单的结论。</p>
<p>单聊消息多的，用精准投递。群聊消息多的，用广播消息。</p>
<p>对于抹茶，我们是有个全员群聊，很多个小群聊，和很多的单聊。发言频率最多的场景是全员群。所以抹茶最应该使用集群广播推送的方案。</p>
<p>接下来再讨论一个极端场景的解决方案。</p>
<h5 id="百万直播间推送方案-1"><a href="#百万直播间推送方案-1" class="headerlink" title="百万直播间推送方案"></a>百万直播间推送方案</h5><p>假设在抖音直播的场景下，一个热门的直播间<strong>100w</strong>人同时在线，大量的礼物，互动消息充斥在直播间，如何通知到每个人。保证消息的<strong>即时性</strong>，<strong>可靠性</strong>。</p>
<p>首先这明显更倾向于大群聊的一种场景，&#x3D;&#x3D;如果用精准投递，那么消息的扩散系数就是100w级&#x3D;&#x3D;。&#x3D;&#x3D;如果采用的是集群推送，假设100w的用户需要500台websocket进行连接&#x3D;&#x3D;，那么扩散系数只是500的级别。</p>
<p>但是这个假设是整个平台只有这个直播间，如果平台有更多的直播间。websocket会更多，mq的扩散系数也会更大。</p>
<p><img src="/.io//1694838682316-6244f4d6-f8b9-423e-8c3f-e16bf72f4141.webp" alt="image.png"></p>
<p>每个方案又都优缺点，而应对极端场景，通常都是方案的组合，扬长避短。很类似于我们后面会提到的推拉结合。</p>
<p>这个场景的方案，&#x3D;&#x3D;我们可以设置一个热门阈值，比如1w。超过1w的直播间，我们会进行直播间升级，升级成热门直播间&#x3D;&#x3D;。&#x3D;&#x3D;热门直播间的websocket单独管理。把直播间用户的websocket连接都统一路由到固定的几百台websocket上&#x3D;&#x3D;。由于目标用户都集中了，也就不需要精准投递了，&#x3D;&#x3D;可以采用广播投递消息到这指定500台机器上。再对应的推送给直播间的观众&#x3D;&#x3D;。</p>
<p>这个方案的核心，&#x3D;&#x3D;就是要能将直播间所有用户通过<strong>网关路由</strong>到相同的500台websocket上&#x3D;&#x3D;，有了这个基础，才能用广播消息，&#x3D;&#x3D;那500台websocket都监听同一个topic的<strong>广播mq消息</strong>&#x3D;&#x3D;。能省下很大的带宽开销。而消&#x3D;&#x3D;息的发送端，需要知道消息究竟是发送到热门直播间的topic进行<strong>集群广播</strong>还是普通直播间的<strong>精准推送</strong>&#x3D;&#x3D;。还是得依赖<strong>router</strong>服务进行路由推送。</p>
<p>几个功能细节;</p>
<p><code>热门直播间升级：</code>一开始的普通直播间，&#x3D;&#x3D;用户都分散在不同的websocket机器上&#x3D;&#x3D;。等到直播间人数突破阈值1w。就需要开始直播间的<strong>热点升级</strong>。这时候&#x3D;&#x3D;服务器检测到直播间需要升级&#x3D;&#x3D;，<strong>动态扩缩容</strong>，&#x3D;&#x3D;启动一系列配套措施（k8s&#x3D;&#x3D;现在已经使用的比较多了）。</p>
<p>一系列措施准备好后，&#x3D;&#x3D;相应的配置推送到网关路由机器上&#x3D;&#x3D;。指定&#x3D;&#x3D;以后该直播间的连接路由到我们新启动的50台websocket&#x3D;&#x3D;上。</p>
<p>然后&#x3D;&#x3D;对当前在线的所有用户发送断连替换指令&#x3D;&#x3D;。所有在线用户都断开连接，&#x3D;&#x3D;重连的时候会被网关路由到新的websocket上&#x3D;&#x3D;。优化：&#x3D;&#x3D;对于经常突破1w人的直播间，可以打个标&#x3D;&#x3D;。以后该直播间上线，默认就是热点，省略升级过程。</p>
<p><code>消息合并</code>：直播间的点赞操作，&#x3D;&#x3D;一般发生在主播求赞的时候，大量人在同一时间段点赞&#x3D;&#x3D;。&#x3D;&#x3D;并且单人在同一时间也快速点赞&#x3D;&#x3D;。可以&#x3D;&#x3D;在客户端对每个人的多次点赞首先进行合并一次（用户a点赞20）&#x3D;&#x3D;。请求到后端后，由于路由已经做好，在每个点赞服务器，&#x3D;&#x3D;可以对多人的点赞再合并一次（用户a+b总点赞40）&#x3D;&#x3D;，进行入库。&#x3D;&#x3D;给前端推送的时候，也可以合并推送，不需要每条点赞都推送。每隔1s推送一次直播间点赞总量达到（100w）&#x3D;&#x3D;</p>
<p><code>优先级隔离</code>：在100w直播间里，&#x3D;&#x3D;推送的消息会有很多。会导致部分消息到达产生延迟&#x3D;&#x3D;。这就类似push系统，&#x3D;&#x3D;消息应该<strong>区分优先级</strong>，不要被互相影响&#x3D;&#x3D;。&#x3D;&#x3D;大礼物，和主播发言消息，这些应该独立在一个广播topic里&#x3D;&#x3D;，其他的不重要的消息，&#x3D;&#x3D;可以设置另一个topic，区分优先级，不要影响重要消息&#x3D;&#x3D;。</p>
<h3 id="2-消息时序性"><a href="#2-消息时序性" class="headerlink" title="2.消息时序性"></a>2.消息时序性</h3><p>消息时序性，主要解决的就是消息展示的顺序问题。它为啥那么难？</p>
<p>如果&#x3D;&#x3D;用户a给用户b同时发了三条消息 aa bb cc&#x3D;&#x3D;。而&#x3D;&#x3D;服务端接收到的消息是并发的&#x3D;&#x3D;，&#x3D;&#x3D;可能入库就是aa cc bb&#x3D;&#x3D;。</p>
<p>就产生了发送方顺序和接收方顺序不一致的情况。</p>
<p><img src="/.io//1694797825724-8a10c660-6e1f-4cb9-9b35-17e7227b49bb.webp" alt="image.png"></p>
<h4 id="客户端排序-1"><a href="#客户端排序-1" class="headerlink" title="客户端排序"></a>客户端排序</h4><p>这时候可以让a发送的每条消息带上时间戳，服务存储a的消息时间戳。b的展示根据时间戳排序。</p>
<p><img src="/.io//1694797928410-693cd25d-a7ed-45da-98b0-8a5ea90422fc.webp" alt="image.png"></p>
<p>但是如果在多端发送的情况下，&#x3D;&#x3D;a有电脑端，手机端，<strong>每个端的时间</strong>可能是不一样的&#x3D;&#x3D;，就会出现发送的乱序问题</p>
<p><img src="/.io//1694798178170-73f6143c-a83d-4d39-980f-04e05165bfa0-172559465483410.webp" alt="image.png"></p>
<p>回头想想，&#x3D;&#x3D;只是为了解决用户快速发两三条消息时间内的<strong>局部排序</strong>而已&#x3D;&#x3D;。可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/269/2282">腾讯sdk</a>的实现。</p>
<p>&#x3D;&#x3D;给消息设置一个本地的自增id，发送消息的时候带上&#x3D;&#x3D;。&#x3D;&#x3D;排序整体以服务器的时间为准&#x3D;&#x3D;，&#x3D;&#x3D;相同秒内的排序以自增id为准&#x3D;&#x3D;。</p>
<p><img src="/.io//1694798650596-34e5c323-90b4-4b4c-881a-1ce2b4da2a60.webp" alt="image.png"></p>
<p>这样赌的就是，&#x3D;&#x3D;你发的消息再快，哪怕存储顺序变了&#x3D;&#x3D;，&#x3D;&#x3D;但是也都在1s内&#x3D;&#x3D;，对于b来说，1s内的消息，&#x3D;&#x3D;按照自增id额外排序就好了&#x3D;&#x3D;。</p>
<p>这样发送者&#x3D;&#x3D;只需要保证指定时间内的消息自增就好&#x3D;&#x3D;。如果哪天seq丢失，或者在其他端发消息seq不一致，都没关系。</p>
<p>但是&#x3D;&#x3D;在群聊的场景下&#x3D;&#x3D;，每个&#x3D;&#x3D;群成员的客户端时间也是不一样的&#x3D;&#x3D;，&#x3D;&#x3D;没法作为排序的统一基准时间&#x3D;&#x3D;。只能&#x3D;&#x3D;采用服务端时间。并且seq也是不同的，相同秒内也没法排序&#x3D;&#x3D;，不适用该方案</p>
<p><img src="/.io//1694798952659-63fd7155-8076-4dd4-bfc4-37164b47a6df.webp" alt="image.png"></p>
<h4 id="服务端排序-1"><a href="#服务端排序-1" class="headerlink" title="服务端排序"></a>服务端排序</h4><p>对于&#x3D;&#x3D;群聊的场景，我们需要采用服务端排序&#x3D;&#x3D;。服务端排序其实本应该很简单。</p>
<p>对于单表来说，&#x3D;&#x3D;我们可以采用<strong>主键id</strong>来排序&#x3D;&#x3D;，&#x3D;&#x3D;也可以通过<strong>消息的时间戳</strong>来排序&#x3D;&#x3D;。id肯定是严格自增了，&#x3D;&#x3D;时间戳要考虑<strong>精度问题</strong>，一般设置的精度是毫秒&#x3D;&#x3D;，也基本足够进行消息的排序了。因为毫秒内的消息，本身就没有上下文的关系，对顺序要求不高。</p>
<p><img src="/.io//1694799542835-de99d806-780e-4fbd-a832-99998c728dbe.webp" alt="image.png"></p>
<p>小绿小王小马，他们的消息还在发送中，互相都是根据上面已发的消息做的决策，所以他们三的顺序，并不重要，以服务端的时间为准即可。</p>
<p>除了&#x3D;&#x3D;消息的<strong>顺序性</strong>外，还有一个很重要的点，就是消息的<strong>唯一性</strong>&#x3D;&#x3D;。在&#x3D;&#x3D;<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/mallchat/kf0dtv51houe86nh">游标翻页</a>的场景下。翻页的游标字段&#x3D;&#x3D;，需要同时&#x3D;&#x3D;保证顺序性与唯一性的作用&#x3D;&#x3D;。如果&#x3D;&#x3D;单纯用时间戳，毫秒内的消息，就没办法区分与排序，得额外再拼接其他唯一字段一同排序&#x3D;&#x3D;，不如就&#x3D;&#x3D;直接用唯一且有序的id作为游标&#x3D;&#x3D;。</p>
<p><img src="/.io//1685189899438-884c817d-0ee5-4b7d-a540-6be3bb135975.webp" alt="img"></p>
<p>因此消息的时序性，我们通常都是用一个唯一id来保证。<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/269/2738">微信sdk</a>也是用一个id来进行翻页。</p>
<h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><p>&#x3D;&#x3D;通常没有绝对的客户端排序，单聊场景可以用客户端seq&#x3D;&#x3D;。保证&#x3D;&#x3D;单位时间内多条消息的顺序性&#x3D;&#x3D;。</p>
<p>消息不仅要保证时序性，也要保证唯一性。&#x3D;&#x3D;通常用消息id一个字段满足两个需求&#x3D;&#x3D;。</p>
<h3 id="3-消息ID"><a href="#3-消息ID" class="headerlink" title="3.消息ID"></a>3.消息ID</h3><p>消息id被我们给予厚望，不仅要<strong>唯一</strong>，还要<strong>有序</strong>（递增）</p>
<p>&#x3D;&#x3D;保证唯一很简单，随便一个分布式id都能实现&#x3D;&#x3D;。&#x3D;&#x3D;重点是消息的有序&#x3D;&#x3D;，如何去保证。</p>
<h4 id="全局递增-1"><a href="#全局递增-1" class="headerlink" title="全局递增"></a>全局递增</h4><p>&#x3D;&#x3D;消息在整个IM系统都是唯一且递增的&#x3D;&#x3D;。一般对于&#x3D;&#x3D;单表来说<strong>主键</strong>就自然保证了递增&#x3D;&#x3D;。但是如果消息量大了，省不了分库分表，&#x3D;&#x3D;分库分表后的消息递增，通常采用分布式id&#x3D;&#x3D;。但是&#x3D;&#x3D;分布式id通常保证的是<strong>趋势递增</strong>，而不是**单调递增&#x3D;&#x3D;**。</p>
<p><img src="/.io//1691922818312-48ecbc4e-f52f-4598-92e4-def6f6c0e099.webp" alt="img"></p>
<p>所以雪花id不适用于IM这种严格时序性的系统。对分布式id感兴趣可看《架构之路》的<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/architecture/crefklebmccw1vpr">分布式id方案</a>文章</p>
<p>事实上，&#x3D;&#x3D;<strong>严格的单调递增</strong>，意味着<strong>严重的单点竞争</strong>问题&#x3D;&#x3D;。对于一个都需要分库分表的系统，是很难实现这样的方案的</p>
<p><img src="/.io//image-20240906120907266.png" alt="image-20240906120907266"></p>
<p><img src="/.io//image-20240906120933712.png" alt="image-20240906120933712"></p>
<p><img src="/.io//image-20240906120749625.png" alt="image-20240906120749625"></p>
<h4 id="会话级别递增-1"><a href="#会话级别递增-1" class="headerlink" title="会话级别递增"></a>会话级别递增</h4><p>全局的&#x3D;&#x3D;单调递增&#x3D;&#x3D;，意味着&#x3D;&#x3D;严重的单点竞争&#x3D;&#x3D;，而我们为什么需要递增呢，&#x3D;&#x3D;目的就是为了消息的顺序性展示&#x3D;&#x3D;，只需要保证&#x3D;&#x3D;单个群组内的消息id是有序且唯一即可&#x3D;&#x3D;。&#x3D;&#x3D;QQ就是这样的架构&#x3D;&#x3D;</p>
<p>如何保证会话级别的递增呢?一个简单的做法分库分表以会话id分表。这样相同的会话必定在同一张表，又重新回到了主键自增。</p>
<p>一般分表就不用主键自增了，都是用分布式id。因为这种方案很难支持之后的扩容，比如4扩8。</p>
<p>用分布式id保证会话级别的单调递增</p>
<p>&#x3D;&#x3D;单调递增&#x3D;&#x3D;，同时&#x3D;&#x3D;意味着单点问题&#x3D;&#x3D;。两者是不可两全的。&#x3D;&#x3D;分布式id之所以没有单点问题，所以大多数是趋势递增的&#x3D;&#x3D;，这里面设计的可用性，以及单调递增这种一致性的取舍。</p>
<h4 id="收信箱递增-1"><a href="#收信箱递增-1" class="headerlink" title="收信箱递增"></a>收信箱递增</h4><p><strong>会话级别的递增：</strong>更多的适用于<strong>读扩散</strong>的场景。所有人拉取消息列表的时候，都去会话的消息表拉取。</p>
<p><img src="/.io//1694805584259-c669c4a3-5828-4ec4-a54a-72ffb66a95d4.webp" alt="image.png"></p>
<p><strong>守信箱的递增：</strong>适用于<strong>写扩散</strong>的场景。所有人都有自己的一个收信箱，维护自己的时间线即可。</p>
<p><img src="/.io//1694805861395-ce36e294-2c1d-4508-a798-584fa8f4a9dc.webp" alt="image.png"></p>
<p>收信箱的&#x3D;&#x3D;时间线的单调递增和uid相关&#x3D;&#x3D;。实现的方式和上面都一样，&#x3D;&#x3D;一个是以会话为key，一个是以uid为key&#x3D;&#x3D;。</p>
<p><img src="/.io//image-20240906211031866.png" alt="image-20240906211031866"></p>
<blockquote>
<p><code>微信就是典型的写扩散场景，所以他的群聊最多只能500人</code></p>
</blockquote>
<h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><p>我们讨论了消息id的重要使命，用来确保唯一、和有序。</p>
<p>对于&#x3D;&#x3D;有序&#x3D;&#x3D;顺带提了单调递增和趋势递增。现实种分布式id大多数都是趋势递增的，这样比较高可用。</p>
<p>而有序，又讨论时三种有序的情况，为啥全局单调递增不好实现（因为单点竞争）。引出了单调递增id生成器的方案，和可用性保证。</p>
<p>如果你能了解&#x3D;&#x3D;大部分分布式id方案的优缺点&#x3D;&#x3D;，同时了解&#x3D;&#x3D;IM的业务诉求，必须单调递增的限制&#x3D;&#x3D;。又能够引出业界的解决方案。</p>
<h3 id="4-消息可靠ACK"><a href="#4-消息可靠ACK" class="headerlink" title="4.消息可靠ACK"></a>4.消息可靠ACK</h3><p>&#x3D;&#x3D;消息的时序性和可靠性&#x3D;&#x3D;是IM产品最重要的功能。</p>
<p>IM的消息发送一般分为两个场景。</p>
<ul>
<li><strong>发送方</strong>发送消息给服务端，服务端入库成功返回ack</li>
<li>服务端推送消息给<strong>接受方</strong>，接收方返回ACK</li>
</ul>
<h4 id="发送可靠-1"><a href="#发送可靠-1" class="headerlink" title="发送可靠"></a>发送可靠</h4><p>如何&#x3D;&#x3D;确保发送的消息可靠，基本都是靠ack&#x3D;&#x3D;来保证。有人会好奇，&#x3D;&#x3D;能不能借助tcp的ack&#x3D;&#x3D;呢？答案是&#x3D;&#x3D;不能&#x3D;&#x3D;的，业务层的ack不能靠网络层来保证。</p>
<p>举一个例子，假设我&#x3D;&#x3D;发送消息，到达服务器&#x3D;&#x3D;了，&#x3D;&#x3D;这时候的tcp的ack已经响应&#x3D;&#x3D;，代表服务器接收到了请求。&#x3D;&#x3D;但是服务器在入库的时候失败了&#x3D;&#x3D;。&#x3D;&#x3D;业务层可能有很多种失败，业务校验，db入库，代码执行&#x3D;&#x3D;。。。只有业务层返回的ack，才是业务可靠的保证。</p>
<p><img src="/.io//1694841895526-7e9134fc-5820-46f4-9c62-43020b324f1d.webp" alt="image.png"></p>
<p><img src="/.io//image-20240906213921820.png" alt="image-20240906213921820"></p>
<blockquote>
<p>&#x3D;&#x3D;websocket底层是tcp协议&#x3D;&#x3D;，特点&#x3D;&#x3D;就是发消息和接收消息是没关系的&#x3D;&#x3D;，&#x3D;&#x3D;需要通过一个唯一标识&#x3D;&#x3D;来标识推出去的&#x3D;&#x3D;消息是用来响应上一个接收的消息的&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/.io//1694842964385-ae96b9d4-090f-45e1-a6b5-86aff19eec6f.webp" alt="image.png"></p>
<p><img src="/.io//image-20240906215217555.png" alt="image-20240906215217555"></p>
<p><img src="/.io//image-20240906215316611.png" alt="image-20240906215316611"></p>
<h4 id="推送可靠-1"><a href="#推送可靠-1" class="headerlink" title="推送可靠"></a>推送可靠</h4><p><img src="/.io//image-20240906215418377.png" alt="image-20240906215418377"></p>
<p><img src="/.io//1694845013491-2538e540-76c3-41ed-bcb4-2a4ef044de34.webp" alt="image.png"></p>
<p><code>定时重试</code>：&#x3D;&#x3D;可靠性，基本离不开一个不断check的重试节点&#x3D;&#x3D;。这个&#x3D;&#x3D;重试可能是后端，也可能是前端&#x3D;&#x3D;。如果&#x3D;&#x3D;信箱没有收到ack&#x3D;&#x3D;。说明&#x3D;&#x3D;消息没有到达接收端&#x3D;&#x3D;，需要进行重新推送。可靠的前提，&#x3D;&#x3D;在于信箱是<strong>持久化</strong>的。定时任务又支持<strong>不断重试</strong>的&#x3D;&#x3D;。</p>
<p><img src="/.io//1694845092656-b6391f16-9e45-4946-b9f2-840976e23e81.webp" alt="image.png"></p>
<p>但这有个问题，&#x3D;&#x3D;如果用户一直不在线，难道你的定时任务就一直拉取全部信箱消息&#x3D;&#x3D;，&#x3D;&#x3D;在逻辑判断是否在线，再推送吗&#x3D;&#x3D;？这每次拉取的消耗可不小。</p>
<p>&#x3D;&#x3D;<code>在线推送</code>：推送服务增加一个判断，如果是在线消息，才会进行推送&#x3D;&#x3D;，并且&#x3D;&#x3D;记录消息在内存中&#x3D;&#x3D;，&#x3D;&#x3D;定时任务也只会拉取内存ack队列的消息，进行推送重试&#x3D;&#x3D;。</p>
<p><img src="/.io//1694845759730-03316ff3-f98b-41b3-ba50-9bc877ee7f7c.webp" alt="image.png"></p>
<p>如果接收到ack。&#x3D;&#x3D;内存队列会移除对应的待ack消息&#x3D;&#x3D;。并且&#x3D;&#x3D;对持久化的信箱进行ack标识&#x3D;&#x3D;。如果内存待ack队列过多，&#x3D;&#x3D;可以采用lru的方式，排除最早入队的消息&#x3D;&#x3D;。</p>
<p><img src="/.io//1694846361596-d143d38d-7f00-4a1b-8ef4-5ed783b7e733.webp" alt="image.png"></p>
<p>当然&#x3D;&#x3D;内存队列是肯定不可靠的&#x3D;&#x3D;，但他只是&#x3D;&#x3D;为了<strong>加速</strong>我们的可靠性推送的效率&#x3D;&#x3D;，&#x3D;&#x3D;最终还有我们的持久化收信箱做兜底&#x3D;&#x3D;。<strong>最后的保障</strong>，也就是我们的离线推送。</p>
<p><code>离线推送</code>：&#x3D;&#x3D;对于不在线的用户，只能确保他在下一次连接上的时候&#x3D;&#x3D;，保证消息的可靠推送。&#x3D;&#x3D;在此之前，还有友情通过push的方式提示他消息到达。让他打开软件&#x3D;&#x3D;。</p>
<p><img src="/.io//1694847189240-0306c1c5-8842-4dd5-b298-60900ffb24ab.webp" alt="image.png"></p>
<p>所有的复杂点都在用户上线的时间点。发现用户上线后，要立马查出他所有未ack的消息，一股脑全部推送给他。&#x3D;&#x3D;并且copy一份到内存ack队列&#x3D;&#x3D;，确保可靠性。后面的流程就差不多了，定时任务继续重试，保证最终的一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">producer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    queue.put(i);  <span class="comment">// 阻塞式插入</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">consumer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">item</span> <span class="operator">=</span> queue.take();  <span class="comment">// 阻塞式获取</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>java的内存队列主要的适用原因是快</p>
<p><strong>一次性推送所有消息，也可能会有瓶颈，对于一个很久没上线的用户来说。</strong><br>可以做到分批推送，感兴趣看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LSE-8iOwrySuHdHlDK0pXA">b站文章</a>。</p>
<p><img src="/.io//1694849424519-aa3d5ee7-41c5-4943-ae19-c3b98f5e0d35.webp" alt="image.png"></p>
<p>这样已经是一个完整的消息可靠性方案了。做到了持久化，重试，就能达到最终一致性。<strong>但是</strong>。。。</p>
<p>在我们的万人群聊场景下，&#x3D;&#x3D;一条消息，就意味着需要写入1w人的收信箱&#x3D;&#x3D;。你知道这种&#x3D;&#x3D;<strong>写扩散</strong>的系数有多爆炸吗&#x3D;&#x3D;？？？再换个角度来说，&#x3D;&#x3D;每条消息都存一份消息id到用户的个人信箱&#x3D;&#x3D;。对应的存储也增长了好多倍。&#x3D;&#x3D;微信为了降低写扩散的影响，都把群限制了只能500个人。（不是说解决不了，只是代价挺大的）&#x3D;&#x3D;。</p>
<p>以上我们讨论的都是<strong>消息推送的可靠性</strong>，遇到的热点问题，实际上还有一些优化方案，后面的<strong>推拉结合</strong>，和<strong>热点群聊</strong>，都会再讨论这个问题，综合一个更好的方案。</p>
<p>上面的讨论，我们了解了消息可靠的基本方案。虽然抹茶没做到消息的可靠保证，但是面试官问的的时候，你也能答得出来了。</p>
<p>&#x3D;&#x3D;抹茶为啥不做消息可靠的保证呢？一方面是复杂。另一方面抹茶是一个web项目，压根就不存储消息，消息到没到问题不是很大，哪怕消息到了，你刷新一下，消息也又没了。&#x3D;&#x3D;</p>
<h3 id="5-消息重复避免"><a href="#5-消息重复避免" class="headerlink" title="5.消息重复避免"></a>5.消息重复避免</h3><p>&#x3D;&#x3D;分布式下的一致性方案&#x3D;&#x3D;，我们都老生常谈了。几个关键点，&#x3D;&#x3D;<strong>最终一致性</strong> ，<strong>持久化</strong>，<strong>重试</strong>，<strong>幂等</strong>&#x3D;&#x3D;。在分布式场景下一般为了达到最终一致性，&#x3D;&#x3D;失败了我们也需要进行重试&#x3D;&#x3D;，&#x3D;&#x3D;重试就有幂等问题，如何标明两次重试是一次操作&#x3D;&#x3D;，不能因为重试插入了两条数据。</p>
<p>&#x3D;&#x3D;保证幂等关键的点就是幂等标识&#x3D;&#x3D;。</p>
<h4 id="发送消息幂等-1"><a href="#发送消息幂等-1" class="headerlink" title="发送消息幂等"></a>发送消息幂等</h4><p>消息发送的时候，&#x3D;&#x3D;如果遇到网络波动，底层会自动帮忙重试&#x3D;&#x3D;。如何唯一的标识这条消息？&#x3D;&#x3D;靠的是发送端生成一个唯一的标识&#x3D;&#x3D;，如果重试的时候，&#x3D;&#x3D;相同的消息带的是相同的标识。后端服务就能够检测出来，保证幂等&#x3D;&#x3D;。</p>
<p>类似kafka发消息到broker的重试，也会在发送时生成个幂等标识。<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/269/2282">腾讯sdk的文档</a>，也能看到发送消息的一个随机md5，保证幂等标识。</p>
<p><img src="/.io//1694851387465-57d7e1f7-a968-4b05-98b1-146e83c68a5f.webp" alt="image.png"></p>
<p>&#x3D;&#x3D;1s内的去重保证，是比较好的做法&#x3D;&#x3D;。否则需要去重判断的范围太大了，涉及的历史数据也太多了。这样的话，&#x3D;&#x3D;发送端的自动重试也要限制一下超过1s还没成功，就放弃重试了&#x3D;&#x3D;。</p>
<h4 id="接收消息幂等-1"><a href="#接收消息幂等-1" class="headerlink" title="接收消息幂等"></a>接收消息幂等</h4><p>&#x3D;&#x3D;服务端对接收方的消息推送，也是有可靠性保证的。&#x3D;&#x3D;如果&#x3D;&#x3D;没有及时收到ack，定时任务就会进行消息推送重试&#x3D;&#x3D;。同样需要考虑到幂等问题。</p>
<p>假设&#x3D;&#x3D;服务端对接收方推送了相同的消息两次&#x3D;&#x3D;。接收方会怎么展示呢？&#x3D;&#x3D;一般能够想到对消息做幂等判断&#x3D;&#x3D;，如果是客户方已经展示的消息，就跳过。那么这个唯一性怎么判断呢？</p>
<p>消息的唯一性，&#x3D;&#x3D;基本就靠消息id来判断了。上面也讨论了消息id的唯一性问题&#x3D;&#x3D;。一般全局消息唯一的话。直接用唯一消息就好了。</p>
<p>如果是会话级别的消息id唯一，&#x3D;&#x3D;那判断的时候就需要判断<code>会话id+消息id</code>唯一&#x3D;&#x3D;。</p>
<h3 id="6-推拉结合"><a href="#6-推拉结合" class="headerlink" title="6.推拉结合"></a>6.推拉结合</h3><h4 id="推模式-1"><a href="#推模式-1" class="headerlink" title="推模式"></a>推模式</h4><p><img src="/.io//image-20240906221847328.png" alt="image-20240906221847328"></p>
<h4 id="拉模式-1"><a href="#拉模式-1" class="headerlink" title="拉模式"></a>拉模式</h4><p><img src="/.io//image-20240906222105494.png" alt="image-20240906222105494"></p>
<blockquote>
<p>&#x3D;&#x3D;这个项目主要还是在历史消息列表的时候适用拉模式&#x3D;&#x3D;</p>
</blockquote>
<h4 id="推拉结合-2"><a href="#推拉结合-2" class="headerlink" title="推拉结合"></a>推拉结合</h4><p><img src="/.io//image-20240906222541709.png" alt="image-20240906222541709"></p>
<p><img src="/.io//1694856070259-99191750-30be-4698-95d4-39ffe3ee93ac.webp" alt="image.png"></p>
<p><img src="/.io//image-20240906222648096.png" alt="image-20240906222648096"></p>
<p><img src="/.io//image-20240906222901953.png" alt="image-20240906222901953"></p>
<p><img src="/.io//image-20240906222925307.png" alt="image-20240906222925307"></p>
<h3 id="7-多端同步"><a href="#7-多端同步" class="headerlink" title="7.多端同步"></a>7.多端同步</h3><p>上文提到的&#x3D;&#x3D;推拉结合是个好方案&#x3D;&#x3D;，但是在多端同步的场景下，就失效了。&#x3D;&#x3D;多端同步的核心，是确保消息可靠的到达多端&#x3D;&#x3D;。&#x3D;&#x3D;消息的可靠是通过ack完成的&#x3D;&#x3D;，问题就出来这里。</p>
<p>&#x3D;&#x3D;用户收信箱只有一个&#x3D;&#x3D;，消息的状态分为<code>ack</code>&#x3D;<code>true</code>，<code>false</code>。代表用户是否已经收到消息。&#x3D;&#x3D;但是在多端的场景下&#x3D;&#x3D;，如何去表示用户收到消息呢？</p>
<p><img src="/.io//1694875066927-747fcc4d-4054-41ea-b941-74e9aab836ec.webp" alt="image.png"></p>
<blockquote>
<p>核心就是&#x3D;&#x3D;当多端的情况&#x3D;&#x3D;，如果&#x3D;&#x3D;一个消息只有一个ack标记位没有办法表示&#x3D;&#x3D;</p>
</blockquote>
<p>&#x3D;&#x3D;这样每个端的ack，都需要独立去维护自己的ack信箱了&#x3D;&#x3D;。手机收到了两条消息，电脑收到了一条。&#x3D;&#x3D;在电脑进行新消息拉取的时候，拉取到的消息应该是2，3，4。而手机端拉取到的应该是3，4&#x3D;&#x3D;。这样的设计可太烂了。难道我们要为每个端都准备一个信箱吗？&#x3D;&#x3D;如果有新的端加入，信箱还需要做历史数据修复吗？&#x3D;&#x3D;为了兼容这个场景，我们不得不去设计一套新的交互方案。</p>
<p>我们来思考一个问题。&#x3D;&#x3D;可靠性，究竟是怎么保证的？&#x3D;&#x3D;是&#x3D;&#x3D;靠状态的持久化来保证的&#x3D;&#x3D;。比如&#x3D;&#x3D;收信箱里的ack&#x3D;&#x3D;，&#x3D;&#x3D;就明确标识了用户接收了哪些，没接收到哪些&#x3D;&#x3D;，之后才能够&#x3D;&#x3D;推送未ack的&#x3D;&#x3D;。保证最终一致性。而现在的状态存储遇到了问题。多端场景下，需要服务端维护<strong>多端状态</strong>。这是一个难题，那么&#x3D;&#x3D;能不能把多端状态抛给客户端&#x3D;&#x3D;？？</p>
<p><img src="/.io//1694876581542-d9e90c2a-e4e7-4224-9a8b-5a6b06f5e2f8.webp" alt="image.png"></p>
<p>&#x3D;&#x3D;服务端不再维护ack状态&#x3D;&#x3D;，由&#x3D;&#x3D;客户端维护&#x3D;&#x3D;。&#x3D;&#x3D;客户端维护该端读取到的最后一条消息的游标&#x3D;&#x3D;。这个&#x3D;&#x3D;<strong>游标</strong>的选择，需要具备<strong>唯一性</strong>和<strong>有序性</strong>&#x3D;&#x3D;。关联上我们前面介绍的，也就是&#x3D;&#x3D;用消息id来保证&#x3D;&#x3D;了。</p>
<p>每次推送，&#x3D;&#x3D;都需要对多端进行新消息通知&#x3D;&#x3D;。</p>
<p>每次&#x3D;&#x3D;拉取新消息的时候，客户端不仅需要带上token，还需要带上自己当前读到的游标&#x3D;&#x3D;。服务端&#x3D;&#x3D;根据游标，查询到id大于游标的消息，全部返回给客户端&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;手机请求新消息时&#x3D;&#x3D;，&#x3D;&#x3D;带上的是自己的游标是2。查到大于2的消息3，4&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;电脑请求新消息时&#x3D;&#x3D;，带上的是自己的游标是1。查到大于1的消息2，3，4。</p>
<p>这一切的前提，&#x3D;&#x3D;是<strong>id是全局递增</strong>的&#x3D;&#x3D;。这样&#x3D;&#x3D;服务端只需要维护一个游标&#x3D;&#x3D;。每次拉取新消息，都是拉取多个会话的消息。</p>
<p>如果&#x3D;&#x3D;id是<strong>收信箱递增</strong>的&#x3D;&#x3D;，对于单个用户来说，&#x3D;&#x3D;其实相当于是全局递增了&#x3D;&#x3D;。&#x3D;&#x3D;用的是收信箱的id做游标&#x3D;&#x3D;，而不是用消息id。也能达到全局的效果。&#x3D;&#x3D;微信就是这个方案&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;如果id是<strong>会话级别递增</strong>的，那么客户端就需要维护每个会话的游标了&#x3D;&#x3D;，每次拉取消息的时候需要带上<code>会话id＋游标id</code>。&#x3D;&#x3D;每次定时任务的拉取，也需要带上<strong>多个</strong><code>会话id＋游标id</code>&#x3D;&#x3D;，为每个会话都尝试拉取最新消息。整体实现复杂了不少。这种方案通常不常见。</p>
<p><img src="/.io//1695130491354-2805f3d6-1e7d-4dd7-b916-e398448e232e.webp" alt="image.png"></p>
<p>&#x3D;&#x3D;对于抹茶来说，是全局递增的id&#x3D;&#x3D;，完全可以&#x3D;&#x3D;客户端存储阅读游标的方式实现多端消息同步&#x3D;&#x3D;。虽然我们暂时没有去做，但是大家可以这样去回答。</p>
<p>抹茶的多端同步也比较简单，毕竟是一个web项目不保存消息。&#x3D;&#x3D;登录每个端都一样。拉取最新的一页消息&#x3D;&#x3D;。&#x3D;&#x3D;后续新消息通知就拉取新消息。感兴趣历史消息，也可以通过翻页加载的方式加载老消息&#x3D;&#x3D;。对于&#x3D;&#x3D;客户端缓存消息来说，看老消息直接从库里查，都不需要翻页加载了&#x3D;&#x3D;</p>
<h3 id="8-单聊群聊"><a href="#8-单聊群聊" class="headerlink" title="8.单聊群聊"></a>8.单聊群聊</h3><p>&#x3D;&#x3D;消息表怎么兼容单聊和群聊&#x3D;&#x3D;。我看市面上很多的设计都是这样的。</p>
<p><img src="/.io//1694881218413-cad8e188-0c7d-49e9-af92-09e7c3705429.webp" alt="image.png"></p>
<p>目标类型分为单聊和群聊。&#x3D;&#x3D;<strong>单聊</strong>的情况下目标id填<strong>uid</strong>&#x3D;&#x3D;。<strong>群聊</strong>情况下，&#x3D;&#x3D;目标id填<strong>群组id</strong>&#x3D;&#x3D;。这样消息是兼容了，&#x3D;&#x3D;但是其他地方也都要兼容了&#x3D;&#x3D;。比如我们的&#x3D;&#x3D;个人收信箱&#x3D;&#x3D;。需要存所有消息。&#x3D;&#x3D;同时还要知道这个消息在哪个会话下的&#x3D;&#x3D;。单聊群聊的会话要怎么去唯一标识呢，&#x3D;&#x3D;首先个人信箱，都需要个人uid去标识&#x3D;&#x3D;。一般单聊是加上好友uid，就代表会话。群聊加上群id。</p>
<p><img src="/.io//1694881895993-0e8f3911-f315-40a8-856c-5048a037abcd.webp" alt="image.png"></p>
<p>这样收信箱也需要兼容单聊和群聊，设计两个字段，&#x3D;&#x3D;后续为了能快速命中会话，还需要设计**组合索引&#x3D;&#x3D;**。</p>
<p>&#x3D;&#x3D;后续其他表只要是涉及会话id的都需要这两个字段&#x3D;&#x3D;。想想就麻烦。本着复用和抽象的原则。能复用的地方，就给它抽出来，看看我们要怎么去优化它。</p>
<p><img src="/.io//1694882377438-8c76afd6-ad37-4eab-a9d4-196dd82a3d70.webp" alt="image.png"></p>
<p>我们可以抽象一个房间表出来，群聊所有人在一个房间里面聊天。单聊无非就是两个人在房间里面聊天。这样房间关联上单聊或者群聊的相关信息。有了这层抽象。&#x3D;&#x3D;消息表和个人信箱都不需要两个字段标识会话了&#x3D;&#x3D;。&#x3D;&#x3D;直接用房间id就是会话id&#x3D;&#x3D;。通过房间id，自然就关联出对应的单聊群聊信息了。</p>
<p><img src="/.io//1694880682366-4a1e72a0-cff5-45ca-834f-c405eab3d6b6.webp" alt="image.png"></p>
<p>所以表结构设计就是这样的。通过房间表room，抽象了一层，**&#x3D;&#x3D;屏蔽了单聊群聊的差异&#x3D;&#x3D;**，让其他关心会话的表设计起来更加简单。只需要关联一个房间id字段。</p>
<p>&#x3D;&#x3D;<strong>单聊群聊</strong>和<strong>房间</strong>，都是一对一的关系&#x3D;&#x3D;。相当于单聊表和群聊表都是扩展表。&#x3D;&#x3D;本质上是可以直接在room上面添加字段的&#x3D;&#x3D;。选择扩展能划分更加明确。</p>
<p>&#x3D;&#x3D;<strong>群聊</strong>有对应的头像，群名称等&#x3D;&#x3D;。另外还有一个很重要的群成员。由于群成员和群是多对一的关系。一个群可以有多个群成员。</p>
<p><strong>群成员</strong>单独建了一张表。&#x3D;&#x3D;里面有个role字段，记录群成员在群里的属性，比如群主，管理员，普通成员&#x3D;&#x3D;。如果我们需要快速判断一个群的群主怎么办？为了走索引，&#x3D;&#x3D;所以设计了<code>group_id和role</code>的联合索引&#x3D;&#x3D;。当然你也可以作为冗余字段，直接记录在group表，添加个群主uid字段。</p>
<p>&#x3D;&#x3D;<strong>单聊表</strong>有个很重要的点，就是怎么去唯一确认一个房间&#x3D;&#x3D;。比如我新加了一个好友，系统为我们生成了一个单聊房间。后续在好友列表找到这个好友，对他发消息。这时候怎么找到我们之前的那个房间。这时候我只知道我的uid和好友的uid。</p>
<p>所以在单聊表中有两个重要的字段，uid1和uid2代表好友双方的uid。&#x3D;&#x3D;为了能保证双方建立的房间的唯一性。我们增加了一个唯一字段<code>room_key</code>来唯一标识两个好友的房间&#x3D;&#x3D;。</p>
<p>他的生成规则很简单。&#x3D;&#x3D;<code>uid1_uid2</code>。其中uid1是双方uid较小的那个，uid2是双方uid较大的那个&#x3D;&#x3D;。这样避免不同的排列顺序，产生二义性。</p>
<p><strong>总结</strong></p>
<p>上面的设计完全是抹茶的设计。通过抽象一层房间表，&#x3D;&#x3D;来屏蔽单聊群聊的差异，让消息表和会话表的存储变得更加简单&#x3D;&#x3D;。这是后续面试官会无数次问到你的问题。了解其中的背景和方案，让你在后续的面试中能够对答如流。</p>
<h3 id="9-消息的已读未读"><a href="#9-消息的已读未读" class="headerlink" title="9.消息的已读未读"></a>9.消息的已读未读</h3><p><img src="/.io//1690708033267-a86c050b-7c97-435f-9d3e-ce03138bb685.webp" alt="img"></p>
<p>这里面有几个关键的元素&#x3D;&#x3D;，总共<strong>多少人已读</strong>，<strong>多少人未读</strong>，<strong>已读未读列表&#x3D;&#x3D;。</strong>一条消息怎么知道对方读没读了？&#x3D;&#x3D;这又回到了ack的问题。刚刚我们的多端同步好不容易把ack给取消了&#x3D;&#x3D;，通过客户端维护自己的<strong>阅读游标</strong>，来保证消息的可靠性。现在服务端还是需要维护每个人的ack，这样才知道消息读没读。</p>
<p><img src="/.io//1694930308758-683605d3-6cae-47a7-b2d4-7c72e3b73de8.webp" alt="image.png"></p>
<p>相当于每条消息，都需要投递到用户的收信箱，并且需要记录已读未读的状态。用户读取消息后，需要返回ack。消息投递的可靠性依然由客户端拉取消息自行保证。收信箱的ack是用于已读未读的统计。</p>
<ol>
<li>有人发了条消息1，群消息入库，并插入到群成员A和B的收信箱，此时都是未读状态</li>
<li>推送服务通知A和B拉取新消息</li>
<li>A正好在线，拉取了新消息1，拉到消息后，返回ACK。</li>
<li>推送服务标记A对消息1的ACK。</li>
<li>ack的消息同时需要推送给消息的发送者，同步更新</li>
<li>发消息的人想看看消息的相关情况。</li>
</ol>
<p><img src="/.io//image-20240906235730128.png" alt="image-20240906235730128"></p>
<p>这里面有几个瓶颈，咱们可以一个个尝试解决。</p>
<h4 id="收信箱写指数扩散-1"><a href="#收信箱写指数扩散-1" class="headerlink" title="收信箱写指数扩散"></a>收信箱写指数扩散</h4><p>对于一个万人群聊，每条消息都需要记录所有人的ack。&#x3D;&#x3D;一条消息就需要写入1w条收信箱记录&#x3D;&#x3D;。&#x3D;&#x3D;每人发一条消息，那就是1w*1w&#x3D;1亿&#x3D;&#x3D;的记录量。对存储来说是个很大的负担，有没有可能减轻负担呢？</p>
<p>换个思路，用户的收信箱能不能不为每条消息记录ack，&#x3D;&#x3D;只记录用户阅读的最新时间线（类似之前的客户端存游标）&#x3D;&#x3D;。这样用户ack的时候，后台只需要更新ack的最新时间。</p>
<p><img src="/.io//1694932870774-221b3d26-6a96-4bd8-b015-0d9da08552dc.webp" alt="image.png"></p>
<p>A收到新消息10003后，提交ack。收信箱记录A最后的阅读时间10003。这样存储就不会因为消息而指数扩散了。</p>
<p>只和群成员数有关，每个人都只有一行阅读记录。</p>
<p>因此我们设计了如下的&#x3D;&#x3D;用户收信箱表，也叫会话表&#x3D;&#x3D;。</p>
<p><img src="/.io//1694936653684-cf437a2a-a5cc-4c82-9339-de9f5d650e5f.webp" alt="image.png"></p>
<p>我们是知道消息的发送时间的。</p>
<p>已读数:<code>select count(0) from 信箱 where room_id=xx and read_time&gt;消息时间;</code></p>
<p>未读数:<code>select count(0) from 信箱 where room_id=xx and read_time&lt;消息时间;</code></p>
<p>已读列表：<code>select uid from 信箱 where room_id=xx and read_time&gt;消息时间 order by create_time;;</code></p>
<p>未读列表：<code>select uid from 信箱 where room_id=xx and read_time&lt;消息时间 order by create_time;;</code></p>
<p>所以这里面有个关键，需要room_id和read_time的联合索引，才能够加速查询。</p>
<p>目前抹茶就采用的这个方案，对于我们来说消息id是<strong>全局单调递增</strong>的。其实可以用消息id来进行比较和游标。没必要用时间来比较。这是后面可以优化的点。</p>
<p>所以这里面有个关键，需要room_id和read_time的联合索引，才能够加速查询。</p>
<p>目前抹茶就采用的这个方案，对于我们来说消息id是<strong>全局单调递增</strong>的。其实可以用消息id来进行比较和游标。没必要用时间来比较。这是后面可以优化的点。</p>
<h4 id="消息阅读推送-1"><a href="#消息阅读推送-1" class="headerlink" title="消息阅读推送"></a>消息阅读推送</h4><p>类似钉钉和微信，发送完每条消息，就能看见他的阅读数在蹭蹭上涨。只要有人阅读了，他就加1，看起来是实时增加的。这个怎么设计呢？</p>
<p>最暴力的做法。每个人阅读完群消息，都通知给发送方。然后消息阅读数+1。</p>
<p><img src="/.io//1694934319042-c125f3be-5ebb-4fed-90ba-5e19a005dc5d.webp" alt="image.png"></p>
<p>这样的消息推送频率也是很高的，&#x3D;&#x3D;特别是在万人群聊下，发一条消息，就要收到几千次的ack推送。又要几千次的ack给小王。&#x3D;&#x3D;</p>
<p>优化一下，将推送合并。&#x3D;&#x3D;可以采用<strong>服务端定时任务</strong>的方式。定时任务的间隔，就成为了合并的时间窗口&#x3D;&#x3D;。</p>
<p><img src="/.io//1694934553162-c79fc616-5199-48f2-a766-1585b3adfbb1.webp" alt="image.png"></p>
<p>小王发送新消息后，后端起个定时任务。&#x3D;&#x3D;每5，20，40，100，200,指数上升的时间&#x3D;&#x3D;，给他推送一次消息的总阅读数。&#x3D;&#x3D;这样在5s内的ack都会被合并成一次总的阅读数推送给小王&#x3D;&#x3D;。</p>
<p>这样做的前提，&#x3D;&#x3D;是业务允许小王对消息阅读数一开始很关注，过了30s后，就不那么着急更新的时间了&#x3D;&#x3D;。过了几分钟后，小王压根就不关心消息的阅读数了。定时任务也可以停止了。</p>
<p>这个方案可以节省很大的性能。&#x3D;&#x3D;但是后端维护一个定时任务还是有些麻烦，小王<strong>真的有那么关心消息的阅读吗</strong>？&#x3D;&#x3D;这5分钟内，他都会在这个页面等着看最新的阅读数吗？</p>
<p><img src="/.io//1694935196869-922dfa70-cb91-4577-b33b-0eff6e2eede7.webp" alt="image.png"></p>
<p>由前端自己查询消息的未读数。假设我发了十几条消息。我真的在乎那些消息有谁阅读了嘛？</p>
<p>只有我停留在那个房间，且一个屏幕内有我的发送过的消息，我才需要实时更新未读数。</p>
<p><img src="/.io//1694935301440-09120016-7b3f-4c8c-ad80-2952720816cb.webp" alt="image.png"></p>
<p>&#x3D;&#x3D;比如这一屏内，我只有这两条消息需要看到未读数的更新&#x3D;&#x3D;，我只需要&#x3D;&#x3D;前端启个定时任务自己查这两条消息&#x3D;&#x3D;就好了。这样又节省了很大的性能，更多的时候，我可能已经退出了页面，就一条消息的未读数都不查了。</p>
<h4 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h4><p>我们抹茶目前就采用这样的方案。</p>
<p>通过只记录用户阅读的时间线，减少了每条消息ack存储的成本。</p>
<p>通过合理的索引，让消息已读未读数的统计变得飞快。</p>
<p>通过前端的定时请求，让消息的已读数更新，避免了性能的无效浪费。</p>
<h3 id="10-会话列表设计"><a href="#10-会话列表设计" class="headerlink" title="10.会话列表设计"></a>10.会话列表设计</h3><p>有了这样的设计，我们还能很轻松的实现会话列表的功能。</p>
<p><img src="/.io//1694936650475-f26874de-9316-4b1e-9660-88e6cf5b25bd.webp" alt="image.png"></p>
<p><img src="/.io//1694936308310-68841798-91c9-4cae-a4fb-722f0d57ae5f.webp" alt="image.png"></p>
<p>这张会话表，就是用户优化过后的收信箱。来看看怎么靠他实现对应的功能。</p>
<p>&#x3D;&#x3D;会话表记录的是<code>uid</code>在某个<code>room</code>内的消息详情，比如<code>最新消息时间</code>，自己<code>阅读到的时间</code>&#x3D;&#x3D;。</p>
<p>会话列表：&#x3D;&#x3D;<code>select room_id from contact where uid =我  order by active_time desc</code>&#x3D;&#x3D;。&#x3D;&#x3D;查到我的所有会话&#x3D;&#x3D;，并按照每个会话的最新消息时间倒序排序。为了能快速命中索引，需要<code>uid和active_time</code>的联合索引</p>
<p>会话消息未读数：&#x3D;&#x3D;<code>select count(0) from msg where room_id=我房间 and create_time&gt;我阅读</code>&#x3D;&#x3D;。拿着自己会话表的阅读时间去消息表比较，由于有&#x3D;&#x3D;<code>room_id和create_time</code>的联合索引&#x3D;&#x3D;。查找速度很快。</p>
<p>优化：&#x3D;&#x3D;假设我很多年没上线了。消息的未读数达到了几万条&#x3D;&#x3D;，就算我有索引，也得扫描几万条记录，统计未读数。这个还是比较耗时的，怎么办呢？参考微信最大只展示99条消息的未读数。我们的未读数统计可以优化成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select <span class="title function_">count</span><span class="params">(<span class="number">0</span>)</span> from</span><br><span class="line">(</span><br><span class="line">  SELECT <span class="number">1</span></span><br><span class="line">    FROM msg</span><br><span class="line">    WHERE room_id=我房间 and create_time&gt;我阅读</span><br><span class="line">    LIMIT <span class="number">100</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样未读数最多只会扫描100条，避免了极端的场景。</p>
<p>抹茶的会话表设计，目前就采用了这样的方案。通过记录阅读<strong>时间线</strong>而不是记录每条<strong>消息的ack</strong>。完美适配了会话列表的功能，和消息已读未读数的功能。</p>
<h3 id="11-热点群聊-读写扩散结合"><a href="#11-热点群聊-读写扩散结合" class="headerlink" title="11.热点群聊(读写扩散结合)"></a>11.热点群聊(读写扩散结合)</h3><p>前面留了那么多个坑，都依然没有解决万人群聊写扩散的问题。但是通过一步步的表结构设计的优化，已经逐渐接近了。</p>
<p>&#x3D;&#x3D;万人群聊最大的问题，就是每条消息，都需要写入用户的收信箱。也就是那个会话表的<code>active_time</code>字段&#x3D;&#x3D;。更新了这个字段，最新消息的那个会话才能排序在最前面。如果不更新，这个房间在用户的会话列表就排在很后面了。</p>
<p>&#x3D;&#x3D;这个更新时间可以记，但是能不能单独记，不扩散写到用户的收信箱，而是单独写到热点信箱&#x3D;&#x3D;，用户读取的时候综合读取自己收信箱的会话，合并热点信箱的会话。</p>
<p><img src="/.io//1694938909569-0647c645-2367-48fd-ae7a-7f663a35aa73.webp" alt="热点群聊.png"></p>
<p>这样&#x3D;&#x3D;每个小方块都是一个房间，里面的数字代表这房间的最新消息<strong>游标</strong>&#x3D;&#x3D;。</p>
<ul>
<li>对于&#x3D;&#x3D;<strong>小群聊</strong>写扩散到用户的每个收信箱，更新房间的最新消息<strong>游标</strong>&#x3D;&#x3D;。</li>
<li>对于**&#x3D;&#x3D;热点群聊<strong>，直接</strong>单独记录<strong>该房间的最新</strong>游标&#x3D;&#x3D;**。</li>
<li>用户在查询自己会话列表的时候，&#x3D;&#x3D;通过<strong>聚合层</strong>。聚合自己<strong>收信箱</strong>，和自己参与的<strong>热点群聊</strong>的<strong>排序</strong>&#x3D;&#x3D;，然后展示给用户</li>
</ul>
<p>这样就可以节省每次热点群聊写扩散的消耗了，对热点群聊来说是个极致的提升。</p>
<p><img src="/.io//1694939418984-09f0d450-0f5e-4ae4-98c7-3b23599ffbf3.webp" alt="image.png"></p>
<p>&#x3D;&#x3D;热点群聊相关的信息，直接记录在room表里&#x3D;&#x3D;，不需要写入到用户信箱。</p>
<p>为了&#x3D;&#x3D;<strong>聚合</strong>的时候<strong>效率</strong>更高&#x3D;&#x3D;。我们&#x3D;&#x3D;还可以把热点群聊直接缓存在redis的zset里&#x3D;&#x3D;。这样聚合的时候，速度更快。</p>
<h4 id="精确时间聚合-1"><a href="#精确时间聚合-1" class="headerlink" title="精确时间聚合"></a>精确时间聚合</h4><p>在现实的场景里，&#x3D;&#x3D;跨服务分页一直是一个难题&#x3D;&#x3D;。&#x3D;&#x3D;最佳的方案就是写一张聚合表&#x3D;&#x3D;，&#x3D;&#x3D;将跨库的数据聚合成一张表&#x3D;&#x3D;，&#x3D;&#x3D;然后进行条件分页&#x3D;&#x3D;。然而我们的&#x3D;&#x3D;热点群聊就是为了避免写扩散，所以才需要聚合&#x3D;&#x3D;。这个方案行不通了。</p>
<p>那我们怎么去聚合呢。&#x3D;&#x3D;可以选一张主表用来分页，副表用来聚合&#x3D;&#x3D;。</p>
<p><img src="/.io//image-20240907162445243.png" alt="image-20240907162445243"></p>
<p>以&#x3D;&#x3D;收信箱为主表，查询第一页,假设一页3条&#x3D;&#x3D;。&#x3D;&#x3D;查到3，5，7&#x3D;&#x3D;，&#x3D;&#x3D;通过3和7作为条件，筛选热点群聊里面的房间&#x3D;&#x3D;，&#x3D;&#x3D;只能筛选到4&#x3D;&#x3D;。2怎么办？？？&#x3D;&#x3D;需要兼容第一页的场景，start不应该限制。只限制end&lt;7&#x3D;&#x3D;，筛选出2和4。聚合返回2，3，4，5，7</p>
<p><img src="/.io//1694942346761-98c8132b-b529-498d-a62a-dda06784d0fe.webp" alt="image.png"></p>
<ol>
<li>第二页只有两条，&#x3D;&#x3D;筛选出9和10，通过9和10作为条件&#x3D;&#x3D;，&#x3D;&#x3D;筛选热点群聊房间，筛选不到。那18怎么办？？&#x3D;&#x3D;需要兼容最后一页的场景，end不应该限制，只限制start&gt;9.筛选出18.聚合返回9，10，18.</li>
</ol>
<p>这种方案性能非常的高，但是需要业务能够接受本来一页三条数据，有可能一页5条，或者一页4条的情况。在极端场景这个人加入了很多热点群聊，一页可能会加载出100多条数据</p>
<h4 id="精准条数聚合"><a href="#精准条数聚合" class="headerlink" title="精准条数聚合"></a>精准条数聚合</h4><p>如果业务有强烈的诉求，&#x3D;&#x3D;期望一页得到的条数是固定的3条&#x3D;&#x3D;，我们也需要提供相应的方案来满足诉求。</p>
<p><img src="/.io//1694943058398-885e6af8-0946-40c0-ae28-eb1487b34152-172570005191997.webp" alt="image.png"></p>
<p>1.查询第一页的三条，&#x3D;&#x3D;个人收信箱和热点信箱都是主表&#x3D;&#x3D;。&#x3D;&#x3D;双方各查出一页的数据<strong>候选</strong>&#x3D;&#x3D;（避免极端情况一页都是热点，或一页都是普通）。通过归并排序的方式，&#x3D;&#x3D;每次都pk普通和热点的房间，取出较小的那个放到结果集合。第一轮比较取出2，第二轮比较取出3，第三轮比较取出4，填满即可&#x3D;&#x3D;</p>
<blockquote>
<p>这个很像一个面试题，大文件排序怎么做？</p>
</blockquote>
<p>大文件的难点，&#x3D;&#x3D;在于内存放不下所有的数据。因此只能拆分成一个个局部排序的小文件&#x3D;&#x3D;。然后再对多个小文件，进行<strong>多路归并排序</strong>。</p>
<p><img src="/.io//1694943718419-8c2e2296-b2b1-4efe-89ba-6e1cd4201772.webp" alt="img"></p>
<p>将多个文件的头结点，&#x3D;&#x3D;一起构造一颗小顶堆的树。每次从顶堆取值&#x3D;&#x3D;，就汇总最终的排序。&#x3D;&#x3D;顶堆支持每次弹出一个值就从候选队列再压入一个值。类似的是，我们的抹茶只有两路归并&#x3D;&#x3D;，简单了不少。</p>
<p><img src="/.io//1694944213805-5d1c5c07-2f45-4a11-a7ad-58248d91508d.webp" alt="image.png">2.查询第二页。&#x3D;&#x3D;根据上一页的最后一条的游标，确定下一页开始的位置，这就是<a target="_blank" rel="noopener" href="https://www.yuque.com/snab/mallchat/kf0dtv51houe86nh">游标翻页&#x3D;&#x3D;</a>。这个场景用普通翻页无法实现。根据上一页的最后一条消息是4，往下双方各查一页。最终通过归并排序，返回结果5，7，9。</p>
<p>&#x3D;&#x3D;这样就是做到精确分页了，他的核心是，id必须全局单调递增。&#x3D;&#x3D;因为每个会话记录的都是最后一条消息的id。这个id是用来排序的，如果id只能做到会话内递增，那不同会话间压根没法比较。</p>
<h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><p>我们会发现，所有的方案有有好有坏，没有最佳方案，只有最适合业务的方案。而这种方案一般都是扬长避短的去组合每个方案的优点来共同实现。推拉结合是这样。热点群聊的读写扩散混合也是这样。</p>
<p>&#x3D;&#x3D;为了避免热点群聊的写扩散，我们设计了会话聚合模块&#x3D;&#x3D;。&#x3D;&#x3D;为了满足会话的排序，我们设计了精确时间聚合&#x3D;&#x3D;，&#x3D;&#x3D;或者精确条数聚合的方案&#x3D;&#x3D;。&#x3D;&#x3D;其中精确条数要求id全局单调递增&#x3D;&#x3D;。</p>
<p>抹茶采用的方案是比较简单的精确时间聚合。由于抹茶是id全局单调递增的，想要改成精确条数聚合也特别的简单，大家可自行选择。</p>
<h3 id="消息表支持多类型消息-1"><a href="#消息表支持多类型消息-1" class="headerlink" title="消息表支持多类型消息"></a>消息表支持多类型消息</h3><p>支持多类型的消息表，是怎么设计的？</p>
<p><img src="/.io//1695138190521-256e0017-5473-4dbb-9127-ec884512eb60.webp" alt="复杂图片.jpg"></p>
<p>我们能够支持文件，视频，pdf，图片，语音，文本。这么多类型的消息，这个表结构该如何设计呢？</p>
<p>首先来思考下，文件，视频，图片，他们都是啥。真抽象起来，不全部都是一个文件吗，&#x3D;&#x3D;一个存在oss里面的<strong>url</strong>。有了这个思路就简单了。&#x3D;&#x3D;</p>
<p>我们只需要添加一个上传的接口，这些类型的消息，前端只需要上传后记录url，提交给我们即可。</p>
<p><img src="/.io//1694946409060-202f0226-5002-40e2-aace-83fe76b57c1a.webp" alt="image.png"></p>
<p>消息最重要的其实就是两个字段。</p>
<p><code>type</code>：指定消息是什么类型。</p>
<p><code>extra</code>：放置不同类型消息的详情，如果是特别重要的消息，还可以通过设置关联表的方式，扩展出去，比如红包类型消息。</p>
<p>这里的<code>content</code>，<code>reply_msg_id</code>,<code>gap_count</code>其实都是文本类型的消息才有的字段，也可以扔extra里面去。由于一开始的历史兼容问题，没有删除字段，后续可以移除，让消息表更简洁。</p>
<p>消息表最重要的就是<strong>谁</strong>，在哪个<strong>房间</strong>，发送了什么<strong>类型</strong>的消息。<strong>详情</strong>都可以在<strong>extra</strong>里面。</p>
<p><img src="/.io//image-20240907220944814.png" alt="image-20240907220944814"></p>
<blockquote>
</blockquote>
<h1 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h1><h2 id="生产环境上发生了内存泄漏应该如何排查？"><a href="#生产环境上发生了内存泄漏应该如何排查？" class="headerlink" title="生产环境上发生了内存泄漏应该如何排查？"></a>生产环境上发生了内存泄漏应该如何排查？</h2><blockquote>
<p>什么是内存泄漏会带来什么样的影响？</p>
</blockquote>
<p>内存泄漏指的是在程序运行的过程中，因为某些原因导致不需要使用的对象仍然占据JVM内存空间，并且这块空间还无法被回收，最终导致程序占用的内存越来越大，最终导致oom的错误或者影响程序的性能，一般情况下oom这种错误以外，内存泄漏也会出现一些比较明显的现象，比如说频繁的Full GC ，内存占用量过大，一直无法释放</p>
<blockquote>
<p>内存泄漏的排查和解决办法</p>
</blockquote>
<p>一般会根据现象去定位问题，所以第一步我们会先去定位是否是内存泄漏，比如说老年代逐步增长，Full GC卡顿，年轻代的内存一直在高位无法释放，频繁Full GC这些现象基本都是内存出现异常</p>
<p>要了解GC的情况，我们可以使用jstat命令去查看虚拟机中各个内存区域的使用情况和GC情况 </p>
<p><img src="/.io//image-20241011222513493.png" alt="image-20241011222513493"></p>
<p>然后使用dump工具，把当前工具dump下来然后使用MAT工具进行一个分析</p>
<p>如果dump文件比较大呢可以使用轻量级的在线分析工具及jmap</p>
<p>MAT工具会自动分析dump文件的内容，给出一个分析结果并定位到有问题的类，然后我们根据分析的结果找到对应的代码进行就可以了</p>
<p>&#x3D;&#x3D;一般可能是循环引用，内存对象泄漏没有被销毁，动态分配内存以后未被释放，长期持有对象引用，资源未被关闭&#x3D;&#x3D;</p>
<h2 id="分布式系统中，如何回答锁得实现原理"><a href="#分布式系统中，如何回答锁得实现原理" class="headerlink" title="分布式系统中，如何回答锁得实现原理"></a>分布式系统中，如何回答锁得实现原理</h2><p><img src="/.io//image-20241014105008442.png" alt="image-20241014105008442"></p>
<p><img src="/.io//image-20241014105044132.png" alt="image-20241014105044132"></p>
<p><img src="/.io//image-20241014105105737.png" alt="image-20241014105105737"></p>
<p><img src="/.io//image-20241014105226176.png" alt="image-20241014105226176"></p>
<p> <img src="/.io//image-20241014105245412.png" alt="image-20241014105245412"></p>
<h3 id="基于mysql关系型数据库实现分布式锁"><a href="#基于mysql关系型数据库实现分布式锁" class="headerlink" title="基于mysql关系型数据库实现分布式锁"></a>基于mysql关系型数据库实现分布式锁</h3><p><img src="/.io//image-20241014105325811.png" alt="image-20241014105325811"></p>
<p><img src="/.io//image-20241014105355125.png" alt="image-20241014105355125"></p>
<p>&#x3D;&#x3D;这种场景下就会因为相互锁等待产生等待的问题，可以通过超时控制解决交叉死锁的问题，但是性能上是有可能出现等待&#x3D;&#x3D;</p>
<p><img src="/.io//image-20241014105607526.png" alt="image-20241014105607526"></p>
<p><img src="/.io//image-20241014105632841.png" alt="image-20241014105632841"></p>
<blockquote>
<p>在数据库层面select for update是悲观锁，会抑制阻塞事务的提交</p>
<p>为了不消耗资源可以采用基于乐观锁的方式实现，比如：</p>
<p>&#x3D;&#x3D;通过冗余字段添加版本号，基于版本号的方式实现，在select时增加version值，最后在update时检查version值是不是相同&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/.io//image-20241014110033328.png" alt="image-20241014110033328"></p>
<h3 id="基于分布式缓存实现分布式锁"><a href="#基于分布式缓存实现分布式锁" class="headerlink" title="基于分布式缓存实现分布式锁"></a>基于分布式缓存实现分布式锁</h3><p><img src="/.io//image-20241014110252229.png" alt="image-20241014110252229"></p>
<p><img src="/.io//image-20241014110333385.png" alt="image-20241014110333385"></p>
<p>在redis2.6.12中加锁命令和设置锁过期的命令是两个操作，当出现某个线程setnx操作之后还没有来得及设置过期时间线程就挂掉了就会导致设置key一直存在，所以选择redis2.6.12以后的版本和lua脚本</p>
<p><img src="/.io//image-20241014110402811.png" alt="image-20241014110402811"></p>
<p><img src="/.io//image-20241014110656381.png" alt="image-20241014110656381"></p>
<p><img src="/.io//image-20241014110709728.png" alt="image-20241014110709728"></p>
<blockquote>
<p>由于redis的过期时间设置不可靠以及redis的数据同步机制都会导致不可靠</p>
</blockquote>
<p><img src="/.io//image-20241014110840002.png" alt="image-20241014110840002"></p>
<blockquote>
<p>基于续约的方式去设置超时时间（写一个守护线程去判断锁的情况）</p>
</blockquote>
<p>由于redis集群同步到各个节点是异步的，如果在redis主节点获取到锁后没有同步到其他节点时，redis宕机了，此时新的redis主节点依然可以获取到锁，所以多个应用器就有可能同时获取到锁，所以有了redlock</p>
<p><img src="/.io//image-20241014111205656.png" alt="image-20241014111205656"></p>
<p>在集群中申请半数的集群节点加，所以单个的掉点是不影响的</p>
<p><img src="/.io//image-20241014111321387.png" alt="image-20241014111321387"></p>
<p><img src="/.io//image-20241014111332391.png" alt="image-20241014111332391"></p>
<p><img src="/.io//image-20241014111449789.png" alt="image-20241014111449789"></p>
<h3 id="zookeeper是如何设计解决的？它的优缺点是什么？"><a href="#zookeeper是如何设计解决的？它的优缺点是什么？" class="headerlink" title="zookeeper是如何设计解决的？它的优缺点是什么？"></a>zookeeper是如何设计解决的？它的优缺点是什么？</h3><p><img src="/.io//image-20241014111625999.png" alt="image-20241014111625999"></p>
<blockquote>
<p>zookeeper类似一个具有层次关系的文件系统每一个节点代表k-v结构的数据，节点有一些特性：</p>
<p>1.同一级节点不能存在重复的数据</p>
<p>2.提供了有序节点的特性，可以根据创建的先后分配一个有序的编号</p>
</blockquote>
<p>&#x3D;&#x3D;我们可以根据zookeeper中的有序节点实现分布式锁&#x3D;&#x3D;</p>
<p><img src="/.io//image-20241014111845939.png" alt="image-20241014111845939"></p>
<p>1.在zookeeper上创建要给持久化的节点叫<code>exclusive_lock</code>作为锁的根节点</p>
<p>2.每个客户端去竞争锁的时候直接在根节点下面创建要给临时有序节点</p>
<p><img src="/.io//image-20241014112027842.png" alt="image-20241014112027842"></p>
<p>节点的名称以“lock-1”为前缀自动加上zookeeper生成的一个序列号</p>
<p>3.在判断当前竞争锁的进程创建的节点在所有子节点是不是最小的，如果是就表示获得锁成功</p>
<p><img src="/.io//image-20241014112226968.png" alt="image-20241014112226968"></p>
<p>当前客户端需要监听自己在zookeeper上创建的节点的前一个节点的删除事件，这样当前面的节点释放锁之后，就会触发一个事件通知我，那么我就可以再一次去尝试去获取锁</p>
<p>&#x3D;&#x3D;除此之外，还可以利用同一节点的唯一性来实现分布式锁&#x3D;&#x3D;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://nil0330.github.io/2024/11/04/%E9%9D%A2%E8%AF%95test/" data-id="cm330admi0000pouv4hxtbo69" data-title="面试test" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IM/" rel="tag">IM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E6%8A%96%E9%9F%B3/" rel="tag">小抖音</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/11/14/learn-github/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          learn_github
        
      </div>
    </a>
  
  
    <a href="/2024/11/03/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IM/" rel="tag">IM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%96%E9%9F%B3/" rel="tag">小抖音</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/IM/" style="font-size: 10px;">IM</a> <a href="/tags/%E5%B0%8F%E6%8A%96%E9%9F%B3/" style="font-size: 10px;">小抖音</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/14/learn-github/">learn_github</a>
          </li>
        
          <li>
            <a href="/2024/11/04/%E9%9D%A2%E8%AF%95test/">面试test</a>
          </li>
        
          <li>
            <a href="/2024/11/03/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 tfy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>